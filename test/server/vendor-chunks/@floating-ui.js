"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@floating-ui";
exports.ids = ["vendor-chunks/@floating-ui"];
exports.modules = {

/***/ "(ssr)/./node_modules/@floating-ui/core/dist/floating-ui.core.mjs":
/*!******************************************************************!*\
  !*** ./node_modules/@floating-ui/core/dist/floating-ui.core.mjs ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   arrow: () => (/* binding */ arrow),\n/* harmony export */   autoPlacement: () => (/* binding */ autoPlacement),\n/* harmony export */   computePosition: () => (/* binding */ computePosition),\n/* harmony export */   detectOverflow: () => (/* binding */ detectOverflow),\n/* harmony export */   flip: () => (/* binding */ flip),\n/* harmony export */   hide: () => (/* binding */ hide),\n/* harmony export */   inline: () => (/* binding */ inline),\n/* harmony export */   limitShift: () => (/* binding */ limitShift),\n/* harmony export */   offset: () => (/* binding */ offset),\n/* harmony export */   rectToClientRect: () => (/* reexport safe */ _floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.rectToClientRect),\n/* harmony export */   shift: () => (/* binding */ shift),\n/* harmony export */   size: () => (/* binding */ size)\n/* harmony export */ });\n/* harmony import */ var _floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @floating-ui/utils */ \"(ssr)/./node_modules/@floating-ui/utils/dist/floating-ui.utils.mjs\");\n\n\nfunction computeCoordsFromPlacement(_ref, placement, rtl) {\n    let { reference, floating } = _ref;\n    const sideAxis = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getSideAxis)(placement);\n    const alignmentAxis = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getAlignmentAxis)(placement);\n    const alignLength = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getAxisLength)(alignmentAxis);\n    const side = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getSide)(placement);\n    const isVertical = sideAxis === \"y\";\n    const commonX = reference.x + reference.width / 2 - floating.width / 2;\n    const commonY = reference.y + reference.height / 2 - floating.height / 2;\n    const commonAlign = reference[alignLength] / 2 - floating[alignLength] / 2;\n    let coords;\n    switch(side){\n        case \"top\":\n            coords = {\n                x: commonX,\n                y: reference.y - floating.height\n            };\n            break;\n        case \"bottom\":\n            coords = {\n                x: commonX,\n                y: reference.y + reference.height\n            };\n            break;\n        case \"right\":\n            coords = {\n                x: reference.x + reference.width,\n                y: commonY\n            };\n            break;\n        case \"left\":\n            coords = {\n                x: reference.x - floating.width,\n                y: commonY\n            };\n            break;\n        default:\n            coords = {\n                x: reference.x,\n                y: reference.y\n            };\n    }\n    switch((0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getAlignment)(placement)){\n        case \"start\":\n            coords[alignmentAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);\n            break;\n        case \"end\":\n            coords[alignmentAxis] += commonAlign * (rtl && isVertical ? -1 : 1);\n            break;\n    }\n    return coords;\n}\n/**\n * Computes the `x` and `y` coordinates that will place the floating element\n * next to a given reference element.\n *\n * This export does not have any `platform` interface logic. You will need to\n * write one for the platform you are using Floating UI with.\n */ const computePosition = async (reference, floating, config)=>{\n    const { placement = \"bottom\", strategy = \"absolute\", middleware = [], platform } = config;\n    const validMiddleware = middleware.filter(Boolean);\n    const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(floating));\n    let rects = await platform.getElementRects({\n        reference,\n        floating,\n        strategy\n    });\n    let { x, y } = computeCoordsFromPlacement(rects, placement, rtl);\n    let statefulPlacement = placement;\n    let middlewareData = {};\n    let resetCount = 0;\n    for(let i = 0; i < validMiddleware.length; i++){\n        const { name, fn } = validMiddleware[i];\n        const { x: nextX, y: nextY, data, reset } = await fn({\n            x,\n            y,\n            initialPlacement: placement,\n            placement: statefulPlacement,\n            strategy,\n            middlewareData,\n            rects,\n            platform,\n            elements: {\n                reference,\n                floating\n            }\n        });\n        x = nextX != null ? nextX : x;\n        y = nextY != null ? nextY : y;\n        middlewareData = {\n            ...middlewareData,\n            [name]: {\n                ...middlewareData[name],\n                ...data\n            }\n        };\n        if (reset && resetCount <= 50) {\n            resetCount++;\n            if (typeof reset === \"object\") {\n                if (reset.placement) {\n                    statefulPlacement = reset.placement;\n                }\n                if (reset.rects) {\n                    rects = reset.rects === true ? await platform.getElementRects({\n                        reference,\n                        floating,\n                        strategy\n                    }) : reset.rects;\n                }\n                ({ x, y } = computeCoordsFromPlacement(rects, statefulPlacement, rtl));\n            }\n            i = -1;\n        }\n    }\n    return {\n        x,\n        y,\n        placement: statefulPlacement,\n        strategy,\n        middlewareData\n    };\n};\n/**\n * Resolves with an object of overflow side offsets that determine how much the\n * element is overflowing a given clipping boundary on each side.\n * - positive = overflowing the boundary by that number of pixels\n * - negative = how many pixels left before it will overflow\n * - 0 = lies flush with the boundary\n * @see https://floating-ui.com/docs/detectOverflow\n */ async function detectOverflow(state, options) {\n    var _await$platform$isEle;\n    if (options === void 0) {\n        options = {};\n    }\n    const { x, y, platform, rects, elements, strategy } = state;\n    const { boundary = \"clippingAncestors\", rootBoundary = \"viewport\", elementContext = \"floating\", altBoundary = false, padding = 0 } = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.evaluate)(options, state);\n    const paddingObject = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getPaddingObject)(padding);\n    const altContext = elementContext === \"floating\" ? \"reference\" : \"floating\";\n    const element = elements[altBoundary ? altContext : elementContext];\n    const clippingClientRect = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.rectToClientRect)(await platform.getClippingRect({\n        element: ((_await$platform$isEle = await (platform.isElement == null ? void 0 : platform.isElement(element))) != null ? _await$platform$isEle : true) ? element : element.contextElement || await (platform.getDocumentElement == null ? void 0 : platform.getDocumentElement(elements.floating)),\n        boundary,\n        rootBoundary,\n        strategy\n    }));\n    const rect = elementContext === \"floating\" ? {\n        ...rects.floating,\n        x,\n        y\n    } : rects.reference;\n    const offsetParent = await (platform.getOffsetParent == null ? void 0 : platform.getOffsetParent(elements.floating));\n    const offsetScale = await (platform.isElement == null ? void 0 : platform.isElement(offsetParent)) ? await (platform.getScale == null ? void 0 : platform.getScale(offsetParent)) || {\n        x: 1,\n        y: 1\n    } : {\n        x: 1,\n        y: 1\n    };\n    const elementClientRect = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.rectToClientRect)(platform.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform.convertOffsetParentRelativeRectToViewportRelativeRect({\n        elements,\n        rect,\n        offsetParent,\n        strategy\n    }) : rect);\n    return {\n        top: (clippingClientRect.top - elementClientRect.top + paddingObject.top) / offsetScale.y,\n        bottom: (elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom) / offsetScale.y,\n        left: (clippingClientRect.left - elementClientRect.left + paddingObject.left) / offsetScale.x,\n        right: (elementClientRect.right - clippingClientRect.right + paddingObject.right) / offsetScale.x\n    };\n}\n/**\n * Provides data to position an inner element of the floating element so that it\n * appears centered to the reference element.\n * @see https://floating-ui.com/docs/arrow\n */ const arrow = (options)=>({\n        name: \"arrow\",\n        options,\n        async fn (state) {\n            const { x, y, placement, rects, platform, elements, middlewareData } = state;\n            // Since `element` is required, we don't Partial<> the type.\n            const { element, padding = 0 } = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.evaluate)(options, state) || {};\n            if (element == null) {\n                return {};\n            }\n            const paddingObject = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getPaddingObject)(padding);\n            const coords = {\n                x,\n                y\n            };\n            const axis = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getAlignmentAxis)(placement);\n            const length = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getAxisLength)(axis);\n            const arrowDimensions = await platform.getDimensions(element);\n            const isYAxis = axis === \"y\";\n            const minProp = isYAxis ? \"top\" : \"left\";\n            const maxProp = isYAxis ? \"bottom\" : \"right\";\n            const clientProp = isYAxis ? \"clientHeight\" : \"clientWidth\";\n            const endDiff = rects.reference[length] + rects.reference[axis] - coords[axis] - rects.floating[length];\n            const startDiff = coords[axis] - rects.reference[axis];\n            const arrowOffsetParent = await (platform.getOffsetParent == null ? void 0 : platform.getOffsetParent(element));\n            let clientSize = arrowOffsetParent ? arrowOffsetParent[clientProp] : 0;\n            // DOM platform can return `window` as the `offsetParent`.\n            if (!clientSize || !await (platform.isElement == null ? void 0 : platform.isElement(arrowOffsetParent))) {\n                clientSize = elements.floating[clientProp] || rects.floating[length];\n            }\n            const centerToReference = endDiff / 2 - startDiff / 2;\n            // If the padding is large enough that it causes the arrow to no longer be\n            // centered, modify the padding so that it is centered.\n            const largestPossiblePadding = clientSize / 2 - arrowDimensions[length] / 2 - 1;\n            const minPadding = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.min)(paddingObject[minProp], largestPossiblePadding);\n            const maxPadding = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.min)(paddingObject[maxProp], largestPossiblePadding);\n            // Make sure the arrow doesn't overflow the floating element if the center\n            // point is outside the floating element's bounds.\n            const min$1 = minPadding;\n            const max = clientSize - arrowDimensions[length] - maxPadding;\n            const center = clientSize / 2 - arrowDimensions[length] / 2 + centerToReference;\n            const offset = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.clamp)(min$1, center, max);\n            // If the reference is small enough that the arrow's padding causes it to\n            // to point to nothing for an aligned placement, adjust the offset of the\n            // floating element itself. To ensure `shift()` continues to take action,\n            // a single reset is performed when this is true.\n            const shouldAddOffset = !middlewareData.arrow && (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getAlignment)(placement) != null && center !== offset && rects.reference[length] / 2 - (center < min$1 ? minPadding : maxPadding) - arrowDimensions[length] / 2 < 0;\n            const alignmentOffset = shouldAddOffset ? center < min$1 ? center - min$1 : center - max : 0;\n            return {\n                [axis]: coords[axis] + alignmentOffset,\n                data: {\n                    [axis]: offset,\n                    centerOffset: center - offset - alignmentOffset,\n                    ...shouldAddOffset && {\n                        alignmentOffset\n                    }\n                },\n                reset: shouldAddOffset\n            };\n        }\n    });\nfunction getPlacementList(alignment, autoAlignment, allowedPlacements) {\n    const allowedPlacementsSortedByAlignment = alignment ? [\n        ...allowedPlacements.filter((placement)=>(0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getAlignment)(placement) === alignment),\n        ...allowedPlacements.filter((placement)=>(0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getAlignment)(placement) !== alignment)\n    ] : allowedPlacements.filter((placement)=>(0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getSide)(placement) === placement);\n    return allowedPlacementsSortedByAlignment.filter((placement)=>{\n        if (alignment) {\n            return (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getAlignment)(placement) === alignment || (autoAlignment ? (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getOppositeAlignmentPlacement)(placement) !== placement : false);\n        }\n        return true;\n    });\n}\n/**\n * Optimizes the visibility of the floating element by choosing the placement\n * that has the most space available automatically, without needing to specify a\n * preferred placement. Alternative to `flip`.\n * @see https://floating-ui.com/docs/autoPlacement\n */ const autoPlacement = function(options) {\n    if (options === void 0) {\n        options = {};\n    }\n    return {\n        name: \"autoPlacement\",\n        options,\n        async fn (state) {\n            var _middlewareData$autoP, _middlewareData$autoP2, _placementsThatFitOnE;\n            const { rects, middlewareData, placement, platform, elements } = state;\n            const { crossAxis = false, alignment, allowedPlacements = _floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.placements, autoAlignment = true, ...detectOverflowOptions } = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.evaluate)(options, state);\n            const placements$1 = alignment !== undefined || allowedPlacements === _floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.placements ? getPlacementList(alignment || null, autoAlignment, allowedPlacements) : allowedPlacements;\n            const overflow = await detectOverflow(state, detectOverflowOptions);\n            const currentIndex = ((_middlewareData$autoP = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP.index) || 0;\n            const currentPlacement = placements$1[currentIndex];\n            if (currentPlacement == null) {\n                return {};\n            }\n            const alignmentSides = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getAlignmentSides)(currentPlacement, rects, await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating)));\n            // Make `computeCoords` start from the right place.\n            if (placement !== currentPlacement) {\n                return {\n                    reset: {\n                        placement: placements$1[0]\n                    }\n                };\n            }\n            const currentOverflows = [\n                overflow[(0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getSide)(currentPlacement)],\n                overflow[alignmentSides[0]],\n                overflow[alignmentSides[1]]\n            ];\n            const allOverflows = [\n                ...((_middlewareData$autoP2 = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP2.overflows) || [],\n                {\n                    placement: currentPlacement,\n                    overflows: currentOverflows\n                }\n            ];\n            const nextPlacement = placements$1[currentIndex + 1];\n            // There are more placements to check.\n            if (nextPlacement) {\n                return {\n                    data: {\n                        index: currentIndex + 1,\n                        overflows: allOverflows\n                    },\n                    reset: {\n                        placement: nextPlacement\n                    }\n                };\n            }\n            const placementsSortedByMostSpace = allOverflows.map((d)=>{\n                const alignment = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getAlignment)(d.placement);\n                return [\n                    d.placement,\n                    alignment && crossAxis ? // Check along the mainAxis and main crossAxis side.\n                    d.overflows.slice(0, 2).reduce((acc, v)=>acc + v, 0) : // Check only the mainAxis.\n                    d.overflows[0],\n                    d.overflows\n                ];\n            }).sort((a, b)=>a[1] - b[1]);\n            const placementsThatFitOnEachSide = placementsSortedByMostSpace.filter((d)=>d[2].slice(0, // Aligned placements should not check their opposite crossAxis\n                // side.\n                (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getAlignment)(d[0]) ? 2 : 3).every((v)=>v <= 0));\n            const resetPlacement = ((_placementsThatFitOnE = placementsThatFitOnEachSide[0]) == null ? void 0 : _placementsThatFitOnE[0]) || placementsSortedByMostSpace[0][0];\n            if (resetPlacement !== placement) {\n                return {\n                    data: {\n                        index: currentIndex + 1,\n                        overflows: allOverflows\n                    },\n                    reset: {\n                        placement: resetPlacement\n                    }\n                };\n            }\n            return {};\n        }\n    };\n};\n/**\n * Optimizes the visibility of the floating element by flipping the `placement`\n * in order to keep it in view when the preferred placement(s) will overflow the\n * clipping boundary. Alternative to `autoPlacement`.\n * @see https://floating-ui.com/docs/flip\n */ const flip = function(options) {\n    if (options === void 0) {\n        options = {};\n    }\n    return {\n        name: \"flip\",\n        options,\n        async fn (state) {\n            var _middlewareData$arrow, _middlewareData$flip;\n            const { placement, middlewareData, rects, initialPlacement, platform, elements } = state;\n            const { mainAxis: checkMainAxis = true, crossAxis: checkCrossAxis = true, fallbackPlacements: specifiedFallbackPlacements, fallbackStrategy = \"bestFit\", fallbackAxisSideDirection = \"none\", flipAlignment = true, ...detectOverflowOptions } = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.evaluate)(options, state);\n            // If a reset by the arrow was caused due to an alignment offset being\n            // added, we should skip any logic now since `flip()` has already done its\n            // work.\n            // https://github.com/floating-ui/floating-ui/issues/2549#issuecomment-1719601643\n            if ((_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {\n                return {};\n            }\n            const side = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getSide)(placement);\n            const isBasePlacement = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getSide)(initialPlacement) === initialPlacement;\n            const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating));\n            const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [\n                (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getOppositePlacement)(initialPlacement)\n            ] : (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getExpandedPlacements)(initialPlacement));\n            if (!specifiedFallbackPlacements && fallbackAxisSideDirection !== \"none\") {\n                fallbackPlacements.push(...(0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getOppositeAxisPlacements)(initialPlacement, flipAlignment, fallbackAxisSideDirection, rtl));\n            }\n            const placements = [\n                initialPlacement,\n                ...fallbackPlacements\n            ];\n            const overflow = await detectOverflow(state, detectOverflowOptions);\n            const overflows = [];\n            let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];\n            if (checkMainAxis) {\n                overflows.push(overflow[side]);\n            }\n            if (checkCrossAxis) {\n                const sides = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getAlignmentSides)(placement, rects, rtl);\n                overflows.push(overflow[sides[0]], overflow[sides[1]]);\n            }\n            overflowsData = [\n                ...overflowsData,\n                {\n                    placement,\n                    overflows\n                }\n            ];\n            // One or more sides is overflowing.\n            if (!overflows.every((side)=>side <= 0)) {\n                var _middlewareData$flip2, _overflowsData$filter;\n                const nextIndex = (((_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) || 0) + 1;\n                const nextPlacement = placements[nextIndex];\n                if (nextPlacement) {\n                    // Try next placement and re-run the lifecycle.\n                    return {\n                        data: {\n                            index: nextIndex,\n                            overflows: overflowsData\n                        },\n                        reset: {\n                            placement: nextPlacement\n                        }\n                    };\n                }\n                // First, find the candidates that fit on the mainAxis side of overflow,\n                // then find the placement that fits the best on the main crossAxis side.\n                let resetPlacement = (_overflowsData$filter = overflowsData.filter((d)=>d.overflows[0] <= 0).sort((a, b)=>a.overflows[1] - b.overflows[1])[0]) == null ? void 0 : _overflowsData$filter.placement;\n                // Otherwise fallback.\n                if (!resetPlacement) {\n                    switch(fallbackStrategy){\n                        case \"bestFit\":\n                            {\n                                var _overflowsData$map$so;\n                                const placement = (_overflowsData$map$so = overflowsData.map((d)=>[\n                                        d.placement,\n                                        d.overflows.filter((overflow)=>overflow > 0).reduce((acc, overflow)=>acc + overflow, 0)\n                                    ]).sort((a, b)=>a[1] - b[1])[0]) == null ? void 0 : _overflowsData$map$so[0];\n                                if (placement) {\n                                    resetPlacement = placement;\n                                }\n                                break;\n                            }\n                        case \"initialPlacement\":\n                            resetPlacement = initialPlacement;\n                            break;\n                    }\n                }\n                if (placement !== resetPlacement) {\n                    return {\n                        reset: {\n                            placement: resetPlacement\n                        }\n                    };\n                }\n            }\n            return {};\n        }\n    };\n};\nfunction getSideOffsets(overflow, rect) {\n    return {\n        top: overflow.top - rect.height,\n        right: overflow.right - rect.width,\n        bottom: overflow.bottom - rect.height,\n        left: overflow.left - rect.width\n    };\n}\nfunction isAnySideFullyClipped(overflow) {\n    return _floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.sides.some((side)=>overflow[side] >= 0);\n}\n/**\n * Provides data to hide the floating element in applicable situations, such as\n * when it is not in the same clipping context as the reference element.\n * @see https://floating-ui.com/docs/hide\n */ const hide = function(options) {\n    if (options === void 0) {\n        options = {};\n    }\n    return {\n        name: \"hide\",\n        options,\n        async fn (state) {\n            const { rects } = state;\n            const { strategy = \"referenceHidden\", ...detectOverflowOptions } = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.evaluate)(options, state);\n            switch(strategy){\n                case \"referenceHidden\":\n                    {\n                        const overflow = await detectOverflow(state, {\n                            ...detectOverflowOptions,\n                            elementContext: \"reference\"\n                        });\n                        const offsets = getSideOffsets(overflow, rects.reference);\n                        return {\n                            data: {\n                                referenceHiddenOffsets: offsets,\n                                referenceHidden: isAnySideFullyClipped(offsets)\n                            }\n                        };\n                    }\n                case \"escaped\":\n                    {\n                        const overflow = await detectOverflow(state, {\n                            ...detectOverflowOptions,\n                            altBoundary: true\n                        });\n                        const offsets = getSideOffsets(overflow, rects.floating);\n                        return {\n                            data: {\n                                escapedOffsets: offsets,\n                                escaped: isAnySideFullyClipped(offsets)\n                            }\n                        };\n                    }\n                default:\n                    {\n                        return {};\n                    }\n            }\n        }\n    };\n};\nfunction getBoundingRect(rects) {\n    const minX = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.min)(...rects.map((rect)=>rect.left));\n    const minY = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.min)(...rects.map((rect)=>rect.top));\n    const maxX = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.max)(...rects.map((rect)=>rect.right));\n    const maxY = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.max)(...rects.map((rect)=>rect.bottom));\n    return {\n        x: minX,\n        y: minY,\n        width: maxX - minX,\n        height: maxY - minY\n    };\n}\nfunction getRectsByLine(rects) {\n    const sortedRects = rects.slice().sort((a, b)=>a.y - b.y);\n    const groups = [];\n    let prevRect = null;\n    for(let i = 0; i < sortedRects.length; i++){\n        const rect = sortedRects[i];\n        if (!prevRect || rect.y - prevRect.y > prevRect.height / 2) {\n            groups.push([\n                rect\n            ]);\n        } else {\n            groups[groups.length - 1].push(rect);\n        }\n        prevRect = rect;\n    }\n    return groups.map((rect)=>(0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.rectToClientRect)(getBoundingRect(rect)));\n}\n/**\n * Provides improved positioning for inline reference elements that can span\n * over multiple lines, such as hyperlinks or range selections.\n * @see https://floating-ui.com/docs/inline\n */ const inline = function(options) {\n    if (options === void 0) {\n        options = {};\n    }\n    return {\n        name: \"inline\",\n        options,\n        async fn (state) {\n            const { placement, elements, rects, platform, strategy } = state;\n            // A MouseEvent's client{X,Y} coords can be up to 2 pixels off a\n            // ClientRect's bounds, despite the event listener being triggered. A\n            // padding of 2 seems to handle this issue.\n            const { padding = 2, x, y } = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.evaluate)(options, state);\n            const nativeClientRects = Array.from(await (platform.getClientRects == null ? void 0 : platform.getClientRects(elements.reference)) || []);\n            const clientRects = getRectsByLine(nativeClientRects);\n            const fallback = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.rectToClientRect)(getBoundingRect(nativeClientRects));\n            const paddingObject = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getPaddingObject)(padding);\n            function getBoundingClientRect() {\n                // There are two rects and they are disjoined.\n                if (clientRects.length === 2 && clientRects[0].left > clientRects[1].right && x != null && y != null) {\n                    // Find the first rect in which the point is fully inside.\n                    return clientRects.find((rect)=>x > rect.left - paddingObject.left && x < rect.right + paddingObject.right && y > rect.top - paddingObject.top && y < rect.bottom + paddingObject.bottom) || fallback;\n                }\n                // There are 2 or more connected rects.\n                if (clientRects.length >= 2) {\n                    if ((0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getSideAxis)(placement) === \"y\") {\n                        const firstRect = clientRects[0];\n                        const lastRect = clientRects[clientRects.length - 1];\n                        const isTop = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getSide)(placement) === \"top\";\n                        const top = firstRect.top;\n                        const bottom = lastRect.bottom;\n                        const left = isTop ? firstRect.left : lastRect.left;\n                        const right = isTop ? firstRect.right : lastRect.right;\n                        const width = right - left;\n                        const height = bottom - top;\n                        return {\n                            top,\n                            bottom,\n                            left,\n                            right,\n                            width,\n                            height,\n                            x: left,\n                            y: top\n                        };\n                    }\n                    const isLeftSide = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getSide)(placement) === \"left\";\n                    const maxRight = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.max)(...clientRects.map((rect)=>rect.right));\n                    const minLeft = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.min)(...clientRects.map((rect)=>rect.left));\n                    const measureRects = clientRects.filter((rect)=>isLeftSide ? rect.left === minLeft : rect.right === maxRight);\n                    const top = measureRects[0].top;\n                    const bottom = measureRects[measureRects.length - 1].bottom;\n                    const left = minLeft;\n                    const right = maxRight;\n                    const width = right - left;\n                    const height = bottom - top;\n                    return {\n                        top,\n                        bottom,\n                        left,\n                        right,\n                        width,\n                        height,\n                        x: left,\n                        y: top\n                    };\n                }\n                return fallback;\n            }\n            const resetRects = await platform.getElementRects({\n                reference: {\n                    getBoundingClientRect\n                },\n                floating: elements.floating,\n                strategy\n            });\n            if (rects.reference.x !== resetRects.reference.x || rects.reference.y !== resetRects.reference.y || rects.reference.width !== resetRects.reference.width || rects.reference.height !== resetRects.reference.height) {\n                return {\n                    reset: {\n                        rects: resetRects\n                    }\n                };\n            }\n            return {};\n        }\n    };\n};\n// For type backwards-compatibility, the `OffsetOptions` type was also\n// Derivable.\nasync function convertValueToCoords(state, options) {\n    const { placement, platform, elements } = state;\n    const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating));\n    const side = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getSide)(placement);\n    const alignment = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getAlignment)(placement);\n    const isVertical = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getSideAxis)(placement) === \"y\";\n    const mainAxisMulti = [\n        \"left\",\n        \"top\"\n    ].includes(side) ? -1 : 1;\n    const crossAxisMulti = rtl && isVertical ? -1 : 1;\n    const rawValue = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.evaluate)(options, state);\n    let { mainAxis, crossAxis, alignmentAxis } = typeof rawValue === \"number\" ? {\n        mainAxis: rawValue,\n        crossAxis: 0,\n        alignmentAxis: null\n    } : {\n        mainAxis: 0,\n        crossAxis: 0,\n        alignmentAxis: null,\n        ...rawValue\n    };\n    if (alignment && typeof alignmentAxis === \"number\") {\n        crossAxis = alignment === \"end\" ? alignmentAxis * -1 : alignmentAxis;\n    }\n    return isVertical ? {\n        x: crossAxis * crossAxisMulti,\n        y: mainAxis * mainAxisMulti\n    } : {\n        x: mainAxis * mainAxisMulti,\n        y: crossAxis * crossAxisMulti\n    };\n}\n/**\n * Modifies the placement by translating the floating element along the\n * specified axes.\n * A number (shorthand for `mainAxis` or distance), or an axes configuration\n * object may be passed.\n * @see https://floating-ui.com/docs/offset\n */ const offset = function(options) {\n    if (options === void 0) {\n        options = 0;\n    }\n    return {\n        name: \"offset\",\n        options,\n        async fn (state) {\n            var _middlewareData$offse, _middlewareData$arrow;\n            const { x, y, placement, middlewareData } = state;\n            const diffCoords = await convertValueToCoords(state, options);\n            // If the placement is the same and the arrow caused an alignment offset\n            // then we don't need to change the positioning coordinates.\n            if (placement === ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse.placement) && (_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {\n                return {};\n            }\n            return {\n                x: x + diffCoords.x,\n                y: y + diffCoords.y,\n                data: {\n                    ...diffCoords,\n                    placement\n                }\n            };\n        }\n    };\n};\n/**\n * Optimizes the visibility of the floating element by shifting it in order to\n * keep it in view when it will overflow the clipping boundary.\n * @see https://floating-ui.com/docs/shift\n */ const shift = function(options) {\n    if (options === void 0) {\n        options = {};\n    }\n    return {\n        name: \"shift\",\n        options,\n        async fn (state) {\n            const { x, y, placement } = state;\n            const { mainAxis: checkMainAxis = true, crossAxis: checkCrossAxis = false, limiter = {\n                fn: (_ref)=>{\n                    let { x, y } = _ref;\n                    return {\n                        x,\n                        y\n                    };\n                }\n            }, ...detectOverflowOptions } = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.evaluate)(options, state);\n            const coords = {\n                x,\n                y\n            };\n            const overflow = await detectOverflow(state, detectOverflowOptions);\n            const crossAxis = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getSideAxis)((0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getSide)(placement));\n            const mainAxis = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getOppositeAxis)(crossAxis);\n            let mainAxisCoord = coords[mainAxis];\n            let crossAxisCoord = coords[crossAxis];\n            if (checkMainAxis) {\n                const minSide = mainAxis === \"y\" ? \"top\" : \"left\";\n                const maxSide = mainAxis === \"y\" ? \"bottom\" : \"right\";\n                const min = mainAxisCoord + overflow[minSide];\n                const max = mainAxisCoord - overflow[maxSide];\n                mainAxisCoord = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.clamp)(min, mainAxisCoord, max);\n            }\n            if (checkCrossAxis) {\n                const minSide = crossAxis === \"y\" ? \"top\" : \"left\";\n                const maxSide = crossAxis === \"y\" ? \"bottom\" : \"right\";\n                const min = crossAxisCoord + overflow[minSide];\n                const max = crossAxisCoord - overflow[maxSide];\n                crossAxisCoord = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.clamp)(min, crossAxisCoord, max);\n            }\n            const limitedCoords = limiter.fn({\n                ...state,\n                [mainAxis]: mainAxisCoord,\n                [crossAxis]: crossAxisCoord\n            });\n            return {\n                ...limitedCoords,\n                data: {\n                    x: limitedCoords.x - x,\n                    y: limitedCoords.y - y\n                }\n            };\n        }\n    };\n};\n/**\n * Built-in `limiter` that will stop `shift()` at a certain point.\n */ const limitShift = function(options) {\n    if (options === void 0) {\n        options = {};\n    }\n    return {\n        options,\n        fn (state) {\n            const { x, y, placement, rects, middlewareData } = state;\n            const { offset = 0, mainAxis: checkMainAxis = true, crossAxis: checkCrossAxis = true } = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.evaluate)(options, state);\n            const coords = {\n                x,\n                y\n            };\n            const crossAxis = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getSideAxis)(placement);\n            const mainAxis = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getOppositeAxis)(crossAxis);\n            let mainAxisCoord = coords[mainAxis];\n            let crossAxisCoord = coords[crossAxis];\n            const rawOffset = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.evaluate)(offset, state);\n            const computedOffset = typeof rawOffset === \"number\" ? {\n                mainAxis: rawOffset,\n                crossAxis: 0\n            } : {\n                mainAxis: 0,\n                crossAxis: 0,\n                ...rawOffset\n            };\n            if (checkMainAxis) {\n                const len = mainAxis === \"y\" ? \"height\" : \"width\";\n                const limitMin = rects.reference[mainAxis] - rects.floating[len] + computedOffset.mainAxis;\n                const limitMax = rects.reference[mainAxis] + rects.reference[len] - computedOffset.mainAxis;\n                if (mainAxisCoord < limitMin) {\n                    mainAxisCoord = limitMin;\n                } else if (mainAxisCoord > limitMax) {\n                    mainAxisCoord = limitMax;\n                }\n            }\n            if (checkCrossAxis) {\n                var _middlewareData$offse, _middlewareData$offse2;\n                const len = mainAxis === \"y\" ? \"width\" : \"height\";\n                const isOriginSide = [\n                    \"top\",\n                    \"left\"\n                ].includes((0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getSide)(placement));\n                const limitMin = rects.reference[crossAxis] - rects.floating[len] + (isOriginSide ? ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse[crossAxis]) || 0 : 0) + (isOriginSide ? 0 : computedOffset.crossAxis);\n                const limitMax = rects.reference[crossAxis] + rects.reference[len] + (isOriginSide ? 0 : ((_middlewareData$offse2 = middlewareData.offset) == null ? void 0 : _middlewareData$offse2[crossAxis]) || 0) - (isOriginSide ? computedOffset.crossAxis : 0);\n                if (crossAxisCoord < limitMin) {\n                    crossAxisCoord = limitMin;\n                } else if (crossAxisCoord > limitMax) {\n                    crossAxisCoord = limitMax;\n                }\n            }\n            return {\n                [mainAxis]: mainAxisCoord,\n                [crossAxis]: crossAxisCoord\n            };\n        }\n    };\n};\n/**\n * Provides data that allows you to change the size of the floating element â€”\n * for instance, prevent it from overflowing the clipping boundary or match the\n * width of the reference element.\n * @see https://floating-ui.com/docs/size\n */ const size = function(options) {\n    if (options === void 0) {\n        options = {};\n    }\n    return {\n        name: \"size\",\n        options,\n        async fn (state) {\n            const { placement, rects, platform, elements } = state;\n            const { apply = ()=>{}, ...detectOverflowOptions } = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.evaluate)(options, state);\n            const overflow = await detectOverflow(state, detectOverflowOptions);\n            const side = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getSide)(placement);\n            const alignment = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getAlignment)(placement);\n            const isYAxis = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getSideAxis)(placement) === \"y\";\n            const { width, height } = rects.floating;\n            let heightSide;\n            let widthSide;\n            if (side === \"top\" || side === \"bottom\") {\n                heightSide = side;\n                widthSide = alignment === (await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating)) ? \"start\" : \"end\") ? \"left\" : \"right\";\n            } else {\n                widthSide = side;\n                heightSide = alignment === \"end\" ? \"top\" : \"bottom\";\n            }\n            const overflowAvailableHeight = height - overflow[heightSide];\n            const overflowAvailableWidth = width - overflow[widthSide];\n            const noShift = !state.middlewareData.shift;\n            let availableHeight = overflowAvailableHeight;\n            let availableWidth = overflowAvailableWidth;\n            if (isYAxis) {\n                const maximumClippingWidth = width - overflow.left - overflow.right;\n                availableWidth = alignment || noShift ? (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.min)(overflowAvailableWidth, maximumClippingWidth) : maximumClippingWidth;\n            } else {\n                const maximumClippingHeight = height - overflow.top - overflow.bottom;\n                availableHeight = alignment || noShift ? (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.min)(overflowAvailableHeight, maximumClippingHeight) : maximumClippingHeight;\n            }\n            if (noShift && !alignment) {\n                const xMin = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.max)(overflow.left, 0);\n                const xMax = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.max)(overflow.right, 0);\n                const yMin = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.max)(overflow.top, 0);\n                const yMax = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.max)(overflow.bottom, 0);\n                if (isYAxis) {\n                    availableWidth = width - 2 * (xMin !== 0 || xMax !== 0 ? xMin + xMax : (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.max)(overflow.left, overflow.right));\n                } else {\n                    availableHeight = height - 2 * (yMin !== 0 || yMax !== 0 ? yMin + yMax : (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.max)(overflow.top, overflow.bottom));\n                }\n            }\n            await apply({\n                ...state,\n                availableWidth,\n                availableHeight\n            });\n            const nextDimensions = await platform.getDimensions(elements.floating);\n            if (width !== nextDimensions.width || height !== nextDimensions.height) {\n                return {\n                    reset: {\n                        rects: true\n                    }\n                };\n            }\n            return {};\n        }\n    };\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGZsb2F0aW5nLXVpL2NvcmUvZGlzdC9mbG9hdGluZy11aS5jb3JlLm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7O0FBQXNVO0FBQ2hSO0FBRXRELFNBQVNtQiwyQkFBMkJDLElBQUksRUFBRUMsU0FBUyxFQUFFQyxHQUFHO0lBQ3RELElBQUksRUFDRkMsU0FBUyxFQUNUQyxRQUFRLEVBQ1QsR0FBR0o7SUFDSixNQUFNSyxXQUFXekIsK0RBQVdBLENBQUNxQjtJQUM3QixNQUFNSyxnQkFBZ0J6QixvRUFBZ0JBLENBQUNvQjtJQUN2QyxNQUFNTSxjQUFjekIsaUVBQWFBLENBQUN3QjtJQUNsQyxNQUFNRSxPQUFPekIsMkRBQU9BLENBQUNrQjtJQUNyQixNQUFNUSxhQUFhSixhQUFhO0lBQ2hDLE1BQU1LLFVBQVVQLFVBQVVRLENBQUMsR0FBR1IsVUFBVVMsS0FBSyxHQUFHLElBQUlSLFNBQVNRLEtBQUssR0FBRztJQUNyRSxNQUFNQyxVQUFVVixVQUFVVyxDQUFDLEdBQUdYLFVBQVVZLE1BQU0sR0FBRyxJQUFJWCxTQUFTVyxNQUFNLEdBQUc7SUFDdkUsTUFBTUMsY0FBY2IsU0FBUyxDQUFDSSxZQUFZLEdBQUcsSUFBSUgsUUFBUSxDQUFDRyxZQUFZLEdBQUc7SUFDekUsSUFBSVU7SUFDSixPQUFRVDtRQUNOLEtBQUs7WUFDSFMsU0FBUztnQkFDUE4sR0FBR0Q7Z0JBQ0hJLEdBQUdYLFVBQVVXLENBQUMsR0FBR1YsU0FBU1csTUFBTTtZQUNsQztZQUNBO1FBQ0YsS0FBSztZQUNIRSxTQUFTO2dCQUNQTixHQUFHRDtnQkFDSEksR0FBR1gsVUFBVVcsQ0FBQyxHQUFHWCxVQUFVWSxNQUFNO1lBQ25DO1lBQ0E7UUFDRixLQUFLO1lBQ0hFLFNBQVM7Z0JBQ1BOLEdBQUdSLFVBQVVRLENBQUMsR0FBR1IsVUFBVVMsS0FBSztnQkFDaENFLEdBQUdEO1lBQ0w7WUFDQTtRQUNGLEtBQUs7WUFDSEksU0FBUztnQkFDUE4sR0FB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Q0w0SSxrQkFBa0JsTSxTQUFTLElBQUt3TSxDQUFBQSxTQUFTLEtBQUtDLFNBQVMsSUFBSUQsT0FBT0MsT0FBTzNOLHVEQUFHQSxDQUFDNEcsU0FBU3ZDLEdBQUcsRUFBRXVDLFNBQVN0QyxNQUFNO2dCQUM1RztZQUNGO1lBQ0EsTUFBTXdJLE1BQU07Z0JBQ1YsR0FBR2hLLEtBQUs7Z0JBQ1J1SztnQkFDQUQ7WUFDRjtZQUNBLE1BQU1RLGlCQUFpQixNQUFNbk0sU0FBU21ELGFBQWEsQ0FBQ2hDLFNBQVNyQyxRQUFRO1lBQ3JFLElBQUlRLFVBQVU2TSxlQUFlN00sS0FBSyxJQUFJRyxXQUFXME0sZUFBZTFNLE1BQU0sRUFBRTtnQkFDdEUsT0FBTztvQkFDTHdCLE9BQU87d0JBQ0xaLE9BQU87b0JBQ1Q7Z0JBQ0Y7WUFDRjtZQUNBLE9BQU8sQ0FBQztRQUNWO0lBQ0Y7QUFDRjtBQUVzSCIsInNvdXJjZXMiOlsid2VicGFjazovL29wZW4tcHJvLW5leHQvLi9ub2RlX21vZHVsZXMvQGZsb2F0aW5nLXVpL2NvcmUvZGlzdC9mbG9hdGluZy11aS5jb3JlLm1qcz81NmJmIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGdldFNpZGVBeGlzLCBnZXRBbGlnbm1lbnRBeGlzLCBnZXRBeGlzTGVuZ3RoLCBnZXRTaWRlLCBnZXRBbGlnbm1lbnQsIGV2YWx1YXRlLCBnZXRQYWRkaW5nT2JqZWN0LCByZWN0VG9DbGllbnRSZWN0LCBtaW4sIGNsYW1wLCBwbGFjZW1lbnRzLCBnZXRBbGlnbm1lbnRTaWRlcywgZ2V0T3Bwb3NpdGVBbGlnbm1lbnRQbGFjZW1lbnQsIGdldE9wcG9zaXRlUGxhY2VtZW50LCBnZXRFeHBhbmRlZFBsYWNlbWVudHMsIGdldE9wcG9zaXRlQXhpc1BsYWNlbWVudHMsIHNpZGVzLCBtYXgsIGdldE9wcG9zaXRlQXhpcyB9IGZyb20gJ0BmbG9hdGluZy11aS91dGlscyc7XG5leHBvcnQgeyByZWN0VG9DbGllbnRSZWN0IH0gZnJvbSAnQGZsb2F0aW5nLXVpL3V0aWxzJztcblxuZnVuY3Rpb24gY29tcHV0ZUNvb3Jkc0Zyb21QbGFjZW1lbnQoX3JlZiwgcGxhY2VtZW50LCBydGwpIHtcbiAgbGV0IHtcbiAgICByZWZlcmVuY2UsXG4gICAgZmxvYXRpbmdcbiAgfSA9IF9yZWY7XG4gIGNvbnN0IHNpZGVBeGlzID0gZ2V0U2lkZUF4aXMocGxhY2VtZW50KTtcbiAgY29uc3QgYWxpZ25tZW50QXhpcyA9IGdldEFsaWdubWVudEF4aXMocGxhY2VtZW50KTtcbiAgY29uc3QgYWxpZ25MZW5ndGggPSBnZXRBeGlzTGVuZ3RoKGFsaWdubWVudEF4aXMpO1xuICBjb25zdCBzaWRlID0gZ2V0U2lkZShwbGFjZW1lbnQpO1xuICBjb25zdCBpc1ZlcnRpY2FsID0gc2lkZUF4aXMgPT09ICd5JztcbiAgY29uc3QgY29tbW9uWCA9IHJlZmVyZW5jZS54ICsgcmVmZXJlbmNlLndpZHRoIC8gMiAtIGZsb2F0aW5nLndpZHRoIC8gMjtcbiAgY29uc3QgY29tbW9uWSA9IHJlZmVyZW5jZS55ICsgcmVmZXJlbmNlLmhlaWdodCAvIDIgLSBmbG9hdGluZy5oZWlnaHQgLyAyO1xuICBjb25zdCBjb21tb25BbGlnbiA9IHJlZmVyZW5jZVthbGlnbkxlbmd0aF0gLyAyIC0gZmxvYXRpbmdbYWxpZ25MZW5ndGhdIC8gMjtcbiAgbGV0IGNvb3JkcztcbiAgc3dpdGNoIChzaWRlKSB7XG4gICAgY2FzZSAndG9wJzpcbiAgICAgIGNvb3JkcyA9IHtcbiAgICAgICAgeDogY29tbW9uWCxcbiAgICAgICAgeTogcmVmZXJlbmNlLnkgLSBmbG9hdGluZy5oZWlnaHRcbiAgICAgIH07XG4gICAgICBicmVhaztcbiAgICBjYXNlICdib3R0b20nOlxuICAgICAgY29vcmRzID0ge1xuICAgICAgICB4OiBjb21tb25YLFxuICAgICAgICB5OiByZWZlcmVuY2UueSArIHJlZmVyZW5jZS5oZWlnaHRcbiAgICAgIH07XG4gICAgICBicmVhaztcbiAgICBjYXNlICdyaWdodCc6XG4gICAgICBjb29yZHMgPSB7XG4gICAgICAgIHg6IHJlZmVyZW5jZS54ICsgcmVmZXJlbmNlLndpZHRoLFxuICAgICAgICB5OiBjb21tb25ZXG4gICAgICB9O1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnbGVmdCc6XG4gICAgICBjb29yZHMgPSB7XG4gICAgICAgIHg6IHJlZmVyZW5jZS54IC0gZmxvYXRpbmcud2lkdGgsXG4gICAgICAgIHk6IGNvbW1vbllcbiAgICAgIH07XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgY29vcmRzID0ge1xuICAgICAgICB4OiByZWZlcmVuY2UueCxcbiAgICAgICAgeTogcmVmZXJlbmNlLnlcbiAgICAgIH07XG4gIH1cbiAgc3dpdGNoIChnZXRBbGlnbm1lbnQocGxhY2VtZW50KSkge1xuICAgIGNhc2UgJ3N0YXJ0JzpcbiAgICAgIGNvb3Jkc1thbGlnbm1lbnRBeGlzXSAtPSBjb21tb25BbGlnbiAqIChydGwgJiYgaXNWZXJ0aWNhbCA/IC0xIDogMSk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdlbmQnOlxuICAgICAgY29vcmRzW2FsaWdubWVudEF4aXNdICs9IGNvbW1vbkFsaWduICogKHJ0bCAmJiBpc1ZlcnRpY2FsID8gLTEgOiAxKTtcbiAgICAgIGJyZWFrO1xuICB9XG4gIHJldHVybiBjb29yZHM7XG59XG5cbi8qKlxuICogQ29tcHV0ZXMgdGhlIGB4YCBhbmQgYHlgIGNvb3JkaW5hdGVzIHRoYXQgd2lsbCBwbGFjZSB0aGUgZmxvYXRpbmcgZWxlbWVudFxuICogbmV4dCB0byBhIGdpdmVuIHJlZmVyZW5jZSBlbGVtZW50LlxuICpcbiAqIFRoaXMgZXhwb3J0IGRvZXMgbm90IGhhdmUgYW55IGBwbGF0Zm9ybWAgaW50ZXJmYWNlIGxvZ2ljLiBZb3Ugd2lsbCBuZWVkIHRvXG4gKiB3cml0ZSBvbmUgZm9yIHRoZSBwbGF0Zm9ybSB5b3UgYXJlIHVzaW5nIEZsb2F0aW5nIFVJIHdpdGguXG4gKi9cbmNvbnN0IGNvbXB1dGVQb3NpdGlvbiA9IGFzeW5jIChyZWZlcmVuY2UsIGZsb2F0aW5nLCBjb25maWcpID0+IHtcbiAgY29uc3Qge1xuICAgIHBsYWNlbWVudCA9ICdib3R0b20nLFxuICAgIHN0cmF0ZWd5ID0gJ2Fic29sdXRlJyxcbiAgICBtaWRkbGV3YXJlID0gW10sXG4gICAgcGxhdGZvcm1cbiAgfSA9IGNvbmZpZztcbiAgY29uc3QgdmFsaWRNaWRkbGV3YXJlID0gbWlkZGxld2FyZS5maWx0ZXIoQm9vbGVhbik7XG4gIGNvbnN0IHJ0bCA9IGF3YWl0IChwbGF0Zm9ybS5pc1JUTCA9PSBudWxsID8gdm9pZCAwIDogcGxhdGZvcm0uaXNSVEwoZmxvYXRpbmcpKTtcbiAgbGV0IHJlY3RzID0gYXdhaXQgcGxhdGZvcm0uZ2V0RWxlbWVudFJlY3RzKHtcbiAgICByZWZlcmVuY2UsXG4gICAgZmxvYXRpbmcsXG4gICAgc3RyYXRlZ3lcbiAgfSk7XG4gIGxldCB7XG4gICAgeCxcbiAgICB5XG4gIH0gPSBjb21wdXRlQ29vcmRzRnJvbVBsYWNlbWVudChyZWN0cywgcGxhY2VtZW50LCBydGwpO1xuICBsZXQgc3RhdGVmdWxQbGFjZW1lbnQgPSBwbGFjZW1lbnQ7XG4gIGxldCBtaWRkbGV3YXJlRGF0YSA9IHt9O1xuICBsZXQgcmVzZXRDb3VudCA9IDA7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsaWRNaWRkbGV3YXJlLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3Qge1xuICAgICAgbmFtZSxcbiAgICAgIGZuXG4gICAgfSA9IHZhbGlkTWlkZGxld2FyZVtpXTtcbiAgICBjb25zdCB7XG4gICAgICB4OiBuZXh0WCxcbiAgICAgIHk6IG5leHRZLFxuICAgICAgZGF0YSxcbiAgICAgIHJlc2V0XG4gICAgfSA9IGF3YWl0IGZuKHtcbiAgICAgIHgsXG4gICAgICB5LFxuICAgICAgaW5pdGlhbFBsYWNlbWVudDogcGxhY2VtZW50LFxuICAgICAgcGxhY2VtZW50OiBzdGF0ZWZ1bFBsYWNlbWVudCxcbiAgICAgIHN0cmF0ZWd5LFxuICAgICAgbWlkZGxld2FyZURhdGEsXG4gICAgICByZWN0cyxcbiAgICAgIHBsYXRmb3JtLFxuICAgICAgZWxlbWVudHM6IHtcbiAgICAgICAgcmVmZXJlbmNlLFxuICAgICAgICBmbG9hdGluZ1xuICAgICAgfVxuICAgIH0pO1xuICAgIHggPSBuZXh0WCAhPSBudWxsID8gbmV4dFggOiB4O1xuICAgIHkgPSBuZXh0WSAhPSBudWxsID8gbmV4dFkgOiB5O1xuICAgIG1pZGRsZXdhcmVEYXRhID0ge1xuICAgICAgLi4ubWlkZGxld2FyZURhdGEsXG4gICAgICBbbmFtZV06IHtcbiAgICAgICAgLi4ubWlkZGxld2FyZURhdGFbbmFtZV0sXG4gICAgICAgIC4uLmRhdGFcbiAgICAgIH1cbiAgICB9O1xuICAgIGlmIChyZXNldCAmJiByZXNldENvdW50IDw9IDUwKSB7XG4gICAgICByZXNldENvdW50Kys7XG4gICAgICBpZiAodHlwZW9mIHJlc2V0ID09PSAnb2JqZWN0Jykge1xuICAgICAgICBpZiAocmVzZXQucGxhY2VtZW50KSB7XG4gICAgICAgICAgc3RhdGVmdWxQbGFjZW1lbnQgPSByZXNldC5wbGFjZW1lbnQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc2V0LnJlY3RzKSB7XG4gICAgICAgICAgcmVjdHMgPSByZXNldC5yZWN0cyA9PT0gdHJ1ZSA/IGF3YWl0IHBsYXRmb3JtLmdldEVsZW1lbnRSZWN0cyh7XG4gICAgICAgICAgICByZWZlcmVuY2UsXG4gICAgICAgICAgICBmbG9hdGluZyxcbiAgICAgICAgICAgIHN0cmF0ZWd5XG4gICAgICAgICAgfSkgOiByZXNldC5yZWN0cztcbiAgICAgICAgfVxuICAgICAgICAoe1xuICAgICAgICAgIHgsXG4gICAgICAgICAgeVxuICAgICAgICB9ID0gY29tcHV0ZUNvb3Jkc0Zyb21QbGFjZW1lbnQocmVjdHMsIHN0YXRlZnVsUGxhY2VtZW50LCBydGwpKTtcbiAgICAgIH1cbiAgICAgIGkgPSAtMTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB4LFxuICAgIHksXG4gICAgcGxhY2VtZW50OiBzdGF0ZWZ1bFBsYWNlbWVudCxcbiAgICBzdHJhdGVneSxcbiAgICBtaWRkbGV3YXJlRGF0YVxuICB9O1xufTtcblxuLyoqXG4gKiBSZXNvbHZlcyB3aXRoIGFuIG9iamVjdCBvZiBvdmVyZmxvdyBzaWRlIG9mZnNldHMgdGhhdCBkZXRlcm1pbmUgaG93IG11Y2ggdGhlXG4gKiBlbGVtZW50IGlzIG92ZXJmbG93aW5nIGEgZ2l2ZW4gY2xpcHBpbmcgYm91bmRhcnkgb24gZWFjaCBzaWRlLlxuICogLSBwb3NpdGl2ZSA9IG92ZXJmbG93aW5nIHRoZSBib3VuZGFyeSBieSB0aGF0IG51bWJlciBvZiBwaXhlbHNcbiAqIC0gbmVnYXRpdmUgPSBob3cgbWFueSBwaXhlbHMgbGVmdCBiZWZvcmUgaXQgd2lsbCBvdmVyZmxvd1xuICogLSAwID0gbGllcyBmbHVzaCB3aXRoIHRoZSBib3VuZGFyeVxuICogQHNlZSBodHRwczovL2Zsb2F0aW5nLXVpLmNvbS9kb2NzL2RldGVjdE92ZXJmbG93XG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGRldGVjdE92ZXJmbG93KHN0YXRlLCBvcHRpb25zKSB7XG4gIHZhciBfYXdhaXQkcGxhdGZvcm0kaXNFbGU7XG4gIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICBvcHRpb25zID0ge307XG4gIH1cbiAgY29uc3Qge1xuICAgIHgsXG4gICAgeSxcbiAgICBwbGF0Zm9ybSxcbiAgICByZWN0cyxcbiAgICBlbGVtZW50cyxcbiAgICBzdHJhdGVneVxuICB9ID0gc3RhdGU7XG4gIGNvbnN0IHtcbiAgICBib3VuZGFyeSA9ICdjbGlwcGluZ0FuY2VzdG9ycycsXG4gICAgcm9vdEJvdW5kYXJ5ID0gJ3ZpZXdwb3J0JyxcbiAgICBlbGVtZW50Q29udGV4dCA9ICdmbG9hdGluZycsXG4gICAgYWx0Qm91bmRhcnkgPSBmYWxzZSxcbiAgICBwYWRkaW5nID0gMFxuICB9ID0gZXZhbHVhdGUob3B0aW9ucywgc3RhdGUpO1xuICBjb25zdCBwYWRkaW5nT2JqZWN0ID0gZ2V0UGFkZGluZ09iamVjdChwYWRkaW5nKTtcbiAgY29uc3QgYWx0Q29udGV4dCA9IGVsZW1lbnRDb250ZXh0ID09PSAnZmxvYXRpbmcnID8gJ3JlZmVyZW5jZScgOiAnZmxvYXRpbmcnO1xuICBjb25zdCBlbGVtZW50ID0gZWxlbWVudHNbYWx0Qm91bmRhcnkgPyBhbHRDb250ZXh0IDogZWxlbWVudENvbnRleHRdO1xuICBjb25zdCBjbGlwcGluZ0NsaWVudFJlY3QgPSByZWN0VG9DbGllbnRSZWN0KGF3YWl0IHBsYXRmb3JtLmdldENsaXBwaW5nUmVjdCh7XG4gICAgZWxlbWVudDogKChfYXdhaXQkcGxhdGZvcm0kaXNFbGUgPSBhd2FpdCAocGxhdGZvcm0uaXNFbGVtZW50ID09IG51bGwgPyB2b2lkIDAgOiBwbGF0Zm9ybS5pc0VsZW1lbnQoZWxlbWVudCkpKSAhPSBudWxsID8gX2F3YWl0JHBsYXRmb3JtJGlzRWxlIDogdHJ1ZSkgPyBlbGVtZW50IDogZWxlbWVudC5jb250ZXh0RWxlbWVudCB8fCAoYXdhaXQgKHBsYXRmb3JtLmdldERvY3VtZW50RWxlbWVudCA9PSBudWxsID8gdm9pZCAwIDogcGxhdGZvcm0uZ2V0RG9jdW1lbnRFbGVtZW50KGVsZW1lbnRzLmZsb2F0aW5nKSkpLFxuICAgIGJvdW5kYXJ5LFxuICAgIHJvb3RCb3VuZGFyeSxcbiAgICBzdHJhdGVneVxuICB9KSk7XG4gIGNvbnN0IHJlY3QgPSBlbGVtZW50Q29udGV4dCA9PT0gJ2Zsb2F0aW5nJyA/IHtcbiAgICAuLi5yZWN0cy5mbG9hdGluZyxcbiAgICB4LFxuICAgIHlcbiAgfSA6IHJlY3RzLnJlZmVyZW5jZTtcbiAgY29uc3Qgb2Zmc2V0UGFyZW50ID0gYXdhaXQgKHBsYXRmb3JtLmdldE9mZnNldFBhcmVudCA9PSBudWxsID8gdm9pZCAwIDogcGxhdGZvcm0uZ2V0T2Zmc2V0UGFyZW50KGVsZW1lbnRzLmZsb2F0aW5nKSk7XG4gIGNvbnN0IG9mZnNldFNjYWxlID0gKGF3YWl0IChwbGF0Zm9ybS5pc0VsZW1lbnQgPT0gbnVsbCA/IHZvaWQgMCA6IHBsYXRmb3JtLmlzRWxlbWVudChvZmZzZXRQYXJlbnQpKSkgPyAoYXdhaXQgKHBsYXRmb3JtLmdldFNjYWxlID09IG51bGwgPyB2b2lkIDAgOiBwbGF0Zm9ybS5nZXRTY2FsZShvZmZzZXRQYXJlbnQpKSkgfHwge1xuICAgIHg6IDEsXG4gICAgeTogMVxuICB9IDoge1xuICAgIHg6IDEsXG4gICAgeTogMVxuICB9O1xuICBjb25zdCBlbGVtZW50Q2xpZW50UmVjdCA9IHJlY3RUb0NsaWVudFJlY3QocGxhdGZvcm0uY29udmVydE9mZnNldFBhcmVudFJlbGF0aXZlUmVjdFRvVmlld3BvcnRSZWxhdGl2ZVJlY3QgPyBhd2FpdCBwbGF0Zm9ybS5jb252ZXJ0T2Zmc2V0UGFyZW50UmVsYXRpdmVSZWN0VG9WaWV3cG9ydFJlbGF0aXZlUmVjdCh7XG4gICAgZWxlbWVudHMsXG4gICAgcmVjdCxcbiAgICBvZmZzZXRQYXJlbnQsXG4gICAgc3RyYXRlZ3lcbiAgfSkgOiByZWN0KTtcbiAgcmV0dXJuIHtcbiAgICB0b3A6IChjbGlwcGluZ0NsaWVudFJlY3QudG9wIC0gZWxlbWVudENsaWVudFJlY3QudG9wICsgcGFkZGluZ09iamVjdC50b3ApIC8gb2Zmc2V0U2NhbGUueSxcbiAgICBib3R0b206IChlbGVtZW50Q2xpZW50UmVjdC5ib3R0b20gLSBjbGlwcGluZ0NsaWVudFJlY3QuYm90dG9tICsgcGFkZGluZ09iamVjdC5ib3R0b20pIC8gb2Zmc2V0U2NhbGUueSxcbiAgICBsZWZ0OiAoY2xpcHBpbmdDbGllbnRSZWN0LmxlZnQgLSBlbGVtZW50Q2xpZW50UmVjdC5sZWZ0ICsgcGFkZGluZ09iamVjdC5sZWZ0KSAvIG9mZnNldFNjYWxlLngsXG4gICAgcmlnaHQ6IChlbGVtZW50Q2xpZW50UmVjdC5yaWdodCAtIGNsaXBwaW5nQ2xpZW50UmVjdC5yaWdodCArIHBhZGRpbmdPYmplY3QucmlnaHQpIC8gb2Zmc2V0U2NhbGUueFxuICB9O1xufVxuXG4vKipcbiAqIFByb3ZpZGVzIGRhdGEgdG8gcG9zaXRpb24gYW4gaW5uZXIgZWxlbWVudCBvZiB0aGUgZmxvYXRpbmcgZWxlbWVudCBzbyB0aGF0IGl0XG4gKiBhcHBlYXJzIGNlbnRlcmVkIHRvIHRoZSByZWZlcmVuY2UgZWxlbWVudC5cbiAqIEBzZWUgaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy9hcnJvd1xuICovXG5jb25zdCBhcnJvdyA9IG9wdGlvbnMgPT4gKHtcbiAgbmFtZTogJ2Fycm93JyxcbiAgb3B0aW9ucyxcbiAgYXN5bmMgZm4oc3RhdGUpIHtcbiAgICBjb25zdCB7XG4gICAgICB4LFxuICAgICAgeSxcbiAgICAgIHBsYWNlbWVudCxcbiAgICAgIHJlY3RzLFxuICAgICAgcGxhdGZvcm0sXG4gICAgICBlbGVtZW50cyxcbiAgICAgIG1pZGRsZXdhcmVEYXRhXG4gICAgfSA9IHN0YXRlO1xuICAgIC8vIFNpbmNlIGBlbGVtZW50YCBpcyByZXF1aXJlZCwgd2UgZG9uJ3QgUGFydGlhbDw+IHRoZSB0eXBlLlxuICAgIGNvbnN0IHtcbiAgICAgIGVsZW1lbnQsXG4gICAgICBwYWRkaW5nID0gMFxuICAgIH0gPSBldmFsdWF0ZShvcHRpb25zLCBzdGF0ZSkgfHwge307XG4gICAgaWYgKGVsZW1lbnQgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHt9O1xuICAgIH1cbiAgICBjb25zdCBwYWRkaW5nT2JqZWN0ID0gZ2V0UGFkZGluZ09iamVjdChwYWRkaW5nKTtcbiAgICBjb25zdCBjb29yZHMgPSB7XG4gICAgICB4LFxuICAgICAgeVxuICAgIH07XG4gICAgY29uc3QgYXhpcyA9IGdldEFsaWdubWVudEF4aXMocGxhY2VtZW50KTtcbiAgICBjb25zdCBsZW5ndGggPSBnZXRBeGlzTGVuZ3RoKGF4aXMpO1xuICAgIGNvbnN0IGFycm93RGltZW5zaW9ucyA9IGF3YWl0IHBsYXRmb3JtLmdldERpbWVuc2lvbnMoZWxlbWVudCk7XG4gICAgY29uc3QgaXNZQXhpcyA9IGF4aXMgPT09ICd5JztcbiAgICBjb25zdCBtaW5Qcm9wID0gaXNZQXhpcyA/ICd0b3AnIDogJ2xlZnQnO1xuICAgIGNvbnN0IG1heFByb3AgPSBpc1lBeGlzID8gJ2JvdHRvbScgOiAncmlnaHQnO1xuICAgIGNvbnN0IGNsaWVudFByb3AgPSBpc1lBeGlzID8gJ2NsaWVudEhlaWdodCcgOiAnY2xpZW50V2lkdGgnO1xuICAgIGNvbnN0IGVuZERpZmYgPSByZWN0cy5yZWZlcmVuY2VbbGVuZ3RoXSArIHJlY3RzLnJlZmVyZW5jZVtheGlzXSAtIGNvb3Jkc1theGlzXSAtIHJlY3RzLmZsb2F0aW5nW2xlbmd0aF07XG4gICAgY29uc3Qgc3RhcnREaWZmID0gY29vcmRzW2F4aXNdIC0gcmVjdHMucmVmZXJlbmNlW2F4aXNdO1xuICAgIGNvbnN0IGFycm93T2Zmc2V0UGFyZW50ID0gYXdhaXQgKHBsYXRmb3JtLmdldE9mZnNldFBhcmVudCA9PSBudWxsID8gdm9pZCAwIDogcGxhdGZvcm0uZ2V0T2Zmc2V0UGFyZW50KGVsZW1lbnQpKTtcbiAgICBsZXQgY2xpZW50U2l6ZSA9IGFycm93T2Zmc2V0UGFyZW50ID8gYXJyb3dPZmZzZXRQYXJlbnRbY2xpZW50UHJvcF0gOiAwO1xuXG4gICAgLy8gRE9NIHBsYXRmb3JtIGNhbiByZXR1cm4gYHdpbmRvd2AgYXMgdGhlIGBvZmZzZXRQYXJlbnRgLlxuICAgIGlmICghY2xpZW50U2l6ZSB8fCAhKGF3YWl0IChwbGF0Zm9ybS5pc0VsZW1lbnQgPT0gbnVsbCA/IHZvaWQgMCA6IHBsYXRmb3JtLmlzRWxlbWVudChhcnJvd09mZnNldFBhcmVudCkpKSkge1xuICAgICAgY2xpZW50U2l6ZSA9IGVsZW1lbnRzLmZsb2F0aW5nW2NsaWVudFByb3BdIHx8IHJlY3RzLmZsb2F0aW5nW2xlbmd0aF07XG4gICAgfVxuICAgIGNvbnN0IGNlbnRlclRvUmVmZXJlbmNlID0gZW5kRGlmZiAvIDIgLSBzdGFydERpZmYgLyAyO1xuXG4gICAgLy8gSWYgdGhlIHBhZGRpbmcgaXMgbGFyZ2UgZW5vdWdoIHRoYXQgaXQgY2F1c2VzIHRoZSBhcnJvdyB0byBubyBsb25nZXIgYmVcbiAgICAvLyBjZW50ZXJlZCwgbW9kaWZ5IHRoZSBwYWRkaW5nIHNvIHRoYXQgaXQgaXMgY2VudGVyZWQuXG4gICAgY29uc3QgbGFyZ2VzdFBvc3NpYmxlUGFkZGluZyA9IGNsaWVudFNpemUgLyAyIC0gYXJyb3dEaW1lbnNpb25zW2xlbmd0aF0gLyAyIC0gMTtcbiAgICBjb25zdCBtaW5QYWRkaW5nID0gbWluKHBhZGRpbmdPYmplY3RbbWluUHJvcF0sIGxhcmdlc3RQb3NzaWJsZVBhZGRpbmcpO1xuICAgIGNvbnN0IG1heFBhZGRpbmcgPSBtaW4ocGFkZGluZ09iamVjdFttYXhQcm9wXSwgbGFyZ2VzdFBvc3NpYmxlUGFkZGluZyk7XG5cbiAgICAvLyBNYWtlIHN1cmUgdGhlIGFycm93IGRvZXNuJ3Qgb3ZlcmZsb3cgdGhlIGZsb2F0aW5nIGVsZW1lbnQgaWYgdGhlIGNlbnRlclxuICAgIC8vIHBvaW50IGlzIG91dHNpZGUgdGhlIGZsb2F0aW5nIGVsZW1lbnQncyBib3VuZHMuXG4gICAgY29uc3QgbWluJDEgPSBtaW5QYWRkaW5nO1xuICAgIGNvbnN0IG1heCA9IGNsaWVudFNpemUgLSBhcnJvd0RpbWVuc2lvbnNbbGVuZ3RoXSAtIG1heFBhZGRpbmc7XG4gICAgY29uc3QgY2VudGVyID0gY2xpZW50U2l6ZSAvIDIgLSBhcnJvd0RpbWVuc2lvbnNbbGVuZ3RoXSAvIDIgKyBjZW50ZXJUb1JlZmVyZW5jZTtcbiAgICBjb25zdCBvZmZzZXQgPSBjbGFtcChtaW4kMSwgY2VudGVyLCBtYXgpO1xuXG4gICAgLy8gSWYgdGhlIHJlZmVyZW5jZSBpcyBzbWFsbCBlbm91Z2ggdGhhdCB0aGUgYXJyb3cncyBwYWRkaW5nIGNhdXNlcyBpdCB0b1xuICAgIC8vIHRvIHBvaW50IHRvIG5vdGhpbmcgZm9yIGFuIGFsaWduZWQgcGxhY2VtZW50LCBhZGp1c3QgdGhlIG9mZnNldCBvZiB0aGVcbiAgICAvLyBmbG9hdGluZyBlbGVtZW50IGl0c2VsZi4gVG8gZW5zdXJlIGBzaGlmdCgpYCBjb250aW51ZXMgdG8gdGFrZSBhY3Rpb24sXG4gICAgLy8gYSBzaW5nbGUgcmVzZXQgaXMgcGVyZm9ybWVkIHdoZW4gdGhpcyBpcyB0cnVlLlxuICAgIGNvbnN0IHNob3VsZEFkZE9mZnNldCA9ICFtaWRkbGV3YXJlRGF0YS5hcnJvdyAmJiBnZXRBbGlnbm1lbnQocGxhY2VtZW50KSAhPSBudWxsICYmIGNlbnRlciAhPT0gb2Zmc2V0ICYmIHJlY3RzLnJlZmVyZW5jZVtsZW5ndGhdIC8gMiAtIChjZW50ZXIgPCBtaW4kMSA/IG1pblBhZGRpbmcgOiBtYXhQYWRkaW5nKSAtIGFycm93RGltZW5zaW9uc1tsZW5ndGhdIC8gMiA8IDA7XG4gICAgY29uc3QgYWxpZ25tZW50T2Zmc2V0ID0gc2hvdWxkQWRkT2Zmc2V0ID8gY2VudGVyIDwgbWluJDEgPyBjZW50ZXIgLSBtaW4kMSA6IGNlbnRlciAtIG1heCA6IDA7XG4gICAgcmV0dXJuIHtcbiAgICAgIFtheGlzXTogY29vcmRzW2F4aXNdICsgYWxpZ25tZW50T2Zmc2V0LFxuICAgICAgZGF0YToge1xuICAgICAgICBbYXhpc106IG9mZnNldCxcbiAgICAgICAgY2VudGVyT2Zmc2V0OiBjZW50ZXIgLSBvZmZzZXQgLSBhbGlnbm1lbnRPZmZzZXQsXG4gICAgICAgIC4uLihzaG91bGRBZGRPZmZzZXQgJiYge1xuICAgICAgICAgIGFsaWdubWVudE9mZnNldFxuICAgICAgICB9KVxuICAgICAgfSxcbiAgICAgIHJlc2V0OiBzaG91bGRBZGRPZmZzZXRcbiAgICB9O1xuICB9XG59KTtcblxuZnVuY3Rpb24gZ2V0UGxhY2VtZW50TGlzdChhbGlnbm1lbnQsIGF1dG9BbGlnbm1lbnQsIGFsbG93ZWRQbGFjZW1lbnRzKSB7XG4gIGNvbnN0IGFsbG93ZWRQbGFjZW1lbnRzU29ydGVkQnlBbGlnbm1lbnQgPSBhbGlnbm1lbnQgPyBbLi4uYWxsb3dlZFBsYWNlbWVudHMuZmlsdGVyKHBsYWNlbWVudCA9PiBnZXRBbGlnbm1lbnQocGxhY2VtZW50KSA9PT0gYWxpZ25tZW50KSwgLi4uYWxsb3dlZFBsYWNlbWVudHMuZmlsdGVyKHBsYWNlbWVudCA9PiBnZXRBbGlnbm1lbnQocGxhY2VtZW50KSAhPT0gYWxpZ25tZW50KV0gOiBhbGxvd2VkUGxhY2VtZW50cy5maWx0ZXIocGxhY2VtZW50ID0+IGdldFNpZGUocGxhY2VtZW50KSA9PT0gcGxhY2VtZW50KTtcbiAgcmV0dXJuIGFsbG93ZWRQbGFjZW1lbnRzU29ydGVkQnlBbGlnbm1lbnQuZmlsdGVyKHBsYWNlbWVudCA9PiB7XG4gICAgaWYgKGFsaWdubWVudCkge1xuICAgICAgcmV0dXJuIGdldEFsaWdubWVudChwbGFjZW1lbnQpID09PSBhbGlnbm1lbnQgfHwgKGF1dG9BbGlnbm1lbnQgPyBnZXRPcHBvc2l0ZUFsaWdubWVudFBsYWNlbWVudChwbGFjZW1lbnQpICE9PSBwbGFjZW1lbnQgOiBmYWxzZSk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9KTtcbn1cbi8qKlxuICogT3B0aW1pemVzIHRoZSB2aXNpYmlsaXR5IG9mIHRoZSBmbG9hdGluZyBlbGVtZW50IGJ5IGNob29zaW5nIHRoZSBwbGFjZW1lbnRcbiAqIHRoYXQgaGFzIHRoZSBtb3N0IHNwYWNlIGF2YWlsYWJsZSBhdXRvbWF0aWNhbGx5LCB3aXRob3V0IG5lZWRpbmcgdG8gc3BlY2lmeSBhXG4gKiBwcmVmZXJyZWQgcGxhY2VtZW50LiBBbHRlcm5hdGl2ZSB0byBgZmxpcGAuXG4gKiBAc2VlIGh0dHBzOi8vZmxvYXRpbmctdWkuY29tL2RvY3MvYXV0b1BsYWNlbWVudFxuICovXG5jb25zdCBhdXRvUGxhY2VtZW50ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfVxuICByZXR1cm4ge1xuICAgIG5hbWU6ICdhdXRvUGxhY2VtZW50JyxcbiAgICBvcHRpb25zLFxuICAgIGFzeW5jIGZuKHN0YXRlKSB7XG4gICAgICB2YXIgX21pZGRsZXdhcmVEYXRhJGF1dG9QLCBfbWlkZGxld2FyZURhdGEkYXV0b1AyLCBfcGxhY2VtZW50c1RoYXRGaXRPbkU7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHJlY3RzLFxuICAgICAgICBtaWRkbGV3YXJlRGF0YSxcbiAgICAgICAgcGxhY2VtZW50LFxuICAgICAgICBwbGF0Zm9ybSxcbiAgICAgICAgZWxlbWVudHNcbiAgICAgIH0gPSBzdGF0ZTtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgY3Jvc3NBeGlzID0gZmFsc2UsXG4gICAgICAgIGFsaWdubWVudCxcbiAgICAgICAgYWxsb3dlZFBsYWNlbWVudHMgPSBwbGFjZW1lbnRzLFxuICAgICAgICBhdXRvQWxpZ25tZW50ID0gdHJ1ZSxcbiAgICAgICAgLi4uZGV0ZWN0T3ZlcmZsb3dPcHRpb25zXG4gICAgICB9ID0gZXZhbHVhdGUob3B0aW9ucywgc3RhdGUpO1xuICAgICAgY29uc3QgcGxhY2VtZW50cyQxID0gYWxpZ25tZW50ICE9PSB1bmRlZmluZWQgfHwgYWxsb3dlZFBsYWNlbWVudHMgPT09IHBsYWNlbWVudHMgPyBnZXRQbGFjZW1lbnRMaXN0KGFsaWdubWVudCB8fCBudWxsLCBhdXRvQWxpZ25tZW50LCBhbGxvd2VkUGxhY2VtZW50cykgOiBhbGxvd2VkUGxhY2VtZW50cztcbiAgICAgIGNvbnN0IG92ZXJmbG93ID0gYXdhaXQgZGV0ZWN0T3ZlcmZsb3coc3RhdGUsIGRldGVjdE92ZXJmbG93T3B0aW9ucyk7XG4gICAgICBjb25zdCBjdXJyZW50SW5kZXggPSAoKF9taWRkbGV3YXJlRGF0YSRhdXRvUCA9IG1pZGRsZXdhcmVEYXRhLmF1dG9QbGFjZW1lbnQpID09IG51bGwgPyB2b2lkIDAgOiBfbWlkZGxld2FyZURhdGEkYXV0b1AuaW5kZXgpIHx8IDA7XG4gICAgICBjb25zdCBjdXJyZW50UGxhY2VtZW50ID0gcGxhY2VtZW50cyQxW2N1cnJlbnRJbmRleF07XG4gICAgICBpZiAoY3VycmVudFBsYWNlbWVudCA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiB7fTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGFsaWdubWVudFNpZGVzID0gZ2V0QWxpZ25tZW50U2lkZXMoY3VycmVudFBsYWNlbWVudCwgcmVjdHMsIGF3YWl0IChwbGF0Zm9ybS5pc1JUTCA9PSBudWxsID8gdm9pZCAwIDogcGxhdGZvcm0uaXNSVEwoZWxlbWVudHMuZmxvYXRpbmcpKSk7XG5cbiAgICAgIC8vIE1ha2UgYGNvbXB1dGVDb29yZHNgIHN0YXJ0IGZyb20gdGhlIHJpZ2h0IHBsYWNlLlxuICAgICAgaWYgKHBsYWNlbWVudCAhPT0gY3VycmVudFBsYWNlbWVudCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHJlc2V0OiB7XG4gICAgICAgICAgICBwbGFjZW1lbnQ6IHBsYWNlbWVudHMkMVswXVxuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGN1cnJlbnRPdmVyZmxvd3MgPSBbb3ZlcmZsb3dbZ2V0U2lkZShjdXJyZW50UGxhY2VtZW50KV0sIG92ZXJmbG93W2FsaWdubWVudFNpZGVzWzBdXSwgb3ZlcmZsb3dbYWxpZ25tZW50U2lkZXNbMV1dXTtcbiAgICAgIGNvbnN0IGFsbE92ZXJmbG93cyA9IFsuLi4oKChfbWlkZGxld2FyZURhdGEkYXV0b1AyID0gbWlkZGxld2FyZURhdGEuYXV0b1BsYWNlbWVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9taWRkbGV3YXJlRGF0YSRhdXRvUDIub3ZlcmZsb3dzKSB8fCBbXSksIHtcbiAgICAgICAgcGxhY2VtZW50OiBjdXJyZW50UGxhY2VtZW50LFxuICAgICAgICBvdmVyZmxvd3M6IGN1cnJlbnRPdmVyZmxvd3NcbiAgICAgIH1dO1xuICAgICAgY29uc3QgbmV4dFBsYWNlbWVudCA9IHBsYWNlbWVudHMkMVtjdXJyZW50SW5kZXggKyAxXTtcblxuICAgICAgLy8gVGhlcmUgYXJlIG1vcmUgcGxhY2VtZW50cyB0byBjaGVjay5cbiAgICAgIGlmIChuZXh0UGxhY2VtZW50KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgaW5kZXg6IGN1cnJlbnRJbmRleCArIDEsXG4gICAgICAgICAgICBvdmVyZmxvd3M6IGFsbE92ZXJmbG93c1xuICAgICAgICAgIH0sXG4gICAgICAgICAgcmVzZXQ6IHtcbiAgICAgICAgICAgIHBsYWNlbWVudDogbmV4dFBsYWNlbWVudFxuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHBsYWNlbWVudHNTb3J0ZWRCeU1vc3RTcGFjZSA9IGFsbE92ZXJmbG93cy5tYXAoZCA9PiB7XG4gICAgICAgIGNvbnN0IGFsaWdubWVudCA9IGdldEFsaWdubWVudChkLnBsYWNlbWVudCk7XG4gICAgICAgIHJldHVybiBbZC5wbGFjZW1lbnQsIGFsaWdubWVudCAmJiBjcm9zc0F4aXMgP1xuICAgICAgICAvLyBDaGVjayBhbG9uZyB0aGUgbWFpbkF4aXMgYW5kIG1haW4gY3Jvc3NBeGlzIHNpZGUuXG4gICAgICAgIGQub3ZlcmZsb3dzLnNsaWNlKDAsIDIpLnJlZHVjZSgoYWNjLCB2KSA9PiBhY2MgKyB2LCAwKSA6XG4gICAgICAgIC8vIENoZWNrIG9ubHkgdGhlIG1haW5BeGlzLlxuICAgICAgICBkLm92ZXJmbG93c1swXSwgZC5vdmVyZmxvd3NdO1xuICAgICAgfSkuc29ydCgoYSwgYikgPT4gYVsxXSAtIGJbMV0pO1xuICAgICAgY29uc3QgcGxhY2VtZW50c1RoYXRGaXRPbkVhY2hTaWRlID0gcGxhY2VtZW50c1NvcnRlZEJ5TW9zdFNwYWNlLmZpbHRlcihkID0+IGRbMl0uc2xpY2UoMCxcbiAgICAgIC8vIEFsaWduZWQgcGxhY2VtZW50cyBzaG91bGQgbm90IGNoZWNrIHRoZWlyIG9wcG9zaXRlIGNyb3NzQXhpc1xuICAgICAgLy8gc2lkZS5cbiAgICAgIGdldEFsaWdubWVudChkWzBdKSA/IDIgOiAzKS5ldmVyeSh2ID0+IHYgPD0gMCkpO1xuICAgICAgY29uc3QgcmVzZXRQbGFjZW1lbnQgPSAoKF9wbGFjZW1lbnRzVGhhdEZpdE9uRSA9IHBsYWNlbWVudHNUaGF0Rml0T25FYWNoU2lkZVswXSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9wbGFjZW1lbnRzVGhhdEZpdE9uRVswXSkgfHwgcGxhY2VtZW50c1NvcnRlZEJ5TW9zdFNwYWNlWzBdWzBdO1xuICAgICAgaWYgKHJlc2V0UGxhY2VtZW50ICE9PSBwbGFjZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICBpbmRleDogY3VycmVudEluZGV4ICsgMSxcbiAgICAgICAgICAgIG92ZXJmbG93czogYWxsT3ZlcmZsb3dzXG4gICAgICAgICAgfSxcbiAgICAgICAgICByZXNldDoge1xuICAgICAgICAgICAgcGxhY2VtZW50OiByZXNldFBsYWNlbWVudFxuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7fTtcbiAgICB9XG4gIH07XG59O1xuXG4vKipcbiAqIE9wdGltaXplcyB0aGUgdmlzaWJpbGl0eSBvZiB0aGUgZmxvYXRpbmcgZWxlbWVudCBieSBmbGlwcGluZyB0aGUgYHBsYWNlbWVudGBcbiAqIGluIG9yZGVyIHRvIGtlZXAgaXQgaW4gdmlldyB3aGVuIHRoZSBwcmVmZXJyZWQgcGxhY2VtZW50KHMpIHdpbGwgb3ZlcmZsb3cgdGhlXG4gKiBjbGlwcGluZyBib3VuZGFyeS4gQWx0ZXJuYXRpdmUgdG8gYGF1dG9QbGFjZW1lbnRgLlxuICogQHNlZSBodHRwczovL2Zsb2F0aW5nLXVpLmNvbS9kb2NzL2ZsaXBcbiAqL1xuY29uc3QgZmxpcCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICBvcHRpb25zID0ge307XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBuYW1lOiAnZmxpcCcsXG4gICAgb3B0aW9ucyxcbiAgICBhc3luYyBmbihzdGF0ZSkge1xuICAgICAgdmFyIF9taWRkbGV3YXJlRGF0YSRhcnJvdywgX21pZGRsZXdhcmVEYXRhJGZsaXA7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHBsYWNlbWVudCxcbiAgICAgICAgbWlkZGxld2FyZURhdGEsXG4gICAgICAgIHJlY3RzLFxuICAgICAgICBpbml0aWFsUGxhY2VtZW50LFxuICAgICAgICBwbGF0Zm9ybSxcbiAgICAgICAgZWxlbWVudHNcbiAgICAgIH0gPSBzdGF0ZTtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgbWFpbkF4aXM6IGNoZWNrTWFpbkF4aXMgPSB0cnVlLFxuICAgICAgICBjcm9zc0F4aXM6IGNoZWNrQ3Jvc3NBeGlzID0gdHJ1ZSxcbiAgICAgICAgZmFsbGJhY2tQbGFjZW1lbnRzOiBzcGVjaWZpZWRGYWxsYmFja1BsYWNlbWVudHMsXG4gICAgICAgIGZhbGxiYWNrU3RyYXRlZ3kgPSAnYmVzdEZpdCcsXG4gICAgICAgIGZhbGxiYWNrQXhpc1NpZGVEaXJlY3Rpb24gPSAnbm9uZScsXG4gICAgICAgIGZsaXBBbGlnbm1lbnQgPSB0cnVlLFxuICAgICAgICAuLi5kZXRlY3RPdmVyZmxvd09wdGlvbnNcbiAgICAgIH0gPSBldmFsdWF0ZShvcHRpb25zLCBzdGF0ZSk7XG5cbiAgICAgIC8vIElmIGEgcmVzZXQgYnkgdGhlIGFycm93IHdhcyBjYXVzZWQgZHVlIHRvIGFuIGFsaWdubWVudCBvZmZzZXQgYmVpbmdcbiAgICAgIC8vIGFkZGVkLCB3ZSBzaG91bGQgc2tpcCBhbnkgbG9naWMgbm93IHNpbmNlIGBmbGlwKClgIGhhcyBhbHJlYWR5IGRvbmUgaXRzXG4gICAgICAvLyB3b3JrLlxuICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2Zsb2F0aW5nLXVpL2Zsb2F0aW5nLXVpL2lzc3Vlcy8yNTQ5I2lzc3VlY29tbWVudC0xNzE5NjAxNjQzXG4gICAgICBpZiAoKF9taWRkbGV3YXJlRGF0YSRhcnJvdyA9IG1pZGRsZXdhcmVEYXRhLmFycm93KSAhPSBudWxsICYmIF9taWRkbGV3YXJlRGF0YSRhcnJvdy5hbGlnbm1lbnRPZmZzZXQpIHtcbiAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgfVxuICAgICAgY29uc3Qgc2lkZSA9IGdldFNpZGUocGxhY2VtZW50KTtcbiAgICAgIGNvbnN0IGlzQmFzZVBsYWNlbWVudCA9IGdldFNpZGUoaW5pdGlhbFBsYWNlbWVudCkgPT09IGluaXRpYWxQbGFjZW1lbnQ7XG4gICAgICBjb25zdCBydGwgPSBhd2FpdCAocGxhdGZvcm0uaXNSVEwgPT0gbnVsbCA/IHZvaWQgMCA6IHBsYXRmb3JtLmlzUlRMKGVsZW1lbnRzLmZsb2F0aW5nKSk7XG4gICAgICBjb25zdCBmYWxsYmFja1BsYWNlbWVudHMgPSBzcGVjaWZpZWRGYWxsYmFja1BsYWNlbWVudHMgfHwgKGlzQmFzZVBsYWNlbWVudCB8fCAhZmxpcEFsaWdubWVudCA/IFtnZXRPcHBvc2l0ZVBsYWNlbWVudChpbml0aWFsUGxhY2VtZW50KV0gOiBnZXRFeHBhbmRlZFBsYWNlbWVudHMoaW5pdGlhbFBsYWNlbWVudCkpO1xuICAgICAgaWYgKCFzcGVjaWZpZWRGYWxsYmFja1BsYWNlbWVudHMgJiYgZmFsbGJhY2tBeGlzU2lkZURpcmVjdGlvbiAhPT0gJ25vbmUnKSB7XG4gICAgICAgIGZhbGxiYWNrUGxhY2VtZW50cy5wdXNoKC4uLmdldE9wcG9zaXRlQXhpc1BsYWNlbWVudHMoaW5pdGlhbFBsYWNlbWVudCwgZmxpcEFsaWdubWVudCwgZmFsbGJhY2tBeGlzU2lkZURpcmVjdGlvbiwgcnRsKSk7XG4gICAgICB9XG4gICAgICBjb25zdCBwbGFjZW1lbnRzID0gW2luaXRpYWxQbGFjZW1lbnQsIC4uLmZhbGxiYWNrUGxhY2VtZW50c107XG4gICAgICBjb25zdCBvdmVyZmxvdyA9IGF3YWl0IGRldGVjdE92ZXJmbG93KHN0YXRlLCBkZXRlY3RPdmVyZmxvd09wdGlvbnMpO1xuICAgICAgY29uc3Qgb3ZlcmZsb3dzID0gW107XG4gICAgICBsZXQgb3ZlcmZsb3dzRGF0YSA9ICgoX21pZGRsZXdhcmVEYXRhJGZsaXAgPSBtaWRkbGV3YXJlRGF0YS5mbGlwKSA9PSBudWxsID8gdm9pZCAwIDogX21pZGRsZXdhcmVEYXRhJGZsaXAub3ZlcmZsb3dzKSB8fCBbXTtcbiAgICAgIGlmIChjaGVja01haW5BeGlzKSB7XG4gICAgICAgIG92ZXJmbG93cy5wdXNoKG92ZXJmbG93W3NpZGVdKTtcbiAgICAgIH1cbiAgICAgIGlmIChjaGVja0Nyb3NzQXhpcykge1xuICAgICAgICBjb25zdCBzaWRlcyA9IGdldEFsaWdubWVudFNpZGVzKHBsYWNlbWVudCwgcmVjdHMsIHJ0bCk7XG4gICAgICAgIG92ZXJmbG93cy5wdXNoKG92ZXJmbG93W3NpZGVzWzBdXSwgb3ZlcmZsb3dbc2lkZXNbMV1dKTtcbiAgICAgIH1cbiAgICAgIG92ZXJmbG93c0RhdGEgPSBbLi4ub3ZlcmZsb3dzRGF0YSwge1xuICAgICAgICBwbGFjZW1lbnQsXG4gICAgICAgIG92ZXJmbG93c1xuICAgICAgfV07XG5cbiAgICAgIC8vIE9uZSBvciBtb3JlIHNpZGVzIGlzIG92ZXJmbG93aW5nLlxuICAgICAgaWYgKCFvdmVyZmxvd3MuZXZlcnkoc2lkZSA9PiBzaWRlIDw9IDApKSB7XG4gICAgICAgIHZhciBfbWlkZGxld2FyZURhdGEkZmxpcDIsIF9vdmVyZmxvd3NEYXRhJGZpbHRlcjtcbiAgICAgICAgY29uc3QgbmV4dEluZGV4ID0gKCgoX21pZGRsZXdhcmVEYXRhJGZsaXAyID0gbWlkZGxld2FyZURhdGEuZmxpcCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9taWRkbGV3YXJlRGF0YSRmbGlwMi5pbmRleCkgfHwgMCkgKyAxO1xuICAgICAgICBjb25zdCBuZXh0UGxhY2VtZW50ID0gcGxhY2VtZW50c1tuZXh0SW5kZXhdO1xuICAgICAgICBpZiAobmV4dFBsYWNlbWVudCkge1xuICAgICAgICAgIC8vIFRyeSBuZXh0IHBsYWNlbWVudCBhbmQgcmUtcnVuIHRoZSBsaWZlY3ljbGUuXG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgaW5kZXg6IG5leHRJbmRleCxcbiAgICAgICAgICAgICAgb3ZlcmZsb3dzOiBvdmVyZmxvd3NEYXRhXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcmVzZXQ6IHtcbiAgICAgICAgICAgICAgcGxhY2VtZW50OiBuZXh0UGxhY2VtZW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEZpcnN0LCBmaW5kIHRoZSBjYW5kaWRhdGVzIHRoYXQgZml0IG9uIHRoZSBtYWluQXhpcyBzaWRlIG9mIG92ZXJmbG93LFxuICAgICAgICAvLyB0aGVuIGZpbmQgdGhlIHBsYWNlbWVudCB0aGF0IGZpdHMgdGhlIGJlc3Qgb24gdGhlIG1haW4gY3Jvc3NBeGlzIHNpZGUuXG4gICAgICAgIGxldCByZXNldFBsYWNlbWVudCA9IChfb3ZlcmZsb3dzRGF0YSRmaWx0ZXIgPSBvdmVyZmxvd3NEYXRhLmZpbHRlcihkID0+IGQub3ZlcmZsb3dzWzBdIDw9IDApLnNvcnQoKGEsIGIpID0+IGEub3ZlcmZsb3dzWzFdIC0gYi5vdmVyZmxvd3NbMV0pWzBdKSA9PSBudWxsID8gdm9pZCAwIDogX292ZXJmbG93c0RhdGEkZmlsdGVyLnBsYWNlbWVudDtcblxuICAgICAgICAvLyBPdGhlcndpc2UgZmFsbGJhY2suXG4gICAgICAgIGlmICghcmVzZXRQbGFjZW1lbnQpIHtcbiAgICAgICAgICBzd2l0Y2ggKGZhbGxiYWNrU3RyYXRlZ3kpIHtcbiAgICAgICAgICAgIGNhc2UgJ2Jlc3RGaXQnOlxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdmFyIF9vdmVyZmxvd3NEYXRhJG1hcCRzbztcbiAgICAgICAgICAgICAgICBjb25zdCBwbGFjZW1lbnQgPSAoX292ZXJmbG93c0RhdGEkbWFwJHNvID0gb3ZlcmZsb3dzRGF0YS5tYXAoZCA9PiBbZC5wbGFjZW1lbnQsIGQub3ZlcmZsb3dzLmZpbHRlcihvdmVyZmxvdyA9PiBvdmVyZmxvdyA+IDApLnJlZHVjZSgoYWNjLCBvdmVyZmxvdykgPT4gYWNjICsgb3ZlcmZsb3csIDApXSkuc29ydCgoYSwgYikgPT4gYVsxXSAtIGJbMV0pWzBdKSA9PSBudWxsID8gdm9pZCAwIDogX292ZXJmbG93c0RhdGEkbWFwJHNvWzBdO1xuICAgICAgICAgICAgICAgIGlmIChwbGFjZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgIHJlc2V0UGxhY2VtZW50ID0gcGxhY2VtZW50O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAnaW5pdGlhbFBsYWNlbWVudCc6XG4gICAgICAgICAgICAgIHJlc2V0UGxhY2VtZW50ID0gaW5pdGlhbFBsYWNlbWVudDtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChwbGFjZW1lbnQgIT09IHJlc2V0UGxhY2VtZW50KSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHJlc2V0OiB7XG4gICAgICAgICAgICAgIHBsYWNlbWVudDogcmVzZXRQbGFjZW1lbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4ge307XG4gICAgfVxuICB9O1xufTtcblxuZnVuY3Rpb24gZ2V0U2lkZU9mZnNldHMob3ZlcmZsb3csIHJlY3QpIHtcbiAgcmV0dXJuIHtcbiAgICB0b3A6IG92ZXJmbG93LnRvcCAtIHJlY3QuaGVpZ2h0LFxuICAgIHJpZ2h0OiBvdmVyZmxvdy5yaWdodCAtIHJlY3Qud2lkdGgsXG4gICAgYm90dG9tOiBvdmVyZmxvdy5ib3R0b20gLSByZWN0LmhlaWdodCxcbiAgICBsZWZ0OiBvdmVyZmxvdy5sZWZ0IC0gcmVjdC53aWR0aFxuICB9O1xufVxuZnVuY3Rpb24gaXNBbnlTaWRlRnVsbHlDbGlwcGVkKG92ZXJmbG93KSB7XG4gIHJldHVybiBzaWRlcy5zb21lKHNpZGUgPT4gb3ZlcmZsb3dbc2lkZV0gPj0gMCk7XG59XG4vKipcbiAqIFByb3ZpZGVzIGRhdGEgdG8gaGlkZSB0aGUgZmxvYXRpbmcgZWxlbWVudCBpbiBhcHBsaWNhYmxlIHNpdHVhdGlvbnMsIHN1Y2ggYXNcbiAqIHdoZW4gaXQgaXMgbm90IGluIHRoZSBzYW1lIGNsaXBwaW5nIGNvbnRleHQgYXMgdGhlIHJlZmVyZW5jZSBlbGVtZW50LlxuICogQHNlZSBodHRwczovL2Zsb2F0aW5nLXVpLmNvbS9kb2NzL2hpZGVcbiAqL1xuY29uc3QgaGlkZSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICBvcHRpb25zID0ge307XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBuYW1lOiAnaGlkZScsXG4gICAgb3B0aW9ucyxcbiAgICBhc3luYyBmbihzdGF0ZSkge1xuICAgICAgY29uc3Qge1xuICAgICAgICByZWN0c1xuICAgICAgfSA9IHN0YXRlO1xuICAgICAgY29uc3Qge1xuICAgICAgICBzdHJhdGVneSA9ICdyZWZlcmVuY2VIaWRkZW4nLFxuICAgICAgICAuLi5kZXRlY3RPdmVyZmxvd09wdGlvbnNcbiAgICAgIH0gPSBldmFsdWF0ZShvcHRpb25zLCBzdGF0ZSk7XG4gICAgICBzd2l0Y2ggKHN0cmF0ZWd5KSB7XG4gICAgICAgIGNhc2UgJ3JlZmVyZW5jZUhpZGRlbic6XG4gICAgICAgICAge1xuICAgICAgICAgICAgY29uc3Qgb3ZlcmZsb3cgPSBhd2FpdCBkZXRlY3RPdmVyZmxvdyhzdGF0ZSwge1xuICAgICAgICAgICAgICAuLi5kZXRlY3RPdmVyZmxvd09wdGlvbnMsXG4gICAgICAgICAgICAgIGVsZW1lbnRDb250ZXh0OiAncmVmZXJlbmNlJ1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCBvZmZzZXRzID0gZ2V0U2lkZU9mZnNldHMob3ZlcmZsb3csIHJlY3RzLnJlZmVyZW5jZSk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgcmVmZXJlbmNlSGlkZGVuT2Zmc2V0czogb2Zmc2V0cyxcbiAgICAgICAgICAgICAgICByZWZlcmVuY2VIaWRkZW46IGlzQW55U2lkZUZ1bGx5Q2xpcHBlZChvZmZzZXRzKVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgY2FzZSAnZXNjYXBlZCc6XG4gICAgICAgICAge1xuICAgICAgICAgICAgY29uc3Qgb3ZlcmZsb3cgPSBhd2FpdCBkZXRlY3RPdmVyZmxvdyhzdGF0ZSwge1xuICAgICAgICAgICAgICAuLi5kZXRlY3RPdmVyZmxvd09wdGlvbnMsXG4gICAgICAgICAgICAgIGFsdEJvdW5kYXJ5OiB0cnVlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IG9mZnNldHMgPSBnZXRTaWRlT2Zmc2V0cyhvdmVyZmxvdywgcmVjdHMuZmxvYXRpbmcpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgIGVzY2FwZWRPZmZzZXRzOiBvZmZzZXRzLFxuICAgICAgICAgICAgICAgIGVzY2FwZWQ6IGlzQW55U2lkZUZ1bGx5Q2xpcHBlZChvZmZzZXRzKVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4ge307XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcbn07XG5cbmZ1bmN0aW9uIGdldEJvdW5kaW5nUmVjdChyZWN0cykge1xuICBjb25zdCBtaW5YID0gbWluKC4uLnJlY3RzLm1hcChyZWN0ID0+IHJlY3QubGVmdCkpO1xuICBjb25zdCBtaW5ZID0gbWluKC4uLnJlY3RzLm1hcChyZWN0ID0+IHJlY3QudG9wKSk7XG4gIGNvbnN0IG1heFggPSBtYXgoLi4ucmVjdHMubWFwKHJlY3QgPT4gcmVjdC5yaWdodCkpO1xuICBjb25zdCBtYXhZID0gbWF4KC4uLnJlY3RzLm1hcChyZWN0ID0+IHJlY3QuYm90dG9tKSk7XG4gIHJldHVybiB7XG4gICAgeDogbWluWCxcbiAgICB5OiBtaW5ZLFxuICAgIHdpZHRoOiBtYXhYIC0gbWluWCxcbiAgICBoZWlnaHQ6IG1heFkgLSBtaW5ZXG4gIH07XG59XG5mdW5jdGlvbiBnZXRSZWN0c0J5TGluZShyZWN0cykge1xuICBjb25zdCBzb3J0ZWRSZWN0cyA9IHJlY3RzLnNsaWNlKCkuc29ydCgoYSwgYikgPT4gYS55IC0gYi55KTtcbiAgY29uc3QgZ3JvdXBzID0gW107XG4gIGxldCBwcmV2UmVjdCA9IG51bGw7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc29ydGVkUmVjdHMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCByZWN0ID0gc29ydGVkUmVjdHNbaV07XG4gICAgaWYgKCFwcmV2UmVjdCB8fCByZWN0LnkgLSBwcmV2UmVjdC55ID4gcHJldlJlY3QuaGVpZ2h0IC8gMikge1xuICAgICAgZ3JvdXBzLnB1c2goW3JlY3RdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZ3JvdXBzW2dyb3Vwcy5sZW5ndGggLSAxXS5wdXNoKHJlY3QpO1xuICAgIH1cbiAgICBwcmV2UmVjdCA9IHJlY3Q7XG4gIH1cbiAgcmV0dXJuIGdyb3Vwcy5tYXAocmVjdCA9PiByZWN0VG9DbGllbnRSZWN0KGdldEJvdW5kaW5nUmVjdChyZWN0KSkpO1xufVxuLyoqXG4gKiBQcm92aWRlcyBpbXByb3ZlZCBwb3NpdGlvbmluZyBmb3IgaW5saW5lIHJlZmVyZW5jZSBlbGVtZW50cyB0aGF0IGNhbiBzcGFuXG4gKiBvdmVyIG11bHRpcGxlIGxpbmVzLCBzdWNoIGFzIGh5cGVybGlua3Mgb3IgcmFuZ2Ugc2VsZWN0aW9ucy5cbiAqIEBzZWUgaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy9pbmxpbmVcbiAqL1xuY29uc3QgaW5saW5lID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfVxuICByZXR1cm4ge1xuICAgIG5hbWU6ICdpbmxpbmUnLFxuICAgIG9wdGlvbnMsXG4gICAgYXN5bmMgZm4oc3RhdGUpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgcGxhY2VtZW50LFxuICAgICAgICBlbGVtZW50cyxcbiAgICAgICAgcmVjdHMsXG4gICAgICAgIHBsYXRmb3JtLFxuICAgICAgICBzdHJhdGVneVxuICAgICAgfSA9IHN0YXRlO1xuICAgICAgLy8gQSBNb3VzZUV2ZW50J3MgY2xpZW50e1gsWX0gY29vcmRzIGNhbiBiZSB1cCB0byAyIHBpeGVscyBvZmYgYVxuICAgICAgLy8gQ2xpZW50UmVjdCdzIGJvdW5kcywgZGVzcGl0ZSB0aGUgZXZlbnQgbGlzdGVuZXIgYmVpbmcgdHJpZ2dlcmVkLiBBXG4gICAgICAvLyBwYWRkaW5nIG9mIDIgc2VlbXMgdG8gaGFuZGxlIHRoaXMgaXNzdWUuXG4gICAgICBjb25zdCB7XG4gICAgICAgIHBhZGRpbmcgPSAyLFxuICAgICAgICB4LFxuICAgICAgICB5XG4gICAgICB9ID0gZXZhbHVhdGUob3B0aW9ucywgc3RhdGUpO1xuICAgICAgY29uc3QgbmF0aXZlQ2xpZW50UmVjdHMgPSBBcnJheS5mcm9tKChhd2FpdCAocGxhdGZvcm0uZ2V0Q2xpZW50UmVjdHMgPT0gbnVsbCA/IHZvaWQgMCA6IHBsYXRmb3JtLmdldENsaWVudFJlY3RzKGVsZW1lbnRzLnJlZmVyZW5jZSkpKSB8fCBbXSk7XG4gICAgICBjb25zdCBjbGllbnRSZWN0cyA9IGdldFJlY3RzQnlMaW5lKG5hdGl2ZUNsaWVudFJlY3RzKTtcbiAgICAgIGNvbnN0IGZhbGxiYWNrID0gcmVjdFRvQ2xpZW50UmVjdChnZXRCb3VuZGluZ1JlY3QobmF0aXZlQ2xpZW50UmVjdHMpKTtcbiAgICAgIGNvbnN0IHBhZGRpbmdPYmplY3QgPSBnZXRQYWRkaW5nT2JqZWN0KHBhZGRpbmcpO1xuICAgICAgZnVuY3Rpb24gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkge1xuICAgICAgICAvLyBUaGVyZSBhcmUgdHdvIHJlY3RzIGFuZCB0aGV5IGFyZSBkaXNqb2luZWQuXG4gICAgICAgIGlmIChjbGllbnRSZWN0cy5sZW5ndGggPT09IDIgJiYgY2xpZW50UmVjdHNbMF0ubGVmdCA+IGNsaWVudFJlY3RzWzFdLnJpZ2h0ICYmIHggIT0gbnVsbCAmJiB5ICE9IG51bGwpIHtcbiAgICAgICAgICAvLyBGaW5kIHRoZSBmaXJzdCByZWN0IGluIHdoaWNoIHRoZSBwb2ludCBpcyBmdWxseSBpbnNpZGUuXG4gICAgICAgICAgcmV0dXJuIGNsaWVudFJlY3RzLmZpbmQocmVjdCA9PiB4ID4gcmVjdC5sZWZ0IC0gcGFkZGluZ09iamVjdC5sZWZ0ICYmIHggPCByZWN0LnJpZ2h0ICsgcGFkZGluZ09iamVjdC5yaWdodCAmJiB5ID4gcmVjdC50b3AgLSBwYWRkaW5nT2JqZWN0LnRvcCAmJiB5IDwgcmVjdC5ib3R0b20gKyBwYWRkaW5nT2JqZWN0LmJvdHRvbSkgfHwgZmFsbGJhY2s7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUaGVyZSBhcmUgMiBvciBtb3JlIGNvbm5lY3RlZCByZWN0cy5cbiAgICAgICAgaWYgKGNsaWVudFJlY3RzLmxlbmd0aCA+PSAyKSB7XG4gICAgICAgICAgaWYgKGdldFNpZGVBeGlzKHBsYWNlbWVudCkgPT09ICd5Jykge1xuICAgICAgICAgICAgY29uc3QgZmlyc3RSZWN0ID0gY2xpZW50UmVjdHNbMF07XG4gICAgICAgICAgICBjb25zdCBsYXN0UmVjdCA9IGNsaWVudFJlY3RzW2NsaWVudFJlY3RzLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgY29uc3QgaXNUb3AgPSBnZXRTaWRlKHBsYWNlbWVudCkgPT09ICd0b3AnO1xuICAgICAgICAgICAgY29uc3QgdG9wID0gZmlyc3RSZWN0LnRvcDtcbiAgICAgICAgICAgIGNvbnN0IGJvdHRvbSA9IGxhc3RSZWN0LmJvdHRvbTtcbiAgICAgICAgICAgIGNvbnN0IGxlZnQgPSBpc1RvcCA/IGZpcnN0UmVjdC5sZWZ0IDogbGFzdFJlY3QubGVmdDtcbiAgICAgICAgICAgIGNvbnN0IHJpZ2h0ID0gaXNUb3AgPyBmaXJzdFJlY3QucmlnaHQgOiBsYXN0UmVjdC5yaWdodDtcbiAgICAgICAgICAgIGNvbnN0IHdpZHRoID0gcmlnaHQgLSBsZWZ0O1xuICAgICAgICAgICAgY29uc3QgaGVpZ2h0ID0gYm90dG9tIC0gdG9wO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgdG9wLFxuICAgICAgICAgICAgICBib3R0b20sXG4gICAgICAgICAgICAgIGxlZnQsXG4gICAgICAgICAgICAgIHJpZ2h0LFxuICAgICAgICAgICAgICB3aWR0aCxcbiAgICAgICAgICAgICAgaGVpZ2h0LFxuICAgICAgICAgICAgICB4OiBsZWZ0LFxuICAgICAgICAgICAgICB5OiB0b3BcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IGlzTGVmdFNpZGUgPSBnZXRTaWRlKHBsYWNlbWVudCkgPT09ICdsZWZ0JztcbiAgICAgICAgICBjb25zdCBtYXhSaWdodCA9IG1heCguLi5jbGllbnRSZWN0cy5tYXAocmVjdCA9PiByZWN0LnJpZ2h0KSk7XG4gICAgICAgICAgY29uc3QgbWluTGVmdCA9IG1pbiguLi5jbGllbnRSZWN0cy5tYXAocmVjdCA9PiByZWN0LmxlZnQpKTtcbiAgICAgICAgICBjb25zdCBtZWFzdXJlUmVjdHMgPSBjbGllbnRSZWN0cy5maWx0ZXIocmVjdCA9PiBpc0xlZnRTaWRlID8gcmVjdC5sZWZ0ID09PSBtaW5MZWZ0IDogcmVjdC5yaWdodCA9PT0gbWF4UmlnaHQpO1xuICAgICAgICAgIGNvbnN0IHRvcCA9IG1lYXN1cmVSZWN0c1swXS50b3A7XG4gICAgICAgICAgY29uc3QgYm90dG9tID0gbWVhc3VyZVJlY3RzW21lYXN1cmVSZWN0cy5sZW5ndGggLSAxXS5ib3R0b207XG4gICAgICAgICAgY29uc3QgbGVmdCA9IG1pbkxlZnQ7XG4gICAgICAgICAgY29uc3QgcmlnaHQgPSBtYXhSaWdodDtcbiAgICAgICAgICBjb25zdCB3aWR0aCA9IHJpZ2h0IC0gbGVmdDtcbiAgICAgICAgICBjb25zdCBoZWlnaHQgPSBib3R0b20gLSB0b3A7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHRvcCxcbiAgICAgICAgICAgIGJvdHRvbSxcbiAgICAgICAgICAgIGxlZnQsXG4gICAgICAgICAgICByaWdodCxcbiAgICAgICAgICAgIHdpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0LFxuICAgICAgICAgICAgeDogbGVmdCxcbiAgICAgICAgICAgIHk6IHRvcFxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbGxiYWNrO1xuICAgICAgfVxuICAgICAgY29uc3QgcmVzZXRSZWN0cyA9IGF3YWl0IHBsYXRmb3JtLmdldEVsZW1lbnRSZWN0cyh7XG4gICAgICAgIHJlZmVyZW5jZToge1xuICAgICAgICAgIGdldEJvdW5kaW5nQ2xpZW50UmVjdFxuICAgICAgICB9LFxuICAgICAgICBmbG9hdGluZzogZWxlbWVudHMuZmxvYXRpbmcsXG4gICAgICAgIHN0cmF0ZWd5XG4gICAgICB9KTtcbiAgICAgIGlmIChyZWN0cy5yZWZlcmVuY2UueCAhPT0gcmVzZXRSZWN0cy5yZWZlcmVuY2UueCB8fCByZWN0cy5yZWZlcmVuY2UueSAhPT0gcmVzZXRSZWN0cy5yZWZlcmVuY2UueSB8fCByZWN0cy5yZWZlcmVuY2Uud2lkdGggIT09IHJlc2V0UmVjdHMucmVmZXJlbmNlLndpZHRoIHx8IHJlY3RzLnJlZmVyZW5jZS5oZWlnaHQgIT09IHJlc2V0UmVjdHMucmVmZXJlbmNlLmhlaWdodCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHJlc2V0OiB7XG4gICAgICAgICAgICByZWN0czogcmVzZXRSZWN0c1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7fTtcbiAgICB9XG4gIH07XG59O1xuXG4vLyBGb3IgdHlwZSBiYWNrd2FyZHMtY29tcGF0aWJpbGl0eSwgdGhlIGBPZmZzZXRPcHRpb25zYCB0eXBlIHdhcyBhbHNvXG4vLyBEZXJpdmFibGUuXG5cbmFzeW5jIGZ1bmN0aW9uIGNvbnZlcnRWYWx1ZVRvQ29vcmRzKHN0YXRlLCBvcHRpb25zKSB7XG4gIGNvbnN0IHtcbiAgICBwbGFjZW1lbnQsXG4gICAgcGxhdGZvcm0sXG4gICAgZWxlbWVudHNcbiAgfSA9IHN0YXRlO1xuICBjb25zdCBydGwgPSBhd2FpdCAocGxhdGZvcm0uaXNSVEwgPT0gbnVsbCA/IHZvaWQgMCA6IHBsYXRmb3JtLmlzUlRMKGVsZW1lbnRzLmZsb2F0aW5nKSk7XG4gIGNvbnN0IHNpZGUgPSBnZXRTaWRlKHBsYWNlbWVudCk7XG4gIGNvbnN0IGFsaWdubWVudCA9IGdldEFsaWdubWVudChwbGFjZW1lbnQpO1xuICBjb25zdCBpc1ZlcnRpY2FsID0gZ2V0U2lkZUF4aXMocGxhY2VtZW50KSA9PT0gJ3knO1xuICBjb25zdCBtYWluQXhpc011bHRpID0gWydsZWZ0JywgJ3RvcCddLmluY2x1ZGVzKHNpZGUpID8gLTEgOiAxO1xuICBjb25zdCBjcm9zc0F4aXNNdWx0aSA9IHJ0bCAmJiBpc1ZlcnRpY2FsID8gLTEgOiAxO1xuICBjb25zdCByYXdWYWx1ZSA9IGV2YWx1YXRlKG9wdGlvbnMsIHN0YXRlKTtcbiAgbGV0IHtcbiAgICBtYWluQXhpcyxcbiAgICBjcm9zc0F4aXMsXG4gICAgYWxpZ25tZW50QXhpc1xuICB9ID0gdHlwZW9mIHJhd1ZhbHVlID09PSAnbnVtYmVyJyA/IHtcbiAgICBtYWluQXhpczogcmF3VmFsdWUsXG4gICAgY3Jvc3NBeGlzOiAwLFxuICAgIGFsaWdubWVudEF4aXM6IG51bGxcbiAgfSA6IHtcbiAgICBtYWluQXhpczogMCxcbiAgICBjcm9zc0F4aXM6IDAsXG4gICAgYWxpZ25tZW50QXhpczogbnVsbCxcbiAgICAuLi5yYXdWYWx1ZVxuICB9O1xuICBpZiAoYWxpZ25tZW50ICYmIHR5cGVvZiBhbGlnbm1lbnRBeGlzID09PSAnbnVtYmVyJykge1xuICAgIGNyb3NzQXhpcyA9IGFsaWdubWVudCA9PT0gJ2VuZCcgPyBhbGlnbm1lbnRBeGlzICogLTEgOiBhbGlnbm1lbnRBeGlzO1xuICB9XG4gIHJldHVybiBpc1ZlcnRpY2FsID8ge1xuICAgIHg6IGNyb3NzQXhpcyAqIGNyb3NzQXhpc011bHRpLFxuICAgIHk6IG1haW5BeGlzICogbWFpbkF4aXNNdWx0aVxuICB9IDoge1xuICAgIHg6IG1haW5BeGlzICogbWFpbkF4aXNNdWx0aSxcbiAgICB5OiBjcm9zc0F4aXMgKiBjcm9zc0F4aXNNdWx0aVxuICB9O1xufVxuXG4vKipcbiAqIE1vZGlmaWVzIHRoZSBwbGFjZW1lbnQgYnkgdHJhbnNsYXRpbmcgdGhlIGZsb2F0aW5nIGVsZW1lbnQgYWxvbmcgdGhlXG4gKiBzcGVjaWZpZWQgYXhlcy5cbiAqIEEgbnVtYmVyIChzaG9ydGhhbmQgZm9yIGBtYWluQXhpc2Agb3IgZGlzdGFuY2UpLCBvciBhbiBheGVzIGNvbmZpZ3VyYXRpb25cbiAqIG9iamVjdCBtYXkgYmUgcGFzc2VkLlxuICogQHNlZSBodHRwczovL2Zsb2F0aW5nLXVpLmNvbS9kb2NzL29mZnNldFxuICovXG5jb25zdCBvZmZzZXQgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgb3B0aW9ucyA9IDA7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBuYW1lOiAnb2Zmc2V0JyxcbiAgICBvcHRpb25zLFxuICAgIGFzeW5jIGZuKHN0YXRlKSB7XG4gICAgICB2YXIgX21pZGRsZXdhcmVEYXRhJG9mZnNlLCBfbWlkZGxld2FyZURhdGEkYXJyb3c7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHgsXG4gICAgICAgIHksXG4gICAgICAgIHBsYWNlbWVudCxcbiAgICAgICAgbWlkZGxld2FyZURhdGFcbiAgICAgIH0gPSBzdGF0ZTtcbiAgICAgIGNvbnN0IGRpZmZDb29yZHMgPSBhd2FpdCBjb252ZXJ0VmFsdWVUb0Nvb3JkcyhzdGF0ZSwgb3B0aW9ucyk7XG5cbiAgICAgIC8vIElmIHRoZSBwbGFjZW1lbnQgaXMgdGhlIHNhbWUgYW5kIHRoZSBhcnJvdyBjYXVzZWQgYW4gYWxpZ25tZW50IG9mZnNldFxuICAgICAgLy8gdGhlbiB3ZSBkb24ndCBuZWVkIHRvIGNoYW5nZSB0aGUgcG9zaXRpb25pbmcgY29vcmRpbmF0ZXMuXG4gICAgICBpZiAocGxhY2VtZW50ID09PSAoKF9taWRkbGV3YXJlRGF0YSRvZmZzZSA9IG1pZGRsZXdhcmVEYXRhLm9mZnNldCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9taWRkbGV3YXJlRGF0YSRvZmZzZS5wbGFjZW1lbnQpICYmIChfbWlkZGxld2FyZURhdGEkYXJyb3cgPSBtaWRkbGV3YXJlRGF0YS5hcnJvdykgIT0gbnVsbCAmJiBfbWlkZGxld2FyZURhdGEkYXJyb3cuYWxpZ25tZW50T2Zmc2V0KSB7XG4gICAgICAgIHJldHVybiB7fTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHg6IHggKyBkaWZmQ29vcmRzLngsXG4gICAgICAgIHk6IHkgKyBkaWZmQ29vcmRzLnksXG4gICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAuLi5kaWZmQ29vcmRzLFxuICAgICAgICAgIHBsYWNlbWVudFxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cbiAgfTtcbn07XG5cbi8qKlxuICogT3B0aW1pemVzIHRoZSB2aXNpYmlsaXR5IG9mIHRoZSBmbG9hdGluZyBlbGVtZW50IGJ5IHNoaWZ0aW5nIGl0IGluIG9yZGVyIHRvXG4gKiBrZWVwIGl0IGluIHZpZXcgd2hlbiBpdCB3aWxsIG92ZXJmbG93IHRoZSBjbGlwcGluZyBib3VuZGFyeS5cbiAqIEBzZWUgaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy9zaGlmdFxuICovXG5jb25zdCBzaGlmdCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICBvcHRpb25zID0ge307XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBuYW1lOiAnc2hpZnQnLFxuICAgIG9wdGlvbnMsXG4gICAgYXN5bmMgZm4oc3RhdGUpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgeCxcbiAgICAgICAgeSxcbiAgICAgICAgcGxhY2VtZW50XG4gICAgICB9ID0gc3RhdGU7XG4gICAgICBjb25zdCB7XG4gICAgICAgIG1haW5BeGlzOiBjaGVja01haW5BeGlzID0gdHJ1ZSxcbiAgICAgICAgY3Jvc3NBeGlzOiBjaGVja0Nyb3NzQXhpcyA9IGZhbHNlLFxuICAgICAgICBsaW1pdGVyID0ge1xuICAgICAgICAgIGZuOiBfcmVmID0+IHtcbiAgICAgICAgICAgIGxldCB7XG4gICAgICAgICAgICAgIHgsXG4gICAgICAgICAgICAgIHlcbiAgICAgICAgICAgIH0gPSBfcmVmO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgeCxcbiAgICAgICAgICAgICAgeVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIC4uLmRldGVjdE92ZXJmbG93T3B0aW9uc1xuICAgICAgfSA9IGV2YWx1YXRlKG9wdGlvbnMsIHN0YXRlKTtcbiAgICAgIGNvbnN0IGNvb3JkcyA9IHtcbiAgICAgICAgeCxcbiAgICAgICAgeVxuICAgICAgfTtcbiAgICAgIGNvbnN0IG92ZXJmbG93ID0gYXdhaXQgZGV0ZWN0T3ZlcmZsb3coc3RhdGUsIGRldGVjdE92ZXJmbG93T3B0aW9ucyk7XG4gICAgICBjb25zdCBjcm9zc0F4aXMgPSBnZXRTaWRlQXhpcyhnZXRTaWRlKHBsYWNlbWVudCkpO1xuICAgICAgY29uc3QgbWFpbkF4aXMgPSBnZXRPcHBvc2l0ZUF4aXMoY3Jvc3NBeGlzKTtcbiAgICAgIGxldCBtYWluQXhpc0Nvb3JkID0gY29vcmRzW21haW5BeGlzXTtcbiAgICAgIGxldCBjcm9zc0F4aXNDb29yZCA9IGNvb3Jkc1tjcm9zc0F4aXNdO1xuICAgICAgaWYgKGNoZWNrTWFpbkF4aXMpIHtcbiAgICAgICAgY29uc3QgbWluU2lkZSA9IG1haW5BeGlzID09PSAneScgPyAndG9wJyA6ICdsZWZ0JztcbiAgICAgICAgY29uc3QgbWF4U2lkZSA9IG1haW5BeGlzID09PSAneScgPyAnYm90dG9tJyA6ICdyaWdodCc7XG4gICAgICAgIGNvbnN0IG1pbiA9IG1haW5BeGlzQ29vcmQgKyBvdmVyZmxvd1ttaW5TaWRlXTtcbiAgICAgICAgY29uc3QgbWF4ID0gbWFpbkF4aXNDb29yZCAtIG92ZXJmbG93W21heFNpZGVdO1xuICAgICAgICBtYWluQXhpc0Nvb3JkID0gY2xhbXAobWluLCBtYWluQXhpc0Nvb3JkLCBtYXgpO1xuICAgICAgfVxuICAgICAgaWYgKGNoZWNrQ3Jvc3NBeGlzKSB7XG4gICAgICAgIGNvbnN0IG1pblNpZGUgPSBjcm9zc0F4aXMgPT09ICd5JyA/ICd0b3AnIDogJ2xlZnQnO1xuICAgICAgICBjb25zdCBtYXhTaWRlID0gY3Jvc3NBeGlzID09PSAneScgPyAnYm90dG9tJyA6ICdyaWdodCc7XG4gICAgICAgIGNvbnN0IG1pbiA9IGNyb3NzQXhpc0Nvb3JkICsgb3ZlcmZsb3dbbWluU2lkZV07XG4gICAgICAgIGNvbnN0IG1heCA9IGNyb3NzQXhpc0Nvb3JkIC0gb3ZlcmZsb3dbbWF4U2lkZV07XG4gICAgICAgIGNyb3NzQXhpc0Nvb3JkID0gY2xhbXAobWluLCBjcm9zc0F4aXNDb29yZCwgbWF4KTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGxpbWl0ZWRDb29yZHMgPSBsaW1pdGVyLmZuKHtcbiAgICAgICAgLi4uc3RhdGUsXG4gICAgICAgIFttYWluQXhpc106IG1haW5BeGlzQ29vcmQsXG4gICAgICAgIFtjcm9zc0F4aXNdOiBjcm9zc0F4aXNDb29yZFxuICAgICAgfSk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi5saW1pdGVkQ29vcmRzLFxuICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgeDogbGltaXRlZENvb3Jkcy54IC0geCxcbiAgICAgICAgICB5OiBsaW1pdGVkQ29vcmRzLnkgLSB5XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICB9O1xufTtcbi8qKlxuICogQnVpbHQtaW4gYGxpbWl0ZXJgIHRoYXQgd2lsbCBzdG9wIGBzaGlmdCgpYCBhdCBhIGNlcnRhaW4gcG9pbnQuXG4gKi9cbmNvbnN0IGxpbWl0U2hpZnQgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG4gIHJldHVybiB7XG4gICAgb3B0aW9ucyxcbiAgICBmbihzdGF0ZSkge1xuICAgICAgY29uc3Qge1xuICAgICAgICB4LFxuICAgICAgICB5LFxuICAgICAgICBwbGFjZW1lbnQsXG4gICAgICAgIHJlY3RzLFxuICAgICAgICBtaWRkbGV3YXJlRGF0YVxuICAgICAgfSA9IHN0YXRlO1xuICAgICAgY29uc3Qge1xuICAgICAgICBvZmZzZXQgPSAwLFxuICAgICAgICBtYWluQXhpczogY2hlY2tNYWluQXhpcyA9IHRydWUsXG4gICAgICAgIGNyb3NzQXhpczogY2hlY2tDcm9zc0F4aXMgPSB0cnVlXG4gICAgICB9ID0gZXZhbHVhdGUob3B0aW9ucywgc3RhdGUpO1xuICAgICAgY29uc3QgY29vcmRzID0ge1xuICAgICAgICB4LFxuICAgICAgICB5XG4gICAgICB9O1xuICAgICAgY29uc3QgY3Jvc3NBeGlzID0gZ2V0U2lkZUF4aXMocGxhY2VtZW50KTtcbiAgICAgIGNvbnN0IG1haW5BeGlzID0gZ2V0T3Bwb3NpdGVBeGlzKGNyb3NzQXhpcyk7XG4gICAgICBsZXQgbWFpbkF4aXNDb29yZCA9IGNvb3Jkc1ttYWluQXhpc107XG4gICAgICBsZXQgY3Jvc3NBeGlzQ29vcmQgPSBjb29yZHNbY3Jvc3NBeGlzXTtcbiAgICAgIGNvbnN0IHJhd09mZnNldCA9IGV2YWx1YXRlKG9mZnNldCwgc3RhdGUpO1xuICAgICAgY29uc3QgY29tcHV0ZWRPZmZzZXQgPSB0eXBlb2YgcmF3T2Zmc2V0ID09PSAnbnVtYmVyJyA/IHtcbiAgICAgICAgbWFpbkF4aXM6IHJhd09mZnNldCxcbiAgICAgICAgY3Jvc3NBeGlzOiAwXG4gICAgICB9IDoge1xuICAgICAgICBtYWluQXhpczogMCxcbiAgICAgICAgY3Jvc3NBeGlzOiAwLFxuICAgICAgICAuLi5yYXdPZmZzZXRcbiAgICAgIH07XG4gICAgICBpZiAoY2hlY2tNYWluQXhpcykge1xuICAgICAgICBjb25zdCBsZW4gPSBtYWluQXhpcyA9PT0gJ3knID8gJ2hlaWdodCcgOiAnd2lkdGgnO1xuICAgICAgICBjb25zdCBsaW1pdE1pbiA9IHJlY3RzLnJlZmVyZW5jZVttYWluQXhpc10gLSByZWN0cy5mbG9hdGluZ1tsZW5dICsgY29tcHV0ZWRPZmZzZXQubWFpbkF4aXM7XG4gICAgICAgIGNvbnN0IGxpbWl0TWF4ID0gcmVjdHMucmVmZXJlbmNlW21haW5BeGlzXSArIHJlY3RzLnJlZmVyZW5jZVtsZW5dIC0gY29tcHV0ZWRPZmZzZXQubWFpbkF4aXM7XG4gICAgICAgIGlmIChtYWluQXhpc0Nvb3JkIDwgbGltaXRNaW4pIHtcbiAgICAgICAgICBtYWluQXhpc0Nvb3JkID0gbGltaXRNaW47XG4gICAgICAgIH0gZWxzZSBpZiAobWFpbkF4aXNDb29yZCA+IGxpbWl0TWF4KSB7XG4gICAgICAgICAgbWFpbkF4aXNDb29yZCA9IGxpbWl0TWF4O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoY2hlY2tDcm9zc0F4aXMpIHtcbiAgICAgICAgdmFyIF9taWRkbGV3YXJlRGF0YSRvZmZzZSwgX21pZGRsZXdhcmVEYXRhJG9mZnNlMjtcbiAgICAgICAgY29uc3QgbGVuID0gbWFpbkF4aXMgPT09ICd5JyA/ICd3aWR0aCcgOiAnaGVpZ2h0JztcbiAgICAgICAgY29uc3QgaXNPcmlnaW5TaWRlID0gWyd0b3AnLCAnbGVmdCddLmluY2x1ZGVzKGdldFNpZGUocGxhY2VtZW50KSk7XG4gICAgICAgIGNvbnN0IGxpbWl0TWluID0gcmVjdHMucmVmZXJlbmNlW2Nyb3NzQXhpc10gLSByZWN0cy5mbG9hdGluZ1tsZW5dICsgKGlzT3JpZ2luU2lkZSA/ICgoX21pZGRsZXdhcmVEYXRhJG9mZnNlID0gbWlkZGxld2FyZURhdGEub2Zmc2V0KSA9PSBudWxsID8gdm9pZCAwIDogX21pZGRsZXdhcmVEYXRhJG9mZnNlW2Nyb3NzQXhpc10pIHx8IDAgOiAwKSArIChpc09yaWdpblNpZGUgPyAwIDogY29tcHV0ZWRPZmZzZXQuY3Jvc3NBeGlzKTtcbiAgICAgICAgY29uc3QgbGltaXRNYXggPSByZWN0cy5yZWZlcmVuY2VbY3Jvc3NBeGlzXSArIHJlY3RzLnJlZmVyZW5jZVtsZW5dICsgKGlzT3JpZ2luU2lkZSA/IDAgOiAoKF9taWRkbGV3YXJlRGF0YSRvZmZzZTIgPSBtaWRkbGV3YXJlRGF0YS5vZmZzZXQpID09IG51bGwgPyB2b2lkIDAgOiBfbWlkZGxld2FyZURhdGEkb2Zmc2UyW2Nyb3NzQXhpc10pIHx8IDApIC0gKGlzT3JpZ2luU2lkZSA/IGNvbXB1dGVkT2Zmc2V0LmNyb3NzQXhpcyA6IDApO1xuICAgICAgICBpZiAoY3Jvc3NBeGlzQ29vcmQgPCBsaW1pdE1pbikge1xuICAgICAgICAgIGNyb3NzQXhpc0Nvb3JkID0gbGltaXRNaW47XG4gICAgICAgIH0gZWxzZSBpZiAoY3Jvc3NBeGlzQ29vcmQgPiBsaW1pdE1heCkge1xuICAgICAgICAgIGNyb3NzQXhpc0Nvb3JkID0gbGltaXRNYXg7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIFttYWluQXhpc106IG1haW5BeGlzQ29vcmQsXG4gICAgICAgIFtjcm9zc0F4aXNdOiBjcm9zc0F4aXNDb29yZFxuICAgICAgfTtcbiAgICB9XG4gIH07XG59O1xuXG4vKipcbiAqIFByb3ZpZGVzIGRhdGEgdGhhdCBhbGxvd3MgeW91IHRvIGNoYW5nZSB0aGUgc2l6ZSBvZiB0aGUgZmxvYXRpbmcgZWxlbWVudCDigJRcbiAqIGZvciBpbnN0YW5jZSwgcHJldmVudCBpdCBmcm9tIG92ZXJmbG93aW5nIHRoZSBjbGlwcGluZyBib3VuZGFyeSBvciBtYXRjaCB0aGVcbiAqIHdpZHRoIG9mIHRoZSByZWZlcmVuY2UgZWxlbWVudC5cbiAqIEBzZWUgaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy9zaXplXG4gKi9cbmNvbnN0IHNpemUgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG4gIHJldHVybiB7XG4gICAgbmFtZTogJ3NpemUnLFxuICAgIG9wdGlvbnMsXG4gICAgYXN5bmMgZm4oc3RhdGUpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgcGxhY2VtZW50LFxuICAgICAgICByZWN0cyxcbiAgICAgICAgcGxhdGZvcm0sXG4gICAgICAgIGVsZW1lbnRzXG4gICAgICB9ID0gc3RhdGU7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGFwcGx5ID0gKCkgPT4ge30sXG4gICAgICAgIC4uLmRldGVjdE92ZXJmbG93T3B0aW9uc1xuICAgICAgfSA9IGV2YWx1YXRlKG9wdGlvbnMsIHN0YXRlKTtcbiAgICAgIGNvbnN0IG92ZXJmbG93ID0gYXdhaXQgZGV0ZWN0T3ZlcmZsb3coc3RhdGUsIGRldGVjdE92ZXJmbG93T3B0aW9ucyk7XG4gICAgICBjb25zdCBzaWRlID0gZ2V0U2lkZShwbGFjZW1lbnQpO1xuICAgICAgY29uc3QgYWxpZ25tZW50ID0gZ2V0QWxpZ25tZW50KHBsYWNlbWVudCk7XG4gICAgICBjb25zdCBpc1lBeGlzID0gZ2V0U2lkZUF4aXMocGxhY2VtZW50KSA9PT0gJ3knO1xuICAgICAgY29uc3Qge1xuICAgICAgICB3aWR0aCxcbiAgICAgICAgaGVpZ2h0XG4gICAgICB9ID0gcmVjdHMuZmxvYXRpbmc7XG4gICAgICBsZXQgaGVpZ2h0U2lkZTtcbiAgICAgIGxldCB3aWR0aFNpZGU7XG4gICAgICBpZiAoc2lkZSA9PT0gJ3RvcCcgfHwgc2lkZSA9PT0gJ2JvdHRvbScpIHtcbiAgICAgICAgaGVpZ2h0U2lkZSA9IHNpZGU7XG4gICAgICAgIHdpZHRoU2lkZSA9IGFsaWdubWVudCA9PT0gKChhd2FpdCAocGxhdGZvcm0uaXNSVEwgPT0gbnVsbCA/IHZvaWQgMCA6IHBsYXRmb3JtLmlzUlRMKGVsZW1lbnRzLmZsb2F0aW5nKSkpID8gJ3N0YXJ0JyA6ICdlbmQnKSA/ICdsZWZ0JyA6ICdyaWdodCc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3aWR0aFNpZGUgPSBzaWRlO1xuICAgICAgICBoZWlnaHRTaWRlID0gYWxpZ25tZW50ID09PSAnZW5kJyA/ICd0b3AnIDogJ2JvdHRvbSc7XG4gICAgICB9XG4gICAgICBjb25zdCBvdmVyZmxvd0F2YWlsYWJsZUhlaWdodCA9IGhlaWdodCAtIG92ZXJmbG93W2hlaWdodFNpZGVdO1xuICAgICAgY29uc3Qgb3ZlcmZsb3dBdmFpbGFibGVXaWR0aCA9IHdpZHRoIC0gb3ZlcmZsb3dbd2lkdGhTaWRlXTtcbiAgICAgIGNvbnN0IG5vU2hpZnQgPSAhc3RhdGUubWlkZGxld2FyZURhdGEuc2hpZnQ7XG4gICAgICBsZXQgYXZhaWxhYmxlSGVpZ2h0ID0gb3ZlcmZsb3dBdmFpbGFibGVIZWlnaHQ7XG4gICAgICBsZXQgYXZhaWxhYmxlV2lkdGggPSBvdmVyZmxvd0F2YWlsYWJsZVdpZHRoO1xuICAgICAgaWYgKGlzWUF4aXMpIHtcbiAgICAgICAgY29uc3QgbWF4aW11bUNsaXBwaW5nV2lkdGggPSB3aWR0aCAtIG92ZXJmbG93LmxlZnQgLSBvdmVyZmxvdy5yaWdodDtcbiAgICAgICAgYXZhaWxhYmxlV2lkdGggPSBhbGlnbm1lbnQgfHwgbm9TaGlmdCA/IG1pbihvdmVyZmxvd0F2YWlsYWJsZVdpZHRoLCBtYXhpbXVtQ2xpcHBpbmdXaWR0aCkgOiBtYXhpbXVtQ2xpcHBpbmdXaWR0aDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IG1heGltdW1DbGlwcGluZ0hlaWdodCA9IGhlaWdodCAtIG92ZXJmbG93LnRvcCAtIG92ZXJmbG93LmJvdHRvbTtcbiAgICAgICAgYXZhaWxhYmxlSGVpZ2h0ID0gYWxpZ25tZW50IHx8IG5vU2hpZnQgPyBtaW4ob3ZlcmZsb3dBdmFpbGFibGVIZWlnaHQsIG1heGltdW1DbGlwcGluZ0hlaWdodCkgOiBtYXhpbXVtQ2xpcHBpbmdIZWlnaHQ7XG4gICAgICB9XG4gICAgICBpZiAobm9TaGlmdCAmJiAhYWxpZ25tZW50KSB7XG4gICAgICAgIGNvbnN0IHhNaW4gPSBtYXgob3ZlcmZsb3cubGVmdCwgMCk7XG4gICAgICAgIGNvbnN0IHhNYXggPSBtYXgob3ZlcmZsb3cucmlnaHQsIDApO1xuICAgICAgICBjb25zdCB5TWluID0gbWF4KG92ZXJmbG93LnRvcCwgMCk7XG4gICAgICAgIGNvbnN0IHlNYXggPSBtYXgob3ZlcmZsb3cuYm90dG9tLCAwKTtcbiAgICAgICAgaWYgKGlzWUF4aXMpIHtcbiAgICAgICAgICBhdmFpbGFibGVXaWR0aCA9IHdpZHRoIC0gMiAqICh4TWluICE9PSAwIHx8IHhNYXggIT09IDAgPyB4TWluICsgeE1heCA6IG1heChvdmVyZmxvdy5sZWZ0LCBvdmVyZmxvdy5yaWdodCkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGF2YWlsYWJsZUhlaWdodCA9IGhlaWdodCAtIDIgKiAoeU1pbiAhPT0gMCB8fCB5TWF4ICE9PSAwID8geU1pbiArIHlNYXggOiBtYXgob3ZlcmZsb3cudG9wLCBvdmVyZmxvdy5ib3R0b20pKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYXdhaXQgYXBwbHkoe1xuICAgICAgICAuLi5zdGF0ZSxcbiAgICAgICAgYXZhaWxhYmxlV2lkdGgsXG4gICAgICAgIGF2YWlsYWJsZUhlaWdodFxuICAgICAgfSk7XG4gICAgICBjb25zdCBuZXh0RGltZW5zaW9ucyA9IGF3YWl0IHBsYXRmb3JtLmdldERpbWVuc2lvbnMoZWxlbWVudHMuZmxvYXRpbmcpO1xuICAgICAgaWYgKHdpZHRoICE9PSBuZXh0RGltZW5zaW9ucy53aWR0aCB8fCBoZWlnaHQgIT09IG5leHREaW1lbnNpb25zLmhlaWdodCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHJlc2V0OiB7XG4gICAgICAgICAgICByZWN0czogdHJ1ZVxuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7fTtcbiAgICB9XG4gIH07XG59O1xuXG5leHBvcnQgeyBhcnJvdywgYXV0b1BsYWNlbWVudCwgY29tcHV0ZVBvc2l0aW9uLCBkZXRlY3RPdmVyZmxvdywgZmxpcCwgaGlkZSwgaW5saW5lLCBsaW1pdFNoaWZ0LCBvZmZzZXQsIHNoaWZ0LCBzaXplIH07XG4iXSwibmFtZXMiOlsiZ2V0U2lkZUF4aXMiLCJnZXRBbGlnbm1lbnRBeGlzIiwiZ2V0QXhpc0xlbmd0aCIsImdldFNpZGUiLCJnZXRBbGlnbm1lbnQiLCJldmFsdWF0ZSIsImdldFBhZGRpbmdPYmplY3QiLCJyZWN0VG9DbGllbnRSZWN0IiwibWluIiwiY2xhbXAiLCJwbGFjZW1lbnRzIiwiZ2V0QWxpZ25tZW50U2lkZXMiLCJnZXRPcHBvc2l0ZUFsaWdubWVudFBsYWNlbWVudCIsImdldE9wcG9zaXRlUGxhY2VtZW50IiwiZ2V0RXhwYW5kZWRQbGFjZW1lbnRzIiwiZ2V0T3Bwb3NpdGVBeGlzUGxhY2VtZW50cyIsInNpZGVzIiwibWF4IiwiZ2V0T3Bwb3NpdGVBeGlzIiwiY29tcHV0ZUNvb3Jkc0Zyb21QbGFjZW1lbnQiLCJfcmVmIiwicGxhY2VtZW50IiwicnRsIiwicmVmZXJlbmNlIiwiZmxvYXRpbmciLCJzaWRlQXhpcyIsImFsaWdubWVudEF4aXMiLCJhbGlnbkxlbmd0aCIsInNpZGUiLCJpc1ZlcnRpY2FsIiwiY29tbW9uWCIsIngiLCJ3aWR0aCIsImNvbW1vblkiLCJ5IiwiaGVpZ2h0IiwiY29tbW9uQWxpZ24iLCJjb29yZHMiLCJjb21wdXRlUG9zaXRpb24iLCJjb25maWciLCJzdHJhdGVneSIsIm1pZGRsZXdhcmUiLCJwbGF0Zm9ybSIsInZhbGlkTWlkZGxld2FyZSIsImZpbHRlciIsIkJvb2xlYW4iLCJpc1JUTCIsInJlY3RzIiwiZ2V0RWxlbWVudFJlY3RzIiwic3RhdGVmdWxQbGFjZW1lbnQiLCJtaWRkbGV3YXJlRGF0YSIsInJlc2V0Q291bnQiLCJpIiwibGVuZ3RoIiwibmFtZSIsImZuIiwibmV4dFgiLCJuZXh0WSIsImRhdGEiLCJyZXNldCIsImluaXRpYWxQbGFjZW1lbnQiLCJlbGVtZW50cyIsImRldGVjdE92ZXJmbG93Iiwic3RhdGUiLCJvcHRpb25zIiwiX2F3YWl0JHBsYXRmb3JtJGlzRWxlIiwiYm91bmRhcnkiLCJyb290Qm91bmRhcnkiLCJlbGVtZW50Q29udGV4dCIsImFsdEJvdW5kYXJ5IiwicGFkZGluZyIsInBhZGRpbmdPYmplY3QiLCJhbHRDb250ZXh0IiwiZWxlbWVudCIsImNsaXBwaW5nQ2xpZW50UmVjdCIsImdldENsaXBwaW5nUmVjdCIsImlzRWxlbWVudCIsImNvbnRleHRFbGVtZW50IiwiZ2V0RG9jdW1lbnRFbGVtZW50IiwicmVjdCIsIm9mZnNldFBhcmVudCIsImdldE9mZnNldFBhcmVudCIsIm9mZnNldFNjYWxlIiwiZ2V0U2NhbGUiLCJlbGVtZW50Q2xpZW50UmVjdCIsImNvbnZlcnRPZmZzZXRQYXJlbnRSZWxhdGl2ZVJlY3RUb1ZpZXdwb3J0UmVsYXRpdmVSZWN0IiwidG9wIiwiYm90dG9tIiwibGVmdCIsInJpZ2h0IiwiYXJyb3ciLCJheGlzIiwiYXJyb3dEaW1lbnNpb25zIiwiZ2V0RGltZW5zaW9ucyIsImlzWUF4aXMiLCJtaW5Qcm9wIiwibWF4UHJvcCIsImNsaWVudFByb3AiLCJlbmREaWZmIiwic3RhcnREaWZmIiwiYXJyb3dPZmZzZXRQYXJlbnQiLCJjbGllbnRTaXplIiwiY2VudGVyVG9SZWZlcmVuY2UiLCJsYXJnZXN0UG9zc2libGVQYWRkaW5nIiwibWluUGFkZGluZyIsIm1heFBhZGRpbmciLCJtaW4kMSIsImNlbnRlciIsIm9mZnNldCIsInNob3VsZEFkZE9mZnNldCIsImFsaWdubWVudE9mZnNldCIsImNlbnRlck9mZnNldCIsImdldFBsYWNlbWVudExpc3QiLCJhbGlnbm1lbnQiLCJhdXRvQWxpZ25tZW50IiwiYWxsb3dlZFBsYWNlbWVudHMiLCJhbGxvd2VkUGxhY2VtZW50c1NvcnRlZEJ5QWxpZ25tZW50IiwiYXV0b1BsYWNlbWVudCIsIl9taWRkbGV3YXJlRGF0YSRhdXRvUCIsIl9taWRkbGV3YXJlRGF0YSRhdXRvUDIiLCJfcGxhY2VtZW50c1RoYXRGaXRPbkUiLCJjcm9zc0F4aXMiLCJkZXRlY3RPdmVyZmxvd09wdGlvbnMiLCJwbGFjZW1lbnRzJDEiLCJ1bmRlZmluZWQiLCJvdmVyZmxvdyIsImN1cnJlbnRJbmRleCIsImluZGV4IiwiY3VycmVudFBsYWNlbWVudCIsImFsaWdubWVudFNpZGVzIiwiY3VycmVudE92ZXJmbG93cyIsImFsbE92ZXJmbG93cyIsIm92ZXJmbG93cyIsIm5leHRQbGFjZW1lbnQiLCJwbGFjZW1lbnRzU29ydGVkQnlNb3N0U3BhY2UiLCJtYXAiLCJkIiwic2xpY2UiLCJyZWR1Y2UiLCJhY2MiLCJ2Iiwic29ydCIsImEiLCJiIiwicGxhY2VtZW50c1RoYXRGaXRPbkVhY2hTaWRlIiwiZXZlcnkiLCJyZXNldFBsYWNlbWVudCIsImZsaXAiLCJfbWlkZGxld2FyZURhdGEkYXJyb3ciLCJfbWlkZGxld2FyZURhdGEkZmxpcCIsIm1haW5BeGlzIiwiY2hlY2tNYWluQXhpcyIsImNoZWNrQ3Jvc3NBeGlzIiwiZmFsbGJhY2tQbGFjZW1lbnRzIiwic3BlY2lmaWVkRmFsbGJhY2tQbGFjZW1lbnRzIiwiZmFsbGJhY2tTdHJhdGVneSIsImZhbGxiYWNrQXhpc1NpZGVEaXJlY3Rpb24iLCJmbGlwQWxpZ25tZW50IiwiaXNCYXNlUGxhY2VtZW50IiwicHVzaCIsIm92ZXJmbG93c0RhdGEiLCJfbWlkZGxld2FyZURhdGEkZmxpcDIiLCJfb3ZlcmZsb3dzRGF0YSRmaWx0ZXIiLCJuZXh0SW5kZXgiLCJfb3ZlcmZsb3dzRGF0YSRtYXAkc28iLCJnZXRTaWRlT2Zmc2V0cyIsImlzQW55U2lkZUZ1bGx5Q2xpcHBlZCIsInNvbWUiLCJoaWRlIiwib2Zmc2V0cyIsInJlZmVyZW5jZUhpZGRlbk9mZnNldHMiLCJyZWZlcmVuY2VIaWRkZW4iLCJlc2NhcGVkT2Zmc2V0cyIsImVzY2FwZWQiLCJnZXRCb3VuZGluZ1JlY3QiLCJtaW5YIiwibWluWSIsIm1heFgiLCJtYXhZIiwiZ2V0UmVjdHNCeUxpbmUiLCJzb3J0ZWRSZWN0cyIsImdyb3VwcyIsInByZXZSZWN0IiwiaW5saW5lIiwibmF0aXZlQ2xpZW50UmVjdHMiLCJBcnJheSIsImZyb20iLCJnZXRDbGllbnRSZWN0cyIsImNsaWVudFJlY3RzIiwiZmFsbGJhY2siLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJmaW5kIiwiZmlyc3RSZWN0IiwibGFzdFJlY3QiLCJpc1RvcCIsImlzTGVmdFNpZGUiLCJtYXhSaWdodCIsIm1pbkxlZnQiLCJtZWFzdXJlUmVjdHMiLCJyZXNldFJlY3RzIiwiY29udmVydFZhbHVlVG9Db29yZHMiLCJtYWluQXhpc011bHRpIiwiaW5jbHVkZXMiLCJjcm9zc0F4aXNNdWx0aSIsInJhd1ZhbHVlIiwiX21pZGRsZXdhcmVEYXRhJG9mZnNlIiwiZGlmZkNvb3JkcyIsInNoaWZ0IiwibGltaXRlciIsIm1haW5BeGlzQ29vcmQiLCJjcm9zc0F4aXNDb29yZCIsIm1pblNpZGUiLCJtYXhTaWRlIiwibGltaXRlZENvb3JkcyIsImxpbWl0U2hpZnQiLCJyYXdPZmZzZXQiLCJjb21wdXRlZE9mZnNldCIsImxlbiIsImxpbWl0TWluIiwibGltaXRNYXgiLCJfbWlkZGxld2FyZURhdGEkb2Zmc2UyIiwiaXNPcmlnaW5TaWRlIiwic2l6ZSIsImFwcGx5IiwiaGVpZ2h0U2lkZSIsIndpZHRoU2lkZSIsIm92ZXJmbG93QXZhaWxhYmxlSGVpZ2h0Iiwib3ZlcmZsb3dBdmFpbGFibGVXaWR0aCIsIm5vU2hpZnQiLCJhdmFpbGFibGVIZWlnaHQiLCJhdmFpbGFibGVXaWR0aCIsIm1heGltdW1DbGlwcGluZ1dpZHRoIiwibWF4aW11bUNsaXBwaW5nSGVpZ2h0IiwieE1pbiIsInhNYXgiLCJ5TWluIiwieU1heCIsIm5leHREaW1lbnNpb25zIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@floating-ui/core/dist/floating-ui.core.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@floating-ui/dom/dist/floating-ui.dom.mjs":
/*!****************************************************************!*\
  !*** ./node_modules/@floating-ui/dom/dist/floating-ui.dom.mjs ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   arrow: () => (/* binding */ arrow),\n/* harmony export */   autoPlacement: () => (/* binding */ autoPlacement),\n/* harmony export */   autoUpdate: () => (/* binding */ autoUpdate),\n/* harmony export */   computePosition: () => (/* binding */ computePosition),\n/* harmony export */   detectOverflow: () => (/* reexport safe */ _floating_ui_core__WEBPACK_IMPORTED_MODULE_0__.detectOverflow),\n/* harmony export */   flip: () => (/* binding */ flip),\n/* harmony export */   getOverflowAncestors: () => (/* reexport safe */ _floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getOverflowAncestors),\n/* harmony export */   hide: () => (/* binding */ hide),\n/* harmony export */   inline: () => (/* binding */ inline),\n/* harmony export */   limitShift: () => (/* binding */ limitShift),\n/* harmony export */   offset: () => (/* reexport safe */ _floating_ui_core__WEBPACK_IMPORTED_MODULE_0__.offset),\n/* harmony export */   platform: () => (/* binding */ platform),\n/* harmony export */   shift: () => (/* binding */ shift),\n/* harmony export */   size: () => (/* binding */ size)\n/* harmony export */ });\n/* harmony import */ var _floating_ui_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @floating-ui/utils */ \"(ssr)/./node_modules/@floating-ui/utils/dist/floating-ui.utils.mjs\");\n/* harmony import */ var _floating_ui_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @floating-ui/core */ \"(ssr)/./node_modules/@floating-ui/core/dist/floating-ui.core.mjs\");\n/* harmony import */ var _floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @floating-ui/utils/dom */ \"(ssr)/./node_modules/@floating-ui/utils/dist/floating-ui.utils.dom.mjs\");\n\n\n\n\n\nfunction getCssDimensions(element) {\n    const css = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getComputedStyle)(element);\n    // In testing environments, the `width` and `height` properties are empty\n    // strings for SVG elements, returning NaN. Fallback to `0` in this case.\n    let width = parseFloat(css.width) || 0;\n    let height = parseFloat(css.height) || 0;\n    const hasOffset = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.isHTMLElement)(element);\n    const offsetWidth = hasOffset ? element.offsetWidth : width;\n    const offsetHeight = hasOffset ? element.offsetHeight : height;\n    const shouldFallback = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_2__.round)(width) !== offsetWidth || (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_2__.round)(height) !== offsetHeight;\n    if (shouldFallback) {\n        width = offsetWidth;\n        height = offsetHeight;\n    }\n    return {\n        width,\n        height,\n        $: shouldFallback\n    };\n}\nfunction unwrapElement(element) {\n    return !(0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.isElement)(element) ? element.contextElement : element;\n}\nfunction getScale(element) {\n    const domElement = unwrapElement(element);\n    if (!(0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.isHTMLElement)(domElement)) {\n        return (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_2__.createCoords)(1);\n    }\n    const rect = domElement.getBoundingClientRect();\n    const { width, height, $ } = getCssDimensions(domElement);\n    let x = ($ ? (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_2__.round)(rect.width) : rect.width) / width;\n    let y = ($ ? (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_2__.round)(rect.height) : rect.height) / height;\n    // 0, NaN, or Infinity should always fallback to 1.\n    if (!x || !Number.isFinite(x)) {\n        x = 1;\n    }\n    if (!y || !Number.isFinite(y)) {\n        y = 1;\n    }\n    return {\n        x,\n        y\n    };\n}\nconst noOffsets = /*#__PURE__*/ (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_2__.createCoords)(0);\nfunction getVisualOffsets(element) {\n    const win = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getWindow)(element);\n    if (!(0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.isWebKit)() || !win.visualViewport) {\n        return noOffsets;\n    }\n    return {\n        x: win.visualViewport.offsetLeft,\n        y: win.visualViewport.offsetTop\n    };\n}\nfunction shouldAddVisualOffsets(element, isFixed, floatingOffsetParent) {\n    if (isFixed === void 0) {\n        isFixed = false;\n    }\n    if (!floatingOffsetParent || isFixed && floatingOffsetParent !== (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getWindow)(element)) {\n        return false;\n    }\n    return isFixed;\n}\nfunction getBoundingClientRect(element, includeScale, isFixedStrategy, offsetParent) {\n    if (includeScale === void 0) {\n        includeScale = false;\n    }\n    if (isFixedStrategy === void 0) {\n        isFixedStrategy = false;\n    }\n    const clientRect = element.getBoundingClientRect();\n    const domElement = unwrapElement(element);\n    let scale = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_2__.createCoords)(1);\n    if (includeScale) {\n        if (offsetParent) {\n            if ((0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.isElement)(offsetParent)) {\n                scale = getScale(offsetParent);\n            }\n        } else {\n            scale = getScale(element);\n        }\n    }\n    const visualOffsets = shouldAddVisualOffsets(domElement, isFixedStrategy, offsetParent) ? getVisualOffsets(domElement) : (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_2__.createCoords)(0);\n    let x = (clientRect.left + visualOffsets.x) / scale.x;\n    let y = (clientRect.top + visualOffsets.y) / scale.y;\n    let width = clientRect.width / scale.x;\n    let height = clientRect.height / scale.y;\n    if (domElement) {\n        const win = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getWindow)(domElement);\n        const offsetWin = offsetParent && (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.isElement)(offsetParent) ? (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getWindow)(offsetParent) : offsetParent;\n        let currentWin = win;\n        let currentIFrame = currentWin.frameElement;\n        while(currentIFrame && offsetParent && offsetWin !== currentWin){\n            const iframeScale = getScale(currentIFrame);\n            const iframeRect = currentIFrame.getBoundingClientRect();\n            const css = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getComputedStyle)(currentIFrame);\n            const left = iframeRect.left + (currentIFrame.clientLeft + parseFloat(css.paddingLeft)) * iframeScale.x;\n            const top = iframeRect.top + (currentIFrame.clientTop + parseFloat(css.paddingTop)) * iframeScale.y;\n            x *= iframeScale.x;\n            y *= iframeScale.y;\n            width *= iframeScale.x;\n            height *= iframeScale.y;\n            x += left;\n            y += top;\n            currentWin = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getWindow)(currentIFrame);\n            currentIFrame = currentWin.frameElement;\n        }\n    }\n    return (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_2__.rectToClientRect)({\n        width,\n        height,\n        x,\n        y\n    });\n}\nconst topLayerSelectors = [\n    \":popover-open\",\n    \":modal\"\n];\nfunction isTopLayer(floating) {\n    return topLayerSelectors.some((selector)=>{\n        try {\n            return floating.matches(selector);\n        } catch (e) {\n            return false;\n        }\n    });\n}\nfunction convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {\n    let { elements, rect, offsetParent, strategy } = _ref;\n    const isFixed = strategy === \"fixed\";\n    const documentElement = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getDocumentElement)(offsetParent);\n    const topLayer = elements ? isTopLayer(elements.floating) : false;\n    if (offsetParent === documentElement || topLayer && isFixed) {\n        return rect;\n    }\n    let scroll = {\n        scrollLeft: 0,\n        scrollTop: 0\n    };\n    let scale = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_2__.createCoords)(1);\n    const offsets = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_2__.createCoords)(0);\n    const isOffsetParentAnElement = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.isHTMLElement)(offsetParent);\n    if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {\n        if ((0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getNodeName)(offsetParent) !== \"body\" || (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.isOverflowElement)(documentElement)) {\n            scroll = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getNodeScroll)(offsetParent);\n        }\n        if ((0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.isHTMLElement)(offsetParent)) {\n            const offsetRect = getBoundingClientRect(offsetParent);\n            scale = getScale(offsetParent);\n            offsets.x = offsetRect.x + offsetParent.clientLeft;\n            offsets.y = offsetRect.y + offsetParent.clientTop;\n        }\n    }\n    return {\n        width: rect.width * scale.x,\n        height: rect.height * scale.y,\n        x: rect.x * scale.x - scroll.scrollLeft * scale.x + offsets.x,\n        y: rect.y * scale.y - scroll.scrollTop * scale.y + offsets.y\n    };\n}\nfunction getClientRects(element) {\n    return Array.from(element.getClientRects());\n}\nfunction getWindowScrollBarX(element) {\n    // If <html> has a CSS width greater than the viewport, then this will be\n    // incorrect for RTL.\n    return getBoundingClientRect((0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getDocumentElement)(element)).left + (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getNodeScroll)(element).scrollLeft;\n}\n// Gets the entire size of the scrollable document area, even extending outside\n// of the `<html>` and `<body>` rect bounds if horizontally scrollable.\nfunction getDocumentRect(element) {\n    const html = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getDocumentElement)(element);\n    const scroll = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getNodeScroll)(element);\n    const body = element.ownerDocument.body;\n    const width = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_2__.max)(html.scrollWidth, html.clientWidth, body.scrollWidth, body.clientWidth);\n    const height = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_2__.max)(html.scrollHeight, html.clientHeight, body.scrollHeight, body.clientHeight);\n    let x = -scroll.scrollLeft + getWindowScrollBarX(element);\n    const y = -scroll.scrollTop;\n    if ((0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getComputedStyle)(body).direction === \"rtl\") {\n        x += (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_2__.max)(html.clientWidth, body.clientWidth) - width;\n    }\n    return {\n        width,\n        height,\n        x,\n        y\n    };\n}\nfunction getViewportRect(element, strategy) {\n    const win = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getWindow)(element);\n    const html = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getDocumentElement)(element);\n    const visualViewport = win.visualViewport;\n    let width = html.clientWidth;\n    let height = html.clientHeight;\n    let x = 0;\n    let y = 0;\n    if (visualViewport) {\n        width = visualViewport.width;\n        height = visualViewport.height;\n        const visualViewportBased = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.isWebKit)();\n        if (!visualViewportBased || visualViewportBased && strategy === \"fixed\") {\n            x = visualViewport.offsetLeft;\n            y = visualViewport.offsetTop;\n        }\n    }\n    return {\n        width,\n        height,\n        x,\n        y\n    };\n}\n// Returns the inner client rect, subtracting scrollbars if present.\nfunction getInnerBoundingClientRect(element, strategy) {\n    const clientRect = getBoundingClientRect(element, true, strategy === \"fixed\");\n    const top = clientRect.top + element.clientTop;\n    const left = clientRect.left + element.clientLeft;\n    const scale = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.isHTMLElement)(element) ? getScale(element) : (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_2__.createCoords)(1);\n    const width = element.clientWidth * scale.x;\n    const height = element.clientHeight * scale.y;\n    const x = left * scale.x;\n    const y = top * scale.y;\n    return {\n        width,\n        height,\n        x,\n        y\n    };\n}\nfunction getClientRectFromClippingAncestor(element, clippingAncestor, strategy) {\n    let rect;\n    if (clippingAncestor === \"viewport\") {\n        rect = getViewportRect(element, strategy);\n    } else if (clippingAncestor === \"document\") {\n        rect = getDocumentRect((0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getDocumentElement)(element));\n    } else if ((0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.isElement)(clippingAncestor)) {\n        rect = getInnerBoundingClientRect(clippingAncestor, strategy);\n    } else {\n        const visualOffsets = getVisualOffsets(element);\n        rect = {\n            ...clippingAncestor,\n            x: clippingAncestor.x - visualOffsets.x,\n            y: clippingAncestor.y - visualOffsets.y\n        };\n    }\n    return (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_2__.rectToClientRect)(rect);\n}\nfunction hasFixedPositionAncestor(element, stopNode) {\n    const parentNode = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getParentNode)(element);\n    if (parentNode === stopNode || !(0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.isElement)(parentNode) || (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.isLastTraversableNode)(parentNode)) {\n        return false;\n    }\n    return (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getComputedStyle)(parentNode).position === \"fixed\" || hasFixedPositionAncestor(parentNode, stopNode);\n}\n// A \"clipping ancestor\" is an `overflow` element with the characteristic of\n// clipping (or hiding) child elements. This returns all clipping ancestors\n// of the given element up the tree.\nfunction getClippingElementAncestors(element, cache) {\n    const cachedResult = cache.get(element);\n    if (cachedResult) {\n        return cachedResult;\n    }\n    let result = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getOverflowAncestors)(element, [], false).filter((el)=>(0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.isElement)(el) && (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getNodeName)(el) !== \"body\");\n    let currentContainingBlockComputedStyle = null;\n    const elementIsFixed = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getComputedStyle)(element).position === \"fixed\";\n    let currentNode = elementIsFixed ? (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getParentNode)(element) : element;\n    // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block\n    while((0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.isElement)(currentNode) && !(0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.isLastTraversableNode)(currentNode)){\n        const computedStyle = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getComputedStyle)(currentNode);\n        const currentNodeIsContaining = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.isContainingBlock)(currentNode);\n        if (!currentNodeIsContaining && computedStyle.position === \"fixed\") {\n            currentContainingBlockComputedStyle = null;\n        }\n        const shouldDropCurrentNode = elementIsFixed ? !currentNodeIsContaining && !currentContainingBlockComputedStyle : !currentNodeIsContaining && computedStyle.position === \"static\" && !!currentContainingBlockComputedStyle && [\n            \"absolute\",\n            \"fixed\"\n        ].includes(currentContainingBlockComputedStyle.position) || (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.isOverflowElement)(currentNode) && !currentNodeIsContaining && hasFixedPositionAncestor(element, currentNode);\n        if (shouldDropCurrentNode) {\n            // Drop non-containing blocks.\n            result = result.filter((ancestor)=>ancestor !== currentNode);\n        } else {\n            // Record last containing block for next iteration.\n            currentContainingBlockComputedStyle = computedStyle;\n        }\n        currentNode = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getParentNode)(currentNode);\n    }\n    cache.set(element, result);\n    return result;\n}\n// Gets the maximum area that the element is visible in due to any number of\n// clipping ancestors.\nfunction getClippingRect(_ref) {\n    let { element, boundary, rootBoundary, strategy } = _ref;\n    const elementClippingAncestors = boundary === \"clippingAncestors\" ? getClippingElementAncestors(element, this._c) : [].concat(boundary);\n    const clippingAncestors = [\n        ...elementClippingAncestors,\n        rootBoundary\n    ];\n    const firstClippingAncestor = clippingAncestors[0];\n    const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor)=>{\n        const rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);\n        accRect.top = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_2__.max)(rect.top, accRect.top);\n        accRect.right = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_2__.min)(rect.right, accRect.right);\n        accRect.bottom = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_2__.min)(rect.bottom, accRect.bottom);\n        accRect.left = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_2__.max)(rect.left, accRect.left);\n        return accRect;\n    }, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));\n    return {\n        width: clippingRect.right - clippingRect.left,\n        height: clippingRect.bottom - clippingRect.top,\n        x: clippingRect.left,\n        y: clippingRect.top\n    };\n}\nfunction getDimensions(element) {\n    const { width, height } = getCssDimensions(element);\n    return {\n        width,\n        height\n    };\n}\nfunction getRectRelativeToOffsetParent(element, offsetParent, strategy) {\n    const isOffsetParentAnElement = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.isHTMLElement)(offsetParent);\n    const documentElement = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getDocumentElement)(offsetParent);\n    const isFixed = strategy === \"fixed\";\n    const rect = getBoundingClientRect(element, true, isFixed, offsetParent);\n    let scroll = {\n        scrollLeft: 0,\n        scrollTop: 0\n    };\n    const offsets = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_2__.createCoords)(0);\n    if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {\n        if ((0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getNodeName)(offsetParent) !== \"body\" || (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.isOverflowElement)(documentElement)) {\n            scroll = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getNodeScroll)(offsetParent);\n        }\n        if (isOffsetParentAnElement) {\n            const offsetRect = getBoundingClientRect(offsetParent, true, isFixed, offsetParent);\n            offsets.x = offsetRect.x + offsetParent.clientLeft;\n            offsets.y = offsetRect.y + offsetParent.clientTop;\n        } else if (documentElement) {\n            offsets.x = getWindowScrollBarX(documentElement);\n        }\n    }\n    const x = rect.left + scroll.scrollLeft - offsets.x;\n    const y = rect.top + scroll.scrollTop - offsets.y;\n    return {\n        x,\n        y,\n        width: rect.width,\n        height: rect.height\n    };\n}\nfunction getTrueOffsetParent(element, polyfill) {\n    if (!(0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.isHTMLElement)(element) || (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getComputedStyle)(element).position === \"fixed\") {\n        return null;\n    }\n    if (polyfill) {\n        return polyfill(element);\n    }\n    return element.offsetParent;\n}\n// Gets the closest ancestor positioned element. Handles some edge cases,\n// such as table ancestors and cross browser bugs.\nfunction getOffsetParent(element, polyfill) {\n    const window = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getWindow)(element);\n    if (!(0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.isHTMLElement)(element) || isTopLayer(element)) {\n        return window;\n    }\n    let offsetParent = getTrueOffsetParent(element, polyfill);\n    while(offsetParent && (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.isTableElement)(offsetParent) && (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getComputedStyle)(offsetParent).position === \"static\"){\n        offsetParent = getTrueOffsetParent(offsetParent, polyfill);\n    }\n    if (offsetParent && ((0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getNodeName)(offsetParent) === \"html\" || (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getNodeName)(offsetParent) === \"body\" && (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getComputedStyle)(offsetParent).position === \"static\" && !(0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.isContainingBlock)(offsetParent))) {\n        return window;\n    }\n    return offsetParent || (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getContainingBlock)(element) || window;\n}\nconst getElementRects = async function(data) {\n    const getOffsetParentFn = this.getOffsetParent || getOffsetParent;\n    const getDimensionsFn = this.getDimensions;\n    return {\n        reference: getRectRelativeToOffsetParent(data.reference, await getOffsetParentFn(data.floating), data.strategy),\n        floating: {\n            x: 0,\n            y: 0,\n            ...await getDimensionsFn(data.floating)\n        }\n    };\n};\nfunction isRTL(element) {\n    return (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getComputedStyle)(element).direction === \"rtl\";\n}\nconst platform = {\n    convertOffsetParentRelativeRectToViewportRelativeRect,\n    getDocumentElement: _floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getDocumentElement,\n    getClippingRect,\n    getOffsetParent,\n    getElementRects,\n    getClientRects,\n    getDimensions,\n    getScale,\n    isElement: _floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.isElement,\n    isRTL\n};\n// https://samthor.au/2021/observing-dom/\nfunction observeMove(element, onMove) {\n    let io = null;\n    let timeoutId;\n    const root = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getDocumentElement)(element);\n    function cleanup() {\n        var _io;\n        clearTimeout(timeoutId);\n        (_io = io) == null || _io.disconnect();\n        io = null;\n    }\n    function refresh(skip, threshold) {\n        if (skip === void 0) {\n            skip = false;\n        }\n        if (threshold === void 0) {\n            threshold = 1;\n        }\n        cleanup();\n        const { left, top, width, height } = element.getBoundingClientRect();\n        if (!skip) {\n            onMove();\n        }\n        if (!width || !height) {\n            return;\n        }\n        const insetTop = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_2__.floor)(top);\n        const insetRight = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_2__.floor)(root.clientWidth - (left + width));\n        const insetBottom = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_2__.floor)(root.clientHeight - (top + height));\n        const insetLeft = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_2__.floor)(left);\n        const rootMargin = -insetTop + \"px \" + -insetRight + \"px \" + -insetBottom + \"px \" + -insetLeft + \"px\";\n        const options = {\n            rootMargin,\n            threshold: (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_2__.max)(0, (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_2__.min)(1, threshold)) || 1\n        };\n        let isFirstUpdate = true;\n        function handleObserve(entries) {\n            const ratio = entries[0].intersectionRatio;\n            if (ratio !== threshold) {\n                if (!isFirstUpdate) {\n                    return refresh();\n                }\n                if (!ratio) {\n                    timeoutId = setTimeout(()=>{\n                        refresh(false, 1e-7);\n                    }, 100);\n                } else {\n                    refresh(false, ratio);\n                }\n            }\n            isFirstUpdate = false;\n        }\n        // Older browsers don't support a `document` as the root and will throw an\n        // error.\n        try {\n            io = new IntersectionObserver(handleObserve, {\n                ...options,\n                // Handle <iframe>s\n                root: root.ownerDocument\n            });\n        } catch (e) {\n            io = new IntersectionObserver(handleObserve, options);\n        }\n        io.observe(element);\n    }\n    refresh(true);\n    return cleanup;\n}\n/**\n * Automatically updates the position of the floating element when necessary.\n * Should only be called when the floating element is mounted on the DOM or\n * visible on the screen.\n * @returns cleanup function that should be invoked when the floating element is\n * removed from the DOM or hidden from the screen.\n * @see https://floating-ui.com/docs/autoUpdate\n */ function autoUpdate(reference, floating, update, options) {\n    if (options === void 0) {\n        options = {};\n    }\n    const { ancestorScroll = true, ancestorResize = true, elementResize = typeof ResizeObserver === \"function\", layoutShift = typeof IntersectionObserver === \"function\", animationFrame = false } = options;\n    const referenceEl = unwrapElement(reference);\n    const ancestors = ancestorScroll || ancestorResize ? [\n        ...referenceEl ? (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getOverflowAncestors)(referenceEl) : [],\n        ...(0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getOverflowAncestors)(floating)\n    ] : [];\n    ancestors.forEach((ancestor)=>{\n        ancestorScroll && ancestor.addEventListener(\"scroll\", update, {\n            passive: true\n        });\n        ancestorResize && ancestor.addEventListener(\"resize\", update);\n    });\n    const cleanupIo = referenceEl && layoutShift ? observeMove(referenceEl, update) : null;\n    let reobserveFrame = -1;\n    let resizeObserver = null;\n    if (elementResize) {\n        resizeObserver = new ResizeObserver((_ref)=>{\n            let [firstEntry] = _ref;\n            if (firstEntry && firstEntry.target === referenceEl && resizeObserver) {\n                // Prevent update loops when using the `size` middleware.\n                // https://github.com/floating-ui/floating-ui/issues/1740\n                resizeObserver.unobserve(floating);\n                cancelAnimationFrame(reobserveFrame);\n                reobserveFrame = requestAnimationFrame(()=>{\n                    var _resizeObserver;\n                    (_resizeObserver = resizeObserver) == null || _resizeObserver.observe(floating);\n                });\n            }\n            update();\n        });\n        if (referenceEl && !animationFrame) {\n            resizeObserver.observe(referenceEl);\n        }\n        resizeObserver.observe(floating);\n    }\n    let frameId;\n    let prevRefRect = animationFrame ? getBoundingClientRect(reference) : null;\n    if (animationFrame) {\n        frameLoop();\n    }\n    function frameLoop() {\n        const nextRefRect = getBoundingClientRect(reference);\n        if (prevRefRect && (nextRefRect.x !== prevRefRect.x || nextRefRect.y !== prevRefRect.y || nextRefRect.width !== prevRefRect.width || nextRefRect.height !== prevRefRect.height)) {\n            update();\n        }\n        prevRefRect = nextRefRect;\n        frameId = requestAnimationFrame(frameLoop);\n    }\n    update();\n    return ()=>{\n        var _resizeObserver2;\n        ancestors.forEach((ancestor)=>{\n            ancestorScroll && ancestor.removeEventListener(\"scroll\", update);\n            ancestorResize && ancestor.removeEventListener(\"resize\", update);\n        });\n        cleanupIo == null || cleanupIo();\n        (_resizeObserver2 = resizeObserver) == null || _resizeObserver2.disconnect();\n        resizeObserver = null;\n        if (animationFrame) {\n            cancelAnimationFrame(frameId);\n        }\n    };\n}\n/**\n * Optimizes the visibility of the floating element by choosing the placement\n * that has the most space available automatically, without needing to specify a\n * preferred placement. Alternative to `flip`.\n * @see https://floating-ui.com/docs/autoPlacement\n */ const autoPlacement = _floating_ui_core__WEBPACK_IMPORTED_MODULE_0__.autoPlacement;\n/**\n * Optimizes the visibility of the floating element by shifting it in order to\n * keep it in view when it will overflow the clipping boundary.\n * @see https://floating-ui.com/docs/shift\n */ const shift = _floating_ui_core__WEBPACK_IMPORTED_MODULE_0__.shift;\n/**\n * Optimizes the visibility of the floating element by flipping the `placement`\n * in order to keep it in view when the preferred placement(s) will overflow the\n * clipping boundary. Alternative to `autoPlacement`.\n * @see https://floating-ui.com/docs/flip\n */ const flip = _floating_ui_core__WEBPACK_IMPORTED_MODULE_0__.flip;\n/**\n * Provides data that allows you to change the size of the floating element â€”\n * for instance, prevent it from overflowing the clipping boundary or match the\n * width of the reference element.\n * @see https://floating-ui.com/docs/size\n */ const size = _floating_ui_core__WEBPACK_IMPORTED_MODULE_0__.size;\n/**\n * Provides data to hide the floating element in applicable situations, such as\n * when it is not in the same clipping context as the reference element.\n * @see https://floating-ui.com/docs/hide\n */ const hide = _floating_ui_core__WEBPACK_IMPORTED_MODULE_0__.hide;\n/**\n * Provides data to position an inner element of the floating element so that it\n * appears centered to the reference element.\n * @see https://floating-ui.com/docs/arrow\n */ const arrow = _floating_ui_core__WEBPACK_IMPORTED_MODULE_0__.arrow;\n/**\n * Provides improved positioning for inline reference elements that can span\n * over multiple lines, such as hyperlinks or range selections.\n * @see https://floating-ui.com/docs/inline\n */ const inline = _floating_ui_core__WEBPACK_IMPORTED_MODULE_0__.inline;\n/**\n * Built-in `limiter` that will stop `shift()` at a certain point.\n */ const limitShift = _floating_ui_core__WEBPACK_IMPORTED_MODULE_0__.limitShift;\n/**\n * Computes the `x` and `y` coordinates that will place the floating element\n * next to a given reference element.\n */ const computePosition = (reference, floating, options)=>{\n    // This caches the expensive `getClippingElementAncestors` function so that\n    // multiple lifecycle resets re-use the same result. It only lives for a\n    // single call. If other functions become expensive, we can add them as well.\n    const cache = new Map();\n    const mergedOptions = {\n        platform,\n        ...options\n    };\n    const platformWithCache = {\n        ...mergedOptions.platform,\n        _c: cache\n    };\n    return (0,_floating_ui_core__WEBPACK_IMPORTED_MODULE_0__.computePosition)(reference, floating, {\n        ...mergedOptions,\n        platform: platformWithCache\n    });\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGZsb2F0aW5nLXVpL2RvbS9kaXN0L2Zsb2F0aW5nLXVpLmRvbS5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBaVE7QUFDdE07QUFDZTtBQUNxTjtBQUNqTztBQUU5RCxTQUFTeUMsaUJBQWlCQyxPQUFPO0lBQy9CLE1BQU1DLE1BQU1qQix3RUFBZ0JBLENBQUNnQjtJQUM3Qix5RUFBeUU7SUFDekUseUVBQXlFO0lBQ3pFLElBQUlFLFFBQVFDLFdBQVdGLElBQUlDLEtBQUssS0FBSztJQUNyQyxJQUFJRSxTQUFTRCxXQUFXRixJQUFJRyxNQUFNLEtBQUs7SUFDdkMsTUFBTUMsWUFBWXBCLHFFQUFhQSxDQUFDZTtJQUNoQyxNQUFNTSxjQUFjRCxZQUFZTCxRQUFRTSxXQUFXLEdBQUdKO0lBQ3RELE1BQU1LLGVBQWVGLFlBQVlMLFFBQVFPLFlBQVksR0FBR0g7SUFDeEQsTUFBTUksaUJBQWlCN0IseURBQUtBLENBQUN1QixXQUFXSSxlQUFlM0IseURBQUtBLENBQUN5QixZQUFZRztJQUN6RSxJQUFJQyxnQkFBZ0I7UUFDbEJOLFFBQVFJO1FBQ1JGLFNBQVNHO0lBQ1g7SUFDQSxPQUFPO1FBQ0xMO1FBQ0FFO1FBQ0FLLEdBQUdEO0lBQ0w7QUFDRjtBQUVBLFNBQVNFLGNBQWNWLE9BQU87SUFDNUIsT0FBTyxDQUFDZCxpRUFBU0EsQ0FBQ2MsV0FBV0EsUUFBUVcsY0FBYyxHQUFHWDtBQUN4RDtBQUVBLFNBQVNZLFNBQVNaLE9BQU87SUFDdkIsTUFBTWEsYUFBYUgsY0FBY1Y7SUFDakMsSUFBSSxDQUFDZixxRUFBYUEsQ0FBQzRCLGFBQWE7UUFDOUIsT0FBT2pDLGdFQUFZQSxDQUFDO0lBQ3RCO0lBQ0EsTUFBTWtDLE9BQU9ELFdBQVdFLHFCQUFxQjtJQUM3QyxNQUFNLEVBQ0piLEtBQUssRUFDTEUsTUFBTSxFQUNOSyxDQUFDLEVBQ0YsR0FBR1YsaUJBQWlCYztJQUNyQixJQUFJRyxJQUFJLENBQUNQLElB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R2tCLE9BQU87SUFDWjtJQUNBLE1BQU11QyxvQkFBb0I7UUFDeEIsR0FBR0QsY0FBY3hELFFBQVE7UUFDekJyQixJQUFJbkI7SUFDTjtJQUNBLE9BQU9qSCxrRUFBaUJBLENBQUN1SixXQUFXOUUsVUFBVTtRQUM1QyxHQUFHd0ksYUFBYTtRQUNoQnhELFVBQVV5RDtJQUNaO0FBQ0Y7QUFFb0giLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9vcGVuLXByby1uZXh0Ly4vbm9kZV9tb2R1bGVzL0BmbG9hdGluZy11aS9kb20vZGlzdC9mbG9hdGluZy11aS5kb20ubWpzPzNmYTIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgcmVjdFRvQ2xpZW50UmVjdCwgYXV0b1BsYWNlbWVudCBhcyBhdXRvUGxhY2VtZW50JDEsIHNoaWZ0IGFzIHNoaWZ0JDEsIGZsaXAgYXMgZmxpcCQxLCBzaXplIGFzIHNpemUkMSwgaGlkZSBhcyBoaWRlJDEsIGFycm93IGFzIGFycm93JDEsIGlubGluZSBhcyBpbmxpbmUkMSwgbGltaXRTaGlmdCBhcyBsaW1pdFNoaWZ0JDEsIGNvbXB1dGVQb3NpdGlvbiBhcyBjb21wdXRlUG9zaXRpb24kMSB9IGZyb20gJ0BmbG9hdGluZy11aS9jb3JlJztcbmV4cG9ydCB7IGRldGVjdE92ZXJmbG93LCBvZmZzZXQgfSBmcm9tICdAZmxvYXRpbmctdWkvY29yZSc7XG5pbXBvcnQgeyByb3VuZCwgY3JlYXRlQ29vcmRzLCBtYXgsIG1pbiwgZmxvb3IgfSBmcm9tICdAZmxvYXRpbmctdWkvdXRpbHMnO1xuaW1wb3J0IHsgZ2V0Q29tcHV0ZWRTdHlsZSwgaXNIVE1MRWxlbWVudCwgaXNFbGVtZW50LCBnZXRXaW5kb3csIGlzV2ViS2l0LCBnZXREb2N1bWVudEVsZW1lbnQsIGdldE5vZGVOYW1lLCBpc092ZXJmbG93RWxlbWVudCwgZ2V0Tm9kZVNjcm9sbCwgZ2V0T3ZlcmZsb3dBbmNlc3RvcnMsIGdldFBhcmVudE5vZGUsIGlzTGFzdFRyYXZlcnNhYmxlTm9kZSwgaXNDb250YWluaW5nQmxvY2ssIGlzVGFibGVFbGVtZW50LCBnZXRDb250YWluaW5nQmxvY2sgfSBmcm9tICdAZmxvYXRpbmctdWkvdXRpbHMvZG9tJztcbmV4cG9ydCB7IGdldE92ZXJmbG93QW5jZXN0b3JzIH0gZnJvbSAnQGZsb2F0aW5nLXVpL3V0aWxzL2RvbSc7XG5cbmZ1bmN0aW9uIGdldENzc0RpbWVuc2lvbnMoZWxlbWVudCkge1xuICBjb25zdCBjc3MgPSBnZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpO1xuICAvLyBJbiB0ZXN0aW5nIGVudmlyb25tZW50cywgdGhlIGB3aWR0aGAgYW5kIGBoZWlnaHRgIHByb3BlcnRpZXMgYXJlIGVtcHR5XG4gIC8vIHN0cmluZ3MgZm9yIFNWRyBlbGVtZW50cywgcmV0dXJuaW5nIE5hTi4gRmFsbGJhY2sgdG8gYDBgIGluIHRoaXMgY2FzZS5cbiAgbGV0IHdpZHRoID0gcGFyc2VGbG9hdChjc3Mud2lkdGgpIHx8IDA7XG4gIGxldCBoZWlnaHQgPSBwYXJzZUZsb2F0KGNzcy5oZWlnaHQpIHx8IDA7XG4gIGNvbnN0IGhhc09mZnNldCA9IGlzSFRNTEVsZW1lbnQoZWxlbWVudCk7XG4gIGNvbnN0IG9mZnNldFdpZHRoID0gaGFzT2Zmc2V0ID8gZWxlbWVudC5vZmZzZXRXaWR0aCA6IHdpZHRoO1xuICBjb25zdCBvZmZzZXRIZWlnaHQgPSBoYXNPZmZzZXQgPyBlbGVtZW50Lm9mZnNldEhlaWdodCA6IGhlaWdodDtcbiAgY29uc3Qgc2hvdWxkRmFsbGJhY2sgPSByb3VuZCh3aWR0aCkgIT09IG9mZnNldFdpZHRoIHx8IHJvdW5kKGhlaWdodCkgIT09IG9mZnNldEhlaWdodDtcbiAgaWYgKHNob3VsZEZhbGxiYWNrKSB7XG4gICAgd2lkdGggPSBvZmZzZXRXaWR0aDtcbiAgICBoZWlnaHQgPSBvZmZzZXRIZWlnaHQ7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB3aWR0aCxcbiAgICBoZWlnaHQsXG4gICAgJDogc2hvdWxkRmFsbGJhY2tcbiAgfTtcbn1cblxuZnVuY3Rpb24gdW53cmFwRWxlbWVudChlbGVtZW50KSB7XG4gIHJldHVybiAhaXNFbGVtZW50KGVsZW1lbnQpID8gZWxlbWVudC5jb250ZXh0RWxlbWVudCA6IGVsZW1lbnQ7XG59XG5cbmZ1bmN0aW9uIGdldFNjYWxlKGVsZW1lbnQpIHtcbiAgY29uc3QgZG9tRWxlbWVudCA9IHVud3JhcEVsZW1lbnQoZWxlbWVudCk7XG4gIGlmICghaXNIVE1MRWxlbWVudChkb21FbGVtZW50KSkge1xuICAgIHJldHVybiBjcmVhdGVDb29yZHMoMSk7XG4gIH1cbiAgY29uc3QgcmVjdCA9IGRvbUVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gIGNvbnN0IHtcbiAgICB3aWR0aCxcbiAgICBoZWlnaHQsXG4gICAgJFxuICB9ID0gZ2V0Q3NzRGltZW5zaW9ucyhkb21FbGVtZW50KTtcbiAgbGV0IHggPSAoJCA/IHJvdW5kKHJlY3Qud2lkdGgpIDogcmVjdC53aWR0aCkgLyB3aWR0aDtcbiAgbGV0IHkgPSAoJCA/IHJvdW5kKHJlY3QuaGVpZ2h0KSA6IHJlY3QuaGVpZ2h0KSAvIGhlaWdodDtcblxuICAvLyAwLCBOYU4sIG9yIEluZmluaXR5IHNob3VsZCBhbHdheXMgZmFsbGJhY2sgdG8gMS5cblxuICBpZiAoIXggfHwgIU51bWJlci5pc0Zpbml0ZSh4KSkge1xuICAgIHggPSAxO1xuICB9XG4gIGlmICgheSB8fCAhTnVtYmVyLmlzRmluaXRlKHkpKSB7XG4gICAgeSA9IDE7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB4LFxuICAgIHlcbiAgfTtcbn1cblxuY29uc3Qgbm9PZmZzZXRzID0gLyojX19QVVJFX18qL2NyZWF0ZUNvb3JkcygwKTtcbmZ1bmN0aW9uIGdldFZpc3VhbE9mZnNldHMoZWxlbWVudCkge1xuICBjb25zdCB3aW4gPSBnZXRXaW5kb3coZWxlbWVudCk7XG4gIGlmICghaXNXZWJLaXQoKSB8fCAhd2luLnZpc3VhbFZpZXdwb3J0KSB7XG4gICAgcmV0dXJuIG5vT2Zmc2V0cztcbiAgfVxuICByZXR1cm4ge1xuICAgIHg6IHdpbi52aXN1YWxWaWV3cG9ydC5vZmZzZXRMZWZ0LFxuICAgIHk6IHdpbi52aXN1YWxWaWV3cG9ydC5vZmZzZXRUb3BcbiAgfTtcbn1cbmZ1bmN0aW9uIHNob3VsZEFkZFZpc3VhbE9mZnNldHMoZWxlbWVudCwgaXNGaXhlZCwgZmxvYXRpbmdPZmZzZXRQYXJlbnQpIHtcbiAgaWYgKGlzRml4ZWQgPT09IHZvaWQgMCkge1xuICAgIGlzRml4ZWQgPSBmYWxzZTtcbiAgfVxuICBpZiAoIWZsb2F0aW5nT2Zmc2V0UGFyZW50IHx8IGlzRml4ZWQgJiYgZmxvYXRpbmdPZmZzZXRQYXJlbnQgIT09IGdldFdpbmRvdyhlbGVtZW50KSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gaXNGaXhlZDtcbn1cblxuZnVuY3Rpb24gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KGVsZW1lbnQsIGluY2x1ZGVTY2FsZSwgaXNGaXhlZFN0cmF0ZWd5LCBvZmZzZXRQYXJlbnQpIHtcbiAgaWYgKGluY2x1ZGVTY2FsZSA9PT0gdm9pZCAwKSB7XG4gICAgaW5jbHVkZVNjYWxlID0gZmFsc2U7XG4gIH1cbiAgaWYgKGlzRml4ZWRTdHJhdGVneSA9PT0gdm9pZCAwKSB7XG4gICAgaXNGaXhlZFN0cmF0ZWd5ID0gZmFsc2U7XG4gIH1cbiAgY29uc3QgY2xpZW50UmVjdCA9IGVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gIGNvbnN0IGRvbUVsZW1lbnQgPSB1bndyYXBFbGVtZW50KGVsZW1lbnQpO1xuICBsZXQgc2NhbGUgPSBjcmVhdGVDb29yZHMoMSk7XG4gIGlmIChpbmNsdWRlU2NhbGUpIHtcbiAgICBpZiAob2Zmc2V0UGFyZW50KSB7XG4gICAgICBpZiAoaXNFbGVtZW50KG9mZnNldFBhcmVudCkpIHtcbiAgICAgICAgc2NhbGUgPSBnZXRTY2FsZShvZmZzZXRQYXJlbnQpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzY2FsZSA9IGdldFNjYWxlKGVsZW1lbnQpO1xuICAgIH1cbiAgfVxuICBjb25zdCB2aXN1YWxPZmZzZXRzID0gc2hvdWxkQWRkVmlzdWFsT2Zmc2V0cyhkb21FbGVtZW50LCBpc0ZpeGVkU3RyYXRlZ3ksIG9mZnNldFBhcmVudCkgPyBnZXRWaXN1YWxPZmZzZXRzKGRvbUVsZW1lbnQpIDogY3JlYXRlQ29vcmRzKDApO1xuICBsZXQgeCA9IChjbGllbnRSZWN0LmxlZnQgKyB2aXN1YWxPZmZzZXRzLngpIC8gc2NhbGUueDtcbiAgbGV0IHkgPSAoY2xpZW50UmVjdC50b3AgKyB2aXN1YWxPZmZzZXRzLnkpIC8gc2NhbGUueTtcbiAgbGV0IHdpZHRoID0gY2xpZW50UmVjdC53aWR0aCAvIHNjYWxlLng7XG4gIGxldCBoZWlnaHQgPSBjbGllbnRSZWN0LmhlaWdodCAvIHNjYWxlLnk7XG4gIGlmIChkb21FbGVtZW50KSB7XG4gICAgY29uc3Qgd2luID0gZ2V0V2luZG93KGRvbUVsZW1lbnQpO1xuICAgIGNvbnN0IG9mZnNldFdpbiA9IG9mZnNldFBhcmVudCAmJiBpc0VsZW1lbnQob2Zmc2V0UGFyZW50KSA/IGdldFdpbmRvdyhvZmZzZXRQYXJlbnQpIDogb2Zmc2V0UGFyZW50O1xuICAgIGxldCBjdXJyZW50V2luID0gd2luO1xuICAgIGxldCBjdXJyZW50SUZyYW1lID0gY3VycmVudFdpbi5mcmFtZUVsZW1lbnQ7XG4gICAgd2hpbGUgKGN1cnJlbnRJRnJhbWUgJiYgb2Zmc2V0UGFyZW50ICYmIG9mZnNldFdpbiAhPT0gY3VycmVudFdpbikge1xuICAgICAgY29uc3QgaWZyYW1lU2NhbGUgPSBnZXRTY2FsZShjdXJyZW50SUZyYW1lKTtcbiAgICAgIGNvbnN0IGlmcmFtZVJlY3QgPSBjdXJyZW50SUZyYW1lLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgY29uc3QgY3NzID0gZ2V0Q29tcHV0ZWRTdHlsZShjdXJyZW50SUZyYW1lKTtcbiAgICAgIGNvbnN0IGxlZnQgPSBpZnJhbWVSZWN0LmxlZnQgKyAoY3VycmVudElGcmFtZS5jbGllbnRMZWZ0ICsgcGFyc2VGbG9hdChjc3MucGFkZGluZ0xlZnQpKSAqIGlmcmFtZVNjYWxlLng7XG4gICAgICBjb25zdCB0b3AgPSBpZnJhbWVSZWN0LnRvcCArIChjdXJyZW50SUZyYW1lLmNsaWVudFRvcCArIHBhcnNlRmxvYXQoY3NzLnBhZGRpbmdUb3ApKSAqIGlmcmFtZVNjYWxlLnk7XG4gICAgICB4ICo9IGlmcmFtZVNjYWxlLng7XG4gICAgICB5ICo9IGlmcmFtZVNjYWxlLnk7XG4gICAgICB3aWR0aCAqPSBpZnJhbWVTY2FsZS54O1xuICAgICAgaGVpZ2h0ICo9IGlmcmFtZVNjYWxlLnk7XG4gICAgICB4ICs9IGxlZnQ7XG4gICAgICB5ICs9IHRvcDtcbiAgICAgIGN1cnJlbnRXaW4gPSBnZXRXaW5kb3coY3VycmVudElGcmFtZSk7XG4gICAgICBjdXJyZW50SUZyYW1lID0gY3VycmVudFdpbi5mcmFtZUVsZW1lbnQ7XG4gICAgfVxuICB9XG4gIHJldHVybiByZWN0VG9DbGllbnRSZWN0KHtcbiAgICB3aWR0aCxcbiAgICBoZWlnaHQsXG4gICAgeCxcbiAgICB5XG4gIH0pO1xufVxuXG5jb25zdCB0b3BMYXllclNlbGVjdG9ycyA9IFsnOnBvcG92ZXItb3BlbicsICc6bW9kYWwnXTtcbmZ1bmN0aW9uIGlzVG9wTGF5ZXIoZmxvYXRpbmcpIHtcbiAgcmV0dXJuIHRvcExheWVyU2VsZWN0b3JzLnNvbWUoc2VsZWN0b3IgPT4ge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gZmxvYXRpbmcubWF0Y2hlcyhzZWxlY3Rvcik7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGNvbnZlcnRPZmZzZXRQYXJlbnRSZWxhdGl2ZVJlY3RUb1ZpZXdwb3J0UmVsYXRpdmVSZWN0KF9yZWYpIHtcbiAgbGV0IHtcbiAgICBlbGVtZW50cyxcbiAgICByZWN0LFxuICAgIG9mZnNldFBhcmVudCxcbiAgICBzdHJhdGVneVxuICB9ID0gX3JlZjtcbiAgY29uc3QgaXNGaXhlZCA9IHN0cmF0ZWd5ID09PSAnZml4ZWQnO1xuICBjb25zdCBkb2N1bWVudEVsZW1lbnQgPSBnZXREb2N1bWVudEVsZW1lbnQob2Zmc2V0UGFyZW50KTtcbiAgY29uc3QgdG9wTGF5ZXIgPSBlbGVtZW50cyA/IGlzVG9wTGF5ZXIoZWxlbWVudHMuZmxvYXRpbmcpIDogZmFsc2U7XG4gIGlmIChvZmZzZXRQYXJlbnQgPT09IGRvY3VtZW50RWxlbWVudCB8fCB0b3BMYXllciAmJiBpc0ZpeGVkKSB7XG4gICAgcmV0dXJuIHJlY3Q7XG4gIH1cbiAgbGV0IHNjcm9sbCA9IHtcbiAgICBzY3JvbGxMZWZ0OiAwLFxuICAgIHNjcm9sbFRvcDogMFxuICB9O1xuICBsZXQgc2NhbGUgPSBjcmVhdGVDb29yZHMoMSk7XG4gIGNvbnN0IG9mZnNldHMgPSBjcmVhdGVDb29yZHMoMCk7XG4gIGNvbnN0IGlzT2Zmc2V0UGFyZW50QW5FbGVtZW50ID0gaXNIVE1MRWxlbWVudChvZmZzZXRQYXJlbnQpO1xuICBpZiAoaXNPZmZzZXRQYXJlbnRBbkVsZW1lbnQgfHwgIWlzT2Zmc2V0UGFyZW50QW5FbGVtZW50ICYmICFpc0ZpeGVkKSB7XG4gICAgaWYgKGdldE5vZGVOYW1lKG9mZnNldFBhcmVudCkgIT09ICdib2R5JyB8fCBpc092ZXJmbG93RWxlbWVudChkb2N1bWVudEVsZW1lbnQpKSB7XG4gICAgICBzY3JvbGwgPSBnZXROb2RlU2Nyb2xsKG9mZnNldFBhcmVudCk7XG4gICAgfVxuICAgIGlmIChpc0hUTUxFbGVtZW50KG9mZnNldFBhcmVudCkpIHtcbiAgICAgIGNvbnN0IG9mZnNldFJlY3QgPSBnZXRCb3VuZGluZ0NsaWVudFJlY3Qob2Zmc2V0UGFyZW50KTtcbiAgICAgIHNjYWxlID0gZ2V0U2NhbGUob2Zmc2V0UGFyZW50KTtcbiAgICAgIG9mZnNldHMueCA9IG9mZnNldFJlY3QueCArIG9mZnNldFBhcmVudC5jbGllbnRMZWZ0O1xuICAgICAgb2Zmc2V0cy55ID0gb2Zmc2V0UmVjdC55ICsgb2Zmc2V0UGFyZW50LmNsaWVudFRvcDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB3aWR0aDogcmVjdC53aWR0aCAqIHNjYWxlLngsXG4gICAgaGVpZ2h0OiByZWN0LmhlaWdodCAqIHNjYWxlLnksXG4gICAgeDogcmVjdC54ICogc2NhbGUueCAtIHNjcm9sbC5zY3JvbGxMZWZ0ICogc2NhbGUueCArIG9mZnNldHMueCxcbiAgICB5OiByZWN0LnkgKiBzY2FsZS55IC0gc2Nyb2xsLnNjcm9sbFRvcCAqIHNjYWxlLnkgKyBvZmZzZXRzLnlcbiAgfTtcbn1cblxuZnVuY3Rpb24gZ2V0Q2xpZW50UmVjdHMoZWxlbWVudCkge1xuICByZXR1cm4gQXJyYXkuZnJvbShlbGVtZW50LmdldENsaWVudFJlY3RzKCkpO1xufVxuXG5mdW5jdGlvbiBnZXRXaW5kb3dTY3JvbGxCYXJYKGVsZW1lbnQpIHtcbiAgLy8gSWYgPGh0bWw+IGhhcyBhIENTUyB3aWR0aCBncmVhdGVyIHRoYW4gdGhlIHZpZXdwb3J0LCB0aGVuIHRoaXMgd2lsbCBiZVxuICAvLyBpbmNvcnJlY3QgZm9yIFJUTC5cbiAgcmV0dXJuIGdldEJvdW5kaW5nQ2xpZW50UmVjdChnZXREb2N1bWVudEVsZW1lbnQoZWxlbWVudCkpLmxlZnQgKyBnZXROb2RlU2Nyb2xsKGVsZW1lbnQpLnNjcm9sbExlZnQ7XG59XG5cbi8vIEdldHMgdGhlIGVudGlyZSBzaXplIG9mIHRoZSBzY3JvbGxhYmxlIGRvY3VtZW50IGFyZWEsIGV2ZW4gZXh0ZW5kaW5nIG91dHNpZGVcbi8vIG9mIHRoZSBgPGh0bWw+YCBhbmQgYDxib2R5PmAgcmVjdCBib3VuZHMgaWYgaG9yaXpvbnRhbGx5IHNjcm9sbGFibGUuXG5mdW5jdGlvbiBnZXREb2N1bWVudFJlY3QoZWxlbWVudCkge1xuICBjb25zdCBodG1sID0gZ2V0RG9jdW1lbnRFbGVtZW50KGVsZW1lbnQpO1xuICBjb25zdCBzY3JvbGwgPSBnZXROb2RlU2Nyb2xsKGVsZW1lbnQpO1xuICBjb25zdCBib2R5ID0gZWxlbWVudC5vd25lckRvY3VtZW50LmJvZHk7XG4gIGNvbnN0IHdpZHRoID0gbWF4KGh0bWwuc2Nyb2xsV2lkdGgsIGh0bWwuY2xpZW50V2lkdGgsIGJvZHkuc2Nyb2xsV2lkdGgsIGJvZHkuY2xpZW50V2lkdGgpO1xuICBjb25zdCBoZWlnaHQgPSBtYXgoaHRtbC5zY3JvbGxIZWlnaHQsIGh0bWwuY2xpZW50SGVpZ2h0LCBib2R5LnNjcm9sbEhlaWdodCwgYm9keS5jbGllbnRIZWlnaHQpO1xuICBsZXQgeCA9IC1zY3JvbGwuc2Nyb2xsTGVmdCArIGdldFdpbmRvd1Njcm9sbEJhclgoZWxlbWVudCk7XG4gIGNvbnN0IHkgPSAtc2Nyb2xsLnNjcm9sbFRvcDtcbiAgaWYgKGdldENvbXB1dGVkU3R5bGUoYm9keSkuZGlyZWN0aW9uID09PSAncnRsJykge1xuICAgIHggKz0gbWF4KGh0bWwuY2xpZW50V2lkdGgsIGJvZHkuY2xpZW50V2lkdGgpIC0gd2lkdGg7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB3aWR0aCxcbiAgICBoZWlnaHQsXG4gICAgeCxcbiAgICB5XG4gIH07XG59XG5cbmZ1bmN0aW9uIGdldFZpZXdwb3J0UmVjdChlbGVtZW50LCBzdHJhdGVneSkge1xuICBjb25zdCB3aW4gPSBnZXRXaW5kb3coZWxlbWVudCk7XG4gIGNvbnN0IGh0bWwgPSBnZXREb2N1bWVudEVsZW1lbnQoZWxlbWVudCk7XG4gIGNvbnN0IHZpc3VhbFZpZXdwb3J0ID0gd2luLnZpc3VhbFZpZXdwb3J0O1xuICBsZXQgd2lkdGggPSBodG1sLmNsaWVudFdpZHRoO1xuICBsZXQgaGVpZ2h0ID0gaHRtbC5jbGllbnRIZWlnaHQ7XG4gIGxldCB4ID0gMDtcbiAgbGV0IHkgPSAwO1xuICBpZiAodmlzdWFsVmlld3BvcnQpIHtcbiAgICB3aWR0aCA9IHZpc3VhbFZpZXdwb3J0LndpZHRoO1xuICAgIGhlaWdodCA9IHZpc3VhbFZpZXdwb3J0LmhlaWdodDtcbiAgICBjb25zdCB2aXN1YWxWaWV3cG9ydEJhc2VkID0gaXNXZWJLaXQoKTtcbiAgICBpZiAoIXZpc3VhbFZpZXdwb3J0QmFzZWQgfHwgdmlzdWFsVmlld3BvcnRCYXNlZCAmJiBzdHJhdGVneSA9PT0gJ2ZpeGVkJykge1xuICAgICAgeCA9IHZpc3VhbFZpZXdwb3J0Lm9mZnNldExlZnQ7XG4gICAgICB5ID0gdmlzdWFsVmlld3BvcnQub2Zmc2V0VG9wO1xuICAgIH1cbiAgfVxuICByZXR1cm4ge1xuICAgIHdpZHRoLFxuICAgIGhlaWdodCxcbiAgICB4LFxuICAgIHlcbiAgfTtcbn1cblxuLy8gUmV0dXJucyB0aGUgaW5uZXIgY2xpZW50IHJlY3QsIHN1YnRyYWN0aW5nIHNjcm9sbGJhcnMgaWYgcHJlc2VudC5cbmZ1bmN0aW9uIGdldElubmVyQm91bmRpbmdDbGllbnRSZWN0KGVsZW1lbnQsIHN0cmF0ZWd5KSB7XG4gIGNvbnN0IGNsaWVudFJlY3QgPSBnZXRCb3VuZGluZ0NsaWVudFJlY3QoZWxlbWVudCwgdHJ1ZSwgc3RyYXRlZ3kgPT09ICdmaXhlZCcpO1xuICBjb25zdCB0b3AgPSBjbGllbnRSZWN0LnRvcCArIGVsZW1lbnQuY2xpZW50VG9wO1xuICBjb25zdCBsZWZ0ID0gY2xpZW50UmVjdC5sZWZ0ICsgZWxlbWVudC5jbGllbnRMZWZ0O1xuICBjb25zdCBzY2FsZSA9IGlzSFRNTEVsZW1lbnQoZWxlbWVudCkgPyBnZXRTY2FsZShlbGVtZW50KSA6IGNyZWF0ZUNvb3JkcygxKTtcbiAgY29uc3Qgd2lkdGggPSBlbGVtZW50LmNsaWVudFdpZHRoICogc2NhbGUueDtcbiAgY29uc3QgaGVpZ2h0ID0gZWxlbWVudC5jbGllbnRIZWlnaHQgKiBzY2FsZS55O1xuICBjb25zdCB4ID0gbGVmdCAqIHNjYWxlLng7XG4gIGNvbnN0IHkgPSB0b3AgKiBzY2FsZS55O1xuICByZXR1cm4ge1xuICAgIHdpZHRoLFxuICAgIGhlaWdodCxcbiAgICB4LFxuICAgIHlcbiAgfTtcbn1cbmZ1bmN0aW9uIGdldENsaWVudFJlY3RGcm9tQ2xpcHBpbmdBbmNlc3RvcihlbGVtZW50LCBjbGlwcGluZ0FuY2VzdG9yLCBzdHJhdGVneSkge1xuICBsZXQgcmVjdDtcbiAgaWYgKGNsaXBwaW5nQW5jZXN0b3IgPT09ICd2aWV3cG9ydCcpIHtcbiAgICByZWN0ID0gZ2V0Vmlld3BvcnRSZWN0KGVsZW1lbnQsIHN0cmF0ZWd5KTtcbiAgfSBlbHNlIGlmIChjbGlwcGluZ0FuY2VzdG9yID09PSAnZG9jdW1lbnQnKSB7XG4gICAgcmVjdCA9IGdldERvY3VtZW50UmVjdChnZXREb2N1bWVudEVsZW1lbnQoZWxlbWVudCkpO1xuICB9IGVsc2UgaWYgKGlzRWxlbWVudChjbGlwcGluZ0FuY2VzdG9yKSkge1xuICAgIHJlY3QgPSBnZXRJbm5lckJvdW5kaW5nQ2xpZW50UmVjdChjbGlwcGluZ0FuY2VzdG9yLCBzdHJhdGVneSk7XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgdmlzdWFsT2Zmc2V0cyA9IGdldFZpc3VhbE9mZnNldHMoZWxlbWVudCk7XG4gICAgcmVjdCA9IHtcbiAgICAgIC4uLmNsaXBwaW5nQW5jZXN0b3IsXG4gICAgICB4OiBjbGlwcGluZ0FuY2VzdG9yLnggLSB2aXN1YWxPZmZzZXRzLngsXG4gICAgICB5OiBjbGlwcGluZ0FuY2VzdG9yLnkgLSB2aXN1YWxPZmZzZXRzLnlcbiAgICB9O1xuICB9XG4gIHJldHVybiByZWN0VG9DbGllbnRSZWN0KHJlY3QpO1xufVxuZnVuY3Rpb24gaGFzRml4ZWRQb3NpdGlvbkFuY2VzdG9yKGVsZW1lbnQsIHN0b3BOb2RlKSB7XG4gIGNvbnN0IHBhcmVudE5vZGUgPSBnZXRQYXJlbnROb2RlKGVsZW1lbnQpO1xuICBpZiAocGFyZW50Tm9kZSA9PT0gc3RvcE5vZGUgfHwgIWlzRWxlbWVudChwYXJlbnROb2RlKSB8fCBpc0xhc3RUcmF2ZXJzYWJsZU5vZGUocGFyZW50Tm9kZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIGdldENvbXB1dGVkU3R5bGUocGFyZW50Tm9kZSkucG9zaXRpb24gPT09ICdmaXhlZCcgfHwgaGFzRml4ZWRQb3NpdGlvbkFuY2VzdG9yKHBhcmVudE5vZGUsIHN0b3BOb2RlKTtcbn1cblxuLy8gQSBcImNsaXBwaW5nIGFuY2VzdG9yXCIgaXMgYW4gYG92ZXJmbG93YCBlbGVtZW50IHdpdGggdGhlIGNoYXJhY3RlcmlzdGljIG9mXG4vLyBjbGlwcGluZyAob3IgaGlkaW5nKSBjaGlsZCBlbGVtZW50cy4gVGhpcyByZXR1cm5zIGFsbCBjbGlwcGluZyBhbmNlc3RvcnNcbi8vIG9mIHRoZSBnaXZlbiBlbGVtZW50IHVwIHRoZSB0cmVlLlxuZnVuY3Rpb24gZ2V0Q2xpcHBpbmdFbGVtZW50QW5jZXN0b3JzKGVsZW1lbnQsIGNhY2hlKSB7XG4gIGNvbnN0IGNhY2hlZFJlc3VsdCA9IGNhY2hlLmdldChlbGVtZW50KTtcbiAgaWYgKGNhY2hlZFJlc3VsdCkge1xuICAgIHJldHVybiBjYWNoZWRSZXN1bHQ7XG4gIH1cbiAgbGV0IHJlc3VsdCA9IGdldE92ZXJmbG93QW5jZXN0b3JzKGVsZW1lbnQsIFtdLCBmYWxzZSkuZmlsdGVyKGVsID0+IGlzRWxlbWVudChlbCkgJiYgZ2V0Tm9kZU5hbWUoZWwpICE9PSAnYm9keScpO1xuICBsZXQgY3VycmVudENvbnRhaW5pbmdCbG9ja0NvbXB1dGVkU3R5bGUgPSBudWxsO1xuICBjb25zdCBlbGVtZW50SXNGaXhlZCA9IGdldENvbXB1dGVkU3R5bGUoZWxlbWVudCkucG9zaXRpb24gPT09ICdmaXhlZCc7XG4gIGxldCBjdXJyZW50Tm9kZSA9IGVsZW1lbnRJc0ZpeGVkID8gZ2V0UGFyZW50Tm9kZShlbGVtZW50KSA6IGVsZW1lbnQ7XG5cbiAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQ1NTL0NvbnRhaW5pbmdfYmxvY2sjaWRlbnRpZnlpbmdfdGhlX2NvbnRhaW5pbmdfYmxvY2tcbiAgd2hpbGUgKGlzRWxlbWVudChjdXJyZW50Tm9kZSkgJiYgIWlzTGFzdFRyYXZlcnNhYmxlTm9kZShjdXJyZW50Tm9kZSkpIHtcbiAgICBjb25zdCBjb21wdXRlZFN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZShjdXJyZW50Tm9kZSk7XG4gICAgY29uc3QgY3VycmVudE5vZGVJc0NvbnRhaW5pbmcgPSBpc0NvbnRhaW5pbmdCbG9jayhjdXJyZW50Tm9kZSk7XG4gICAgaWYgKCFjdXJyZW50Tm9kZUlzQ29udGFpbmluZyAmJiBjb21wdXRlZFN0eWxlLnBvc2l0aW9uID09PSAnZml4ZWQnKSB7XG4gICAgICBjdXJyZW50Q29udGFpbmluZ0Jsb2NrQ29tcHV0ZWRTdHlsZSA9IG51bGw7XG4gICAgfVxuICAgIGNvbnN0IHNob3VsZERyb3BDdXJyZW50Tm9kZSA9IGVsZW1lbnRJc0ZpeGVkID8gIWN1cnJlbnROb2RlSXNDb250YWluaW5nICYmICFjdXJyZW50Q29udGFpbmluZ0Jsb2NrQ29tcHV0ZWRTdHlsZSA6ICFjdXJyZW50Tm9kZUlzQ29udGFpbmluZyAmJiBjb21wdXRlZFN0eWxlLnBvc2l0aW9uID09PSAnc3RhdGljJyAmJiAhIWN1cnJlbnRDb250YWluaW5nQmxvY2tDb21wdXRlZFN0eWxlICYmIFsnYWJzb2x1dGUnLCAnZml4ZWQnXS5pbmNsdWRlcyhjdXJyZW50Q29udGFpbmluZ0Jsb2NrQ29tcHV0ZWRTdHlsZS5wb3NpdGlvbikgfHwgaXNPdmVyZmxvd0VsZW1lbnQoY3VycmVudE5vZGUpICYmICFjdXJyZW50Tm9kZUlzQ29udGFpbmluZyAmJiBoYXNGaXhlZFBvc2l0aW9uQW5jZXN0b3IoZWxlbWVudCwgY3VycmVudE5vZGUpO1xuICAgIGlmIChzaG91bGREcm9wQ3VycmVudE5vZGUpIHtcbiAgICAgIC8vIERyb3Agbm9uLWNvbnRhaW5pbmcgYmxvY2tzLlxuICAgICAgcmVzdWx0ID0gcmVzdWx0LmZpbHRlcihhbmNlc3RvciA9PiBhbmNlc3RvciAhPT0gY3VycmVudE5vZGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBSZWNvcmQgbGFzdCBjb250YWluaW5nIGJsb2NrIGZvciBuZXh0IGl0ZXJhdGlvbi5cbiAgICAgIGN1cnJlbnRDb250YWluaW5nQmxvY2tDb21wdXRlZFN0eWxlID0gY29tcHV0ZWRTdHlsZTtcbiAgICB9XG4gICAgY3VycmVudE5vZGUgPSBnZXRQYXJlbnROb2RlKGN1cnJlbnROb2RlKTtcbiAgfVxuICBjYWNoZS5zZXQoZWxlbWVudCwgcmVzdWx0KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLy8gR2V0cyB0aGUgbWF4aW11bSBhcmVhIHRoYXQgdGhlIGVsZW1lbnQgaXMgdmlzaWJsZSBpbiBkdWUgdG8gYW55IG51bWJlciBvZlxuLy8gY2xpcHBpbmcgYW5jZXN0b3JzLlxuZnVuY3Rpb24gZ2V0Q2xpcHBpbmdSZWN0KF9yZWYpIHtcbiAgbGV0IHtcbiAgICBlbGVtZW50LFxuICAgIGJvdW5kYXJ5LFxuICAgIHJvb3RCb3VuZGFyeSxcbiAgICBzdHJhdGVneVxuICB9ID0gX3JlZjtcbiAgY29uc3QgZWxlbWVudENsaXBwaW5nQW5jZXN0b3JzID0gYm91bmRhcnkgPT09ICdjbGlwcGluZ0FuY2VzdG9ycycgPyBnZXRDbGlwcGluZ0VsZW1lbnRBbmNlc3RvcnMoZWxlbWVudCwgdGhpcy5fYykgOiBbXS5jb25jYXQoYm91bmRhcnkpO1xuICBjb25zdCBjbGlwcGluZ0FuY2VzdG9ycyA9IFsuLi5lbGVtZW50Q2xpcHBpbmdBbmNlc3RvcnMsIHJvb3RCb3VuZGFyeV07XG4gIGNvbnN0IGZpcnN0Q2xpcHBpbmdBbmNlc3RvciA9IGNsaXBwaW5nQW5jZXN0b3JzWzBdO1xuICBjb25zdCBjbGlwcGluZ1JlY3QgPSBjbGlwcGluZ0FuY2VzdG9ycy5yZWR1Y2UoKGFjY1JlY3QsIGNsaXBwaW5nQW5jZXN0b3IpID0+IHtcbiAgICBjb25zdCByZWN0ID0gZ2V0Q2xpZW50UmVjdEZyb21DbGlwcGluZ0FuY2VzdG9yKGVsZW1lbnQsIGNsaXBwaW5nQW5jZXN0b3IsIHN0cmF0ZWd5KTtcbiAgICBhY2NSZWN0LnRvcCA9IG1heChyZWN0LnRvcCwgYWNjUmVjdC50b3ApO1xuICAgIGFjY1JlY3QucmlnaHQgPSBtaW4ocmVjdC5yaWdodCwgYWNjUmVjdC5yaWdodCk7XG4gICAgYWNjUmVjdC5ib3R0b20gPSBtaW4ocmVjdC5ib3R0b20sIGFjY1JlY3QuYm90dG9tKTtcbiAgICBhY2NSZWN0LmxlZnQgPSBtYXgocmVjdC5sZWZ0LCBhY2NSZWN0LmxlZnQpO1xuICAgIHJldHVybiBhY2NSZWN0O1xuICB9LCBnZXRDbGllbnRSZWN0RnJvbUNsaXBwaW5nQW5jZXN0b3IoZWxlbWVudCwgZmlyc3RDbGlwcGluZ0FuY2VzdG9yLCBzdHJhdGVneSkpO1xuICByZXR1cm4ge1xuICAgIHdpZHRoOiBjbGlwcGluZ1JlY3QucmlnaHQgLSBjbGlwcGluZ1JlY3QubGVmdCxcbiAgICBoZWlnaHQ6IGNsaXBwaW5nUmVjdC5ib3R0b20gLSBjbGlwcGluZ1JlY3QudG9wLFxuICAgIHg6IGNsaXBwaW5nUmVjdC5sZWZ0LFxuICAgIHk6IGNsaXBwaW5nUmVjdC50b3BcbiAgfTtcbn1cblxuZnVuY3Rpb24gZ2V0RGltZW5zaW9ucyhlbGVtZW50KSB7XG4gIGNvbnN0IHtcbiAgICB3aWR0aCxcbiAgICBoZWlnaHRcbiAgfSA9IGdldENzc0RpbWVuc2lvbnMoZWxlbWVudCk7XG4gIHJldHVybiB7XG4gICAgd2lkdGgsXG4gICAgaGVpZ2h0XG4gIH07XG59XG5cbmZ1bmN0aW9uIGdldFJlY3RSZWxhdGl2ZVRvT2Zmc2V0UGFyZW50KGVsZW1lbnQsIG9mZnNldFBhcmVudCwgc3RyYXRlZ3kpIHtcbiAgY29uc3QgaXNPZmZzZXRQYXJlbnRBbkVsZW1lbnQgPSBpc0hUTUxFbGVtZW50KG9mZnNldFBhcmVudCk7XG4gIGNvbnN0IGRvY3VtZW50RWxlbWVudCA9IGdldERvY3VtZW50RWxlbWVudChvZmZzZXRQYXJlbnQpO1xuICBjb25zdCBpc0ZpeGVkID0gc3RyYXRlZ3kgPT09ICdmaXhlZCc7XG4gIGNvbnN0IHJlY3QgPSBnZXRCb3VuZGluZ0NsaWVudFJlY3QoZWxlbWVudCwgdHJ1ZSwgaXNGaXhlZCwgb2Zmc2V0UGFyZW50KTtcbiAgbGV0IHNjcm9sbCA9IHtcbiAgICBzY3JvbGxMZWZ0OiAwLFxuICAgIHNjcm9sbFRvcDogMFxuICB9O1xuICBjb25zdCBvZmZzZXRzID0gY3JlYXRlQ29vcmRzKDApO1xuICBpZiAoaXNPZmZzZXRQYXJlbnRBbkVsZW1lbnQgfHwgIWlzT2Zmc2V0UGFyZW50QW5FbGVtZW50ICYmICFpc0ZpeGVkKSB7XG4gICAgaWYgKGdldE5vZGVOYW1lKG9mZnNldFBhcmVudCkgIT09ICdib2R5JyB8fCBpc092ZXJmbG93RWxlbWVudChkb2N1bWVudEVsZW1lbnQpKSB7XG4gICAgICBzY3JvbGwgPSBnZXROb2RlU2Nyb2xsKG9mZnNldFBhcmVudCk7XG4gICAgfVxuICAgIGlmIChpc09mZnNldFBhcmVudEFuRWxlbWVudCkge1xuICAgICAgY29uc3Qgb2Zmc2V0UmVjdCA9IGdldEJvdW5kaW5nQ2xpZW50UmVjdChvZmZzZXRQYXJlbnQsIHRydWUsIGlzRml4ZWQsIG9mZnNldFBhcmVudCk7XG4gICAgICBvZmZzZXRzLnggPSBvZmZzZXRSZWN0LnggKyBvZmZzZXRQYXJlbnQuY2xpZW50TGVmdDtcbiAgICAgIG9mZnNldHMueSA9IG9mZnNldFJlY3QueSArIG9mZnNldFBhcmVudC5jbGllbnRUb3A7XG4gICAgfSBlbHNlIGlmIChkb2N1bWVudEVsZW1lbnQpIHtcbiAgICAgIG9mZnNldHMueCA9IGdldFdpbmRvd1Njcm9sbEJhclgoZG9jdW1lbnRFbGVtZW50KTtcbiAgICB9XG4gIH1cbiAgY29uc3QgeCA9IHJlY3QubGVmdCArIHNjcm9sbC5zY3JvbGxMZWZ0IC0gb2Zmc2V0cy54O1xuICBjb25zdCB5ID0gcmVjdC50b3AgKyBzY3JvbGwuc2Nyb2xsVG9wIC0gb2Zmc2V0cy55O1xuICByZXR1cm4ge1xuICAgIHgsXG4gICAgeSxcbiAgICB3aWR0aDogcmVjdC53aWR0aCxcbiAgICBoZWlnaHQ6IHJlY3QuaGVpZ2h0XG4gIH07XG59XG5cbmZ1bmN0aW9uIGdldFRydWVPZmZzZXRQYXJlbnQoZWxlbWVudCwgcG9seWZpbGwpIHtcbiAgaWYgKCFpc0hUTUxFbGVtZW50KGVsZW1lbnQpIHx8IGdldENvbXB1dGVkU3R5bGUoZWxlbWVudCkucG9zaXRpb24gPT09ICdmaXhlZCcpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBpZiAocG9seWZpbGwpIHtcbiAgICByZXR1cm4gcG9seWZpbGwoZWxlbWVudCk7XG4gIH1cbiAgcmV0dXJuIGVsZW1lbnQub2Zmc2V0UGFyZW50O1xufVxuXG4vLyBHZXRzIHRoZSBjbG9zZXN0IGFuY2VzdG9yIHBvc2l0aW9uZWQgZWxlbWVudC4gSGFuZGxlcyBzb21lIGVkZ2UgY2FzZXMsXG4vLyBzdWNoIGFzIHRhYmxlIGFuY2VzdG9ycyBhbmQgY3Jvc3MgYnJvd3NlciBidWdzLlxuZnVuY3Rpb24gZ2V0T2Zmc2V0UGFyZW50KGVsZW1lbnQsIHBvbHlmaWxsKSB7XG4gIGNvbnN0IHdpbmRvdyA9IGdldFdpbmRvdyhlbGVtZW50KTtcbiAgaWYgKCFpc0hUTUxFbGVtZW50KGVsZW1lbnQpIHx8IGlzVG9wTGF5ZXIoZWxlbWVudCkpIHtcbiAgICByZXR1cm4gd2luZG93O1xuICB9XG4gIGxldCBvZmZzZXRQYXJlbnQgPSBnZXRUcnVlT2Zmc2V0UGFyZW50KGVsZW1lbnQsIHBvbHlmaWxsKTtcbiAgd2hpbGUgKG9mZnNldFBhcmVudCAmJiBpc1RhYmxlRWxlbWVudChvZmZzZXRQYXJlbnQpICYmIGdldENvbXB1dGVkU3R5bGUob2Zmc2V0UGFyZW50KS5wb3NpdGlvbiA9PT0gJ3N0YXRpYycpIHtcbiAgICBvZmZzZXRQYXJlbnQgPSBnZXRUcnVlT2Zmc2V0UGFyZW50KG9mZnNldFBhcmVudCwgcG9seWZpbGwpO1xuICB9XG4gIGlmIChvZmZzZXRQYXJlbnQgJiYgKGdldE5vZGVOYW1lKG9mZnNldFBhcmVudCkgPT09ICdodG1sJyB8fCBnZXROb2RlTmFtZShvZmZzZXRQYXJlbnQpID09PSAnYm9keScgJiYgZ2V0Q29tcHV0ZWRTdHlsZShvZmZzZXRQYXJlbnQpLnBvc2l0aW9uID09PSAnc3RhdGljJyAmJiAhaXNDb250YWluaW5nQmxvY2sob2Zmc2V0UGFyZW50KSkpIHtcbiAgICByZXR1cm4gd2luZG93O1xuICB9XG4gIHJldHVybiBvZmZzZXRQYXJlbnQgfHwgZ2V0Q29udGFpbmluZ0Jsb2NrKGVsZW1lbnQpIHx8IHdpbmRvdztcbn1cblxuY29uc3QgZ2V0RWxlbWVudFJlY3RzID0gYXN5bmMgZnVuY3Rpb24gKGRhdGEpIHtcbiAgY29uc3QgZ2V0T2Zmc2V0UGFyZW50Rm4gPSB0aGlzLmdldE9mZnNldFBhcmVudCB8fCBnZXRPZmZzZXRQYXJlbnQ7XG4gIGNvbnN0IGdldERpbWVuc2lvbnNGbiA9IHRoaXMuZ2V0RGltZW5zaW9ucztcbiAgcmV0dXJuIHtcbiAgICByZWZlcmVuY2U6IGdldFJlY3RSZWxhdGl2ZVRvT2Zmc2V0UGFyZW50KGRhdGEucmVmZXJlbmNlLCBhd2FpdCBnZXRPZmZzZXRQYXJlbnRGbihkYXRhLmZsb2F0aW5nKSwgZGF0YS5zdHJhdGVneSksXG4gICAgZmxvYXRpbmc6IHtcbiAgICAgIHg6IDAsXG4gICAgICB5OiAwLFxuICAgICAgLi4uKGF3YWl0IGdldERpbWVuc2lvbnNGbihkYXRhLmZsb2F0aW5nKSlcbiAgICB9XG4gIH07XG59O1xuXG5mdW5jdGlvbiBpc1JUTChlbGVtZW50KSB7XG4gIHJldHVybiBnZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpLmRpcmVjdGlvbiA9PT0gJ3J0bCc7XG59XG5cbmNvbnN0IHBsYXRmb3JtID0ge1xuICBjb252ZXJ0T2Zmc2V0UGFyZW50UmVsYXRpdmVSZWN0VG9WaWV3cG9ydFJlbGF0aXZlUmVjdCxcbiAgZ2V0RG9jdW1lbnRFbGVtZW50LFxuICBnZXRDbGlwcGluZ1JlY3QsXG4gIGdldE9mZnNldFBhcmVudCxcbiAgZ2V0RWxlbWVudFJlY3RzLFxuICBnZXRDbGllbnRSZWN0cyxcbiAgZ2V0RGltZW5zaW9ucyxcbiAgZ2V0U2NhbGUsXG4gIGlzRWxlbWVudCxcbiAgaXNSVExcbn07XG5cbi8vIGh0dHBzOi8vc2FtdGhvci5hdS8yMDIxL29ic2VydmluZy1kb20vXG5mdW5jdGlvbiBvYnNlcnZlTW92ZShlbGVtZW50LCBvbk1vdmUpIHtcbiAgbGV0IGlvID0gbnVsbDtcbiAgbGV0IHRpbWVvdXRJZDtcbiAgY29uc3Qgcm9vdCA9IGdldERvY3VtZW50RWxlbWVudChlbGVtZW50KTtcbiAgZnVuY3Rpb24gY2xlYW51cCgpIHtcbiAgICB2YXIgX2lvO1xuICAgIGNsZWFyVGltZW91dCh0aW1lb3V0SWQpO1xuICAgIChfaW8gPSBpbykgPT0gbnVsbCB8fCBfaW8uZGlzY29ubmVjdCgpO1xuICAgIGlvID0gbnVsbDtcbiAgfVxuICBmdW5jdGlvbiByZWZyZXNoKHNraXAsIHRocmVzaG9sZCkge1xuICAgIGlmIChza2lwID09PSB2b2lkIDApIHtcbiAgICAgIHNraXAgPSBmYWxzZTtcbiAgICB9XG4gICAgaWYgKHRocmVzaG9sZCA9PT0gdm9pZCAwKSB7XG4gICAgICB0aHJlc2hvbGQgPSAxO1xuICAgIH1cbiAgICBjbGVhbnVwKCk7XG4gICAgY29uc3Qge1xuICAgICAgbGVmdCxcbiAgICAgIHRvcCxcbiAgICAgIHdpZHRoLFxuICAgICAgaGVpZ2h0XG4gICAgfSA9IGVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgaWYgKCFza2lwKSB7XG4gICAgICBvbk1vdmUoKTtcbiAgICB9XG4gICAgaWYgKCF3aWR0aCB8fCAhaGVpZ2h0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGluc2V0VG9wID0gZmxvb3IodG9wKTtcbiAgICBjb25zdCBpbnNldFJpZ2h0ID0gZmxvb3Iocm9vdC5jbGllbnRXaWR0aCAtIChsZWZ0ICsgd2lkdGgpKTtcbiAgICBjb25zdCBpbnNldEJvdHRvbSA9IGZsb29yKHJvb3QuY2xpZW50SGVpZ2h0IC0gKHRvcCArIGhlaWdodCkpO1xuICAgIGNvbnN0IGluc2V0TGVmdCA9IGZsb29yKGxlZnQpO1xuICAgIGNvbnN0IHJvb3RNYXJnaW4gPSAtaW5zZXRUb3AgKyBcInB4IFwiICsgLWluc2V0UmlnaHQgKyBcInB4IFwiICsgLWluc2V0Qm90dG9tICsgXCJweCBcIiArIC1pbnNldExlZnQgKyBcInB4XCI7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAgIHJvb3RNYXJnaW4sXG4gICAgICB0aHJlc2hvbGQ6IG1heCgwLCBtaW4oMSwgdGhyZXNob2xkKSkgfHwgMVxuICAgIH07XG4gICAgbGV0IGlzRmlyc3RVcGRhdGUgPSB0cnVlO1xuICAgIGZ1bmN0aW9uIGhhbmRsZU9ic2VydmUoZW50cmllcykge1xuICAgICAgY29uc3QgcmF0aW8gPSBlbnRyaWVzWzBdLmludGVyc2VjdGlvblJhdGlvO1xuICAgICAgaWYgKHJhdGlvICE9PSB0aHJlc2hvbGQpIHtcbiAgICAgICAgaWYgKCFpc0ZpcnN0VXBkYXRlKSB7XG4gICAgICAgICAgcmV0dXJuIHJlZnJlc2goKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXJhdGlvKSB7XG4gICAgICAgICAgdGltZW91dElkID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICByZWZyZXNoKGZhbHNlLCAxZS03KTtcbiAgICAgICAgICB9LCAxMDApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlZnJlc2goZmFsc2UsIHJhdGlvKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaXNGaXJzdFVwZGF0ZSA9IGZhbHNlO1xuICAgIH1cblxuICAgIC8vIE9sZGVyIGJyb3dzZXJzIGRvbid0IHN1cHBvcnQgYSBgZG9jdW1lbnRgIGFzIHRoZSByb290IGFuZCB3aWxsIHRocm93IGFuXG4gICAgLy8gZXJyb3IuXG4gICAgdHJ5IHtcbiAgICAgIGlvID0gbmV3IEludGVyc2VjdGlvbk9ic2VydmVyKGhhbmRsZU9ic2VydmUsIHtcbiAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgLy8gSGFuZGxlIDxpZnJhbWU+c1xuICAgICAgICByb290OiByb290Lm93bmVyRG9jdW1lbnRcbiAgICAgIH0pO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGlvID0gbmV3IEludGVyc2VjdGlvbk9ic2VydmVyKGhhbmRsZU9ic2VydmUsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBpby5vYnNlcnZlKGVsZW1lbnQpO1xuICB9XG4gIHJlZnJlc2godHJ1ZSk7XG4gIHJldHVybiBjbGVhbnVwO1xufVxuXG4vKipcbiAqIEF1dG9tYXRpY2FsbHkgdXBkYXRlcyB0aGUgcG9zaXRpb24gb2YgdGhlIGZsb2F0aW5nIGVsZW1lbnQgd2hlbiBuZWNlc3NhcnkuXG4gKiBTaG91bGQgb25seSBiZSBjYWxsZWQgd2hlbiB0aGUgZmxvYXRpbmcgZWxlbWVudCBpcyBtb3VudGVkIG9uIHRoZSBET00gb3JcbiAqIHZpc2libGUgb24gdGhlIHNjcmVlbi5cbiAqIEByZXR1cm5zIGNsZWFudXAgZnVuY3Rpb24gdGhhdCBzaG91bGQgYmUgaW52b2tlZCB3aGVuIHRoZSBmbG9hdGluZyBlbGVtZW50IGlzXG4gKiByZW1vdmVkIGZyb20gdGhlIERPTSBvciBoaWRkZW4gZnJvbSB0aGUgc2NyZWVuLlxuICogQHNlZSBodHRwczovL2Zsb2F0aW5nLXVpLmNvbS9kb2NzL2F1dG9VcGRhdGVcbiAqL1xuZnVuY3Rpb24gYXV0b1VwZGF0ZShyZWZlcmVuY2UsIGZsb2F0aW5nLCB1cGRhdGUsIG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfVxuICBjb25zdCB7XG4gICAgYW5jZXN0b3JTY3JvbGwgPSB0cnVlLFxuICAgIGFuY2VzdG9yUmVzaXplID0gdHJ1ZSxcbiAgICBlbGVtZW50UmVzaXplID0gdHlwZW9mIFJlc2l6ZU9ic2VydmVyID09PSAnZnVuY3Rpb24nLFxuICAgIGxheW91dFNoaWZ0ID0gdHlwZW9mIEludGVyc2VjdGlvbk9ic2VydmVyID09PSAnZnVuY3Rpb24nLFxuICAgIGFuaW1hdGlvbkZyYW1lID0gZmFsc2VcbiAgfSA9IG9wdGlvbnM7XG4gIGNvbnN0IHJlZmVyZW5jZUVsID0gdW53cmFwRWxlbWVudChyZWZlcmVuY2UpO1xuICBjb25zdCBhbmNlc3RvcnMgPSBhbmNlc3RvclNjcm9sbCB8fCBhbmNlc3RvclJlc2l6ZSA/IFsuLi4ocmVmZXJlbmNlRWwgPyBnZXRPdmVyZmxvd0FuY2VzdG9ycyhyZWZlcmVuY2VFbCkgOiBbXSksIC4uLmdldE92ZXJmbG93QW5jZXN0b3JzKGZsb2F0aW5nKV0gOiBbXTtcbiAgYW5jZXN0b3JzLmZvckVhY2goYW5jZXN0b3IgPT4ge1xuICAgIGFuY2VzdG9yU2Nyb2xsICYmIGFuY2VzdG9yLmFkZEV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIHVwZGF0ZSwge1xuICAgICAgcGFzc2l2ZTogdHJ1ZVxuICAgIH0pO1xuICAgIGFuY2VzdG9yUmVzaXplICYmIGFuY2VzdG9yLmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHVwZGF0ZSk7XG4gIH0pO1xuICBjb25zdCBjbGVhbnVwSW8gPSByZWZlcmVuY2VFbCAmJiBsYXlvdXRTaGlmdCA/IG9ic2VydmVNb3ZlKHJlZmVyZW5jZUVsLCB1cGRhdGUpIDogbnVsbDtcbiAgbGV0IHJlb2JzZXJ2ZUZyYW1lID0gLTE7XG4gIGxldCByZXNpemVPYnNlcnZlciA9IG51bGw7XG4gIGlmIChlbGVtZW50UmVzaXplKSB7XG4gICAgcmVzaXplT2JzZXJ2ZXIgPSBuZXcgUmVzaXplT2JzZXJ2ZXIoX3JlZiA9PiB7XG4gICAgICBsZXQgW2ZpcnN0RW50cnldID0gX3JlZjtcbiAgICAgIGlmIChmaXJzdEVudHJ5ICYmIGZpcnN0RW50cnkudGFyZ2V0ID09PSByZWZlcmVuY2VFbCAmJiByZXNpemVPYnNlcnZlcikge1xuICAgICAgICAvLyBQcmV2ZW50IHVwZGF0ZSBsb29wcyB3aGVuIHVzaW5nIHRoZSBgc2l6ZWAgbWlkZGxld2FyZS5cbiAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2Zsb2F0aW5nLXVpL2Zsb2F0aW5nLXVpL2lzc3Vlcy8xNzQwXG4gICAgICAgIHJlc2l6ZU9ic2VydmVyLnVub2JzZXJ2ZShmbG9hdGluZyk7XG4gICAgICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKHJlb2JzZXJ2ZUZyYW1lKTtcbiAgICAgICAgcmVvYnNlcnZlRnJhbWUgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgICAgIHZhciBfcmVzaXplT2JzZXJ2ZXI7XG4gICAgICAgICAgKF9yZXNpemVPYnNlcnZlciA9IHJlc2l6ZU9ic2VydmVyKSA9PSBudWxsIHx8IF9yZXNpemVPYnNlcnZlci5vYnNlcnZlKGZsb2F0aW5nKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICB1cGRhdGUoKTtcbiAgICB9KTtcbiAgICBpZiAocmVmZXJlbmNlRWwgJiYgIWFuaW1hdGlvbkZyYW1lKSB7XG4gICAgICByZXNpemVPYnNlcnZlci5vYnNlcnZlKHJlZmVyZW5jZUVsKTtcbiAgICB9XG4gICAgcmVzaXplT2JzZXJ2ZXIub2JzZXJ2ZShmbG9hdGluZyk7XG4gIH1cbiAgbGV0IGZyYW1lSWQ7XG4gIGxldCBwcmV2UmVmUmVjdCA9IGFuaW1hdGlvbkZyYW1lID8gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KHJlZmVyZW5jZSkgOiBudWxsO1xuICBpZiAoYW5pbWF0aW9uRnJhbWUpIHtcbiAgICBmcmFtZUxvb3AoKTtcbiAgfVxuICBmdW5jdGlvbiBmcmFtZUxvb3AoKSB7XG4gICAgY29uc3QgbmV4dFJlZlJlY3QgPSBnZXRCb3VuZGluZ0NsaWVudFJlY3QocmVmZXJlbmNlKTtcbiAgICBpZiAocHJldlJlZlJlY3QgJiYgKG5leHRSZWZSZWN0LnggIT09IHByZXZSZWZSZWN0LnggfHwgbmV4dFJlZlJlY3QueSAhPT0gcHJldlJlZlJlY3QueSB8fCBuZXh0UmVmUmVjdC53aWR0aCAhPT0gcHJldlJlZlJlY3Qud2lkdGggfHwgbmV4dFJlZlJlY3QuaGVpZ2h0ICE9PSBwcmV2UmVmUmVjdC5oZWlnaHQpKSB7XG4gICAgICB1cGRhdGUoKTtcbiAgICB9XG4gICAgcHJldlJlZlJlY3QgPSBuZXh0UmVmUmVjdDtcbiAgICBmcmFtZUlkID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZyYW1lTG9vcCk7XG4gIH1cbiAgdXBkYXRlKCk7XG4gIHJldHVybiAoKSA9PiB7XG4gICAgdmFyIF9yZXNpemVPYnNlcnZlcjI7XG4gICAgYW5jZXN0b3JzLmZvckVhY2goYW5jZXN0b3IgPT4ge1xuICAgICAgYW5jZXN0b3JTY3JvbGwgJiYgYW5jZXN0b3IucmVtb3ZlRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgdXBkYXRlKTtcbiAgICAgIGFuY2VzdG9yUmVzaXplICYmIGFuY2VzdG9yLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHVwZGF0ZSk7XG4gICAgfSk7XG4gICAgY2xlYW51cElvID09IG51bGwgfHwgY2xlYW51cElvKCk7XG4gICAgKF9yZXNpemVPYnNlcnZlcjIgPSByZXNpemVPYnNlcnZlcikgPT0gbnVsbCB8fCBfcmVzaXplT2JzZXJ2ZXIyLmRpc2Nvbm5lY3QoKTtcbiAgICByZXNpemVPYnNlcnZlciA9IG51bGw7XG4gICAgaWYgKGFuaW1hdGlvbkZyYW1lKSB7XG4gICAgICBjYW5jZWxBbmltYXRpb25GcmFtZShmcmFtZUlkKTtcbiAgICB9XG4gIH07XG59XG5cbi8qKlxuICogT3B0aW1pemVzIHRoZSB2aXNpYmlsaXR5IG9mIHRoZSBmbG9hdGluZyBlbGVtZW50IGJ5IGNob29zaW5nIHRoZSBwbGFjZW1lbnRcbiAqIHRoYXQgaGFzIHRoZSBtb3N0IHNwYWNlIGF2YWlsYWJsZSBhdXRvbWF0aWNhbGx5LCB3aXRob3V0IG5lZWRpbmcgdG8gc3BlY2lmeSBhXG4gKiBwcmVmZXJyZWQgcGxhY2VtZW50LiBBbHRlcm5hdGl2ZSB0byBgZmxpcGAuXG4gKiBAc2VlIGh0dHBzOi8vZmxvYXRpbmctdWkuY29tL2RvY3MvYXV0b1BsYWNlbWVudFxuICovXG5jb25zdCBhdXRvUGxhY2VtZW50ID0gYXV0b1BsYWNlbWVudCQxO1xuXG4vKipcbiAqIE9wdGltaXplcyB0aGUgdmlzaWJpbGl0eSBvZiB0aGUgZmxvYXRpbmcgZWxlbWVudCBieSBzaGlmdGluZyBpdCBpbiBvcmRlciB0b1xuICoga2VlcCBpdCBpbiB2aWV3IHdoZW4gaXQgd2lsbCBvdmVyZmxvdyB0aGUgY2xpcHBpbmcgYm91bmRhcnkuXG4gKiBAc2VlIGh0dHBzOi8vZmxvYXRpbmctdWkuY29tL2RvY3Mvc2hpZnRcbiAqL1xuY29uc3Qgc2hpZnQgPSBzaGlmdCQxO1xuXG4vKipcbiAqIE9wdGltaXplcyB0aGUgdmlzaWJpbGl0eSBvZiB0aGUgZmxvYXRpbmcgZWxlbWVudCBieSBmbGlwcGluZyB0aGUgYHBsYWNlbWVudGBcbiAqIGluIG9yZGVyIHRvIGtlZXAgaXQgaW4gdmlldyB3aGVuIHRoZSBwcmVmZXJyZWQgcGxhY2VtZW50KHMpIHdpbGwgb3ZlcmZsb3cgdGhlXG4gKiBjbGlwcGluZyBib3VuZGFyeS4gQWx0ZXJuYXRpdmUgdG8gYGF1dG9QbGFjZW1lbnRgLlxuICogQHNlZSBodHRwczovL2Zsb2F0aW5nLXVpLmNvbS9kb2NzL2ZsaXBcbiAqL1xuY29uc3QgZmxpcCA9IGZsaXAkMTtcblxuLyoqXG4gKiBQcm92aWRlcyBkYXRhIHRoYXQgYWxsb3dzIHlvdSB0byBjaGFuZ2UgdGhlIHNpemUgb2YgdGhlIGZsb2F0aW5nIGVsZW1lbnQg4oCUXG4gKiBmb3IgaW5zdGFuY2UsIHByZXZlbnQgaXQgZnJvbSBvdmVyZmxvd2luZyB0aGUgY2xpcHBpbmcgYm91bmRhcnkgb3IgbWF0Y2ggdGhlXG4gKiB3aWR0aCBvZiB0aGUgcmVmZXJlbmNlIGVsZW1lbnQuXG4gKiBAc2VlIGh0dHBzOi8vZmxvYXRpbmctdWkuY29tL2RvY3Mvc2l6ZVxuICovXG5jb25zdCBzaXplID0gc2l6ZSQxO1xuXG4vKipcbiAqIFByb3ZpZGVzIGRhdGEgdG8gaGlkZSB0aGUgZmxvYXRpbmcgZWxlbWVudCBpbiBhcHBsaWNhYmxlIHNpdHVhdGlvbnMsIHN1Y2ggYXNcbiAqIHdoZW4gaXQgaXMgbm90IGluIHRoZSBzYW1lIGNsaXBwaW5nIGNvbnRleHQgYXMgdGhlIHJlZmVyZW5jZSBlbGVtZW50LlxuICogQHNlZSBodHRwczovL2Zsb2F0aW5nLXVpLmNvbS9kb2NzL2hpZGVcbiAqL1xuY29uc3QgaGlkZSA9IGhpZGUkMTtcblxuLyoqXG4gKiBQcm92aWRlcyBkYXRhIHRvIHBvc2l0aW9uIGFuIGlubmVyIGVsZW1lbnQgb2YgdGhlIGZsb2F0aW5nIGVsZW1lbnQgc28gdGhhdCBpdFxuICogYXBwZWFycyBjZW50ZXJlZCB0byB0aGUgcmVmZXJlbmNlIGVsZW1lbnQuXG4gKiBAc2VlIGh0dHBzOi8vZmxvYXRpbmctdWkuY29tL2RvY3MvYXJyb3dcbiAqL1xuY29uc3QgYXJyb3cgPSBhcnJvdyQxO1xuXG4vKipcbiAqIFByb3ZpZGVzIGltcHJvdmVkIHBvc2l0aW9uaW5nIGZvciBpbmxpbmUgcmVmZXJlbmNlIGVsZW1lbnRzIHRoYXQgY2FuIHNwYW5cbiAqIG92ZXIgbXVsdGlwbGUgbGluZXMsIHN1Y2ggYXMgaHlwZXJsaW5rcyBvciByYW5nZSBzZWxlY3Rpb25zLlxuICogQHNlZSBodHRwczovL2Zsb2F0aW5nLXVpLmNvbS9kb2NzL2lubGluZVxuICovXG5jb25zdCBpbmxpbmUgPSBpbmxpbmUkMTtcblxuLyoqXG4gKiBCdWlsdC1pbiBgbGltaXRlcmAgdGhhdCB3aWxsIHN0b3AgYHNoaWZ0KClgIGF0IGEgY2VydGFpbiBwb2ludC5cbiAqL1xuY29uc3QgbGltaXRTaGlmdCA9IGxpbWl0U2hpZnQkMTtcblxuLyoqXG4gKiBDb21wdXRlcyB0aGUgYHhgIGFuZCBgeWAgY29vcmRpbmF0ZXMgdGhhdCB3aWxsIHBsYWNlIHRoZSBmbG9hdGluZyBlbGVtZW50XG4gKiBuZXh0IHRvIGEgZ2l2ZW4gcmVmZXJlbmNlIGVsZW1lbnQuXG4gKi9cbmNvbnN0IGNvbXB1dGVQb3NpdGlvbiA9IChyZWZlcmVuY2UsIGZsb2F0aW5nLCBvcHRpb25zKSA9PiB7XG4gIC8vIFRoaXMgY2FjaGVzIHRoZSBleHBlbnNpdmUgYGdldENsaXBwaW5nRWxlbWVudEFuY2VzdG9yc2AgZnVuY3Rpb24gc28gdGhhdFxuICAvLyBtdWx0aXBsZSBsaWZlY3ljbGUgcmVzZXRzIHJlLXVzZSB0aGUgc2FtZSByZXN1bHQuIEl0IG9ubHkgbGl2ZXMgZm9yIGFcbiAgLy8gc2luZ2xlIGNhbGwuIElmIG90aGVyIGZ1bmN0aW9ucyBiZWNvbWUgZXhwZW5zaXZlLCB3ZSBjYW4gYWRkIHRoZW0gYXMgd2VsbC5cbiAgY29uc3QgY2FjaGUgPSBuZXcgTWFwKCk7XG4gIGNvbnN0IG1lcmdlZE9wdGlvbnMgPSB7XG4gICAgcGxhdGZvcm0sXG4gICAgLi4ub3B0aW9uc1xuICB9O1xuICBjb25zdCBwbGF0Zm9ybVdpdGhDYWNoZSA9IHtcbiAgICAuLi5tZXJnZWRPcHRpb25zLnBsYXRmb3JtLFxuICAgIF9jOiBjYWNoZVxuICB9O1xuICByZXR1cm4gY29tcHV0ZVBvc2l0aW9uJDEocmVmZXJlbmNlLCBmbG9hdGluZywge1xuICAgIC4uLm1lcmdlZE9wdGlvbnMsXG4gICAgcGxhdGZvcm06IHBsYXRmb3JtV2l0aENhY2hlXG4gIH0pO1xufTtcblxuZXhwb3J0IHsgYXJyb3csIGF1dG9QbGFjZW1lbnQsIGF1dG9VcGRhdGUsIGNvbXB1dGVQb3NpdGlvbiwgZmxpcCwgaGlkZSwgaW5saW5lLCBsaW1pdFNoaWZ0LCBwbGF0Zm9ybSwgc2hpZnQsIHNpemUgfTtcbiJdLCJuYW1lcyI6WyJyZWN0VG9DbGllbnRSZWN0IiwiYXV0b1BsYWNlbWVudCIsImF1dG9QbGFjZW1lbnQkMSIsInNoaWZ0Iiwic2hpZnQkMSIsImZsaXAiLCJmbGlwJDEiLCJzaXplIiwic2l6ZSQxIiwiaGlkZSIsImhpZGUkMSIsImFycm93IiwiYXJyb3ckMSIsImlubGluZSIsImlubGluZSQxIiwibGltaXRTaGlmdCIsImxpbWl0U2hpZnQkMSIsImNvbXB1dGVQb3NpdGlvbiIsImNvbXB1dGVQb3NpdGlvbiQxIiwiZGV0ZWN0T3ZlcmZsb3ciLCJvZmZzZXQiLCJyb3VuZCIsImNyZWF0ZUNvb3JkcyIsIm1heCIsIm1pbiIsImZsb29yIiwiZ2V0Q29tcHV0ZWRTdHlsZSIsImlzSFRNTEVsZW1lbnQiLCJpc0VsZW1lbnQiLCJnZXRXaW5kb3ciLCJpc1dlYktpdCIsImdldERvY3VtZW50RWxlbWVudCIsImdldE5vZGVOYW1lIiwiaXNPdmVyZmxvd0VsZW1lbnQiLCJnZXROb2RlU2Nyb2xsIiwiZ2V0T3ZlcmZsb3dBbmNlc3RvcnMiLCJnZXRQYXJlbnROb2RlIiwiaXNMYXN0VHJhdmVyc2FibGVOb2RlIiwiaXNDb250YWluaW5nQmxvY2siLCJpc1RhYmxlRWxlbWVudCIsImdldENvbnRhaW5pbmdCbG9jayIsImdldENzc0RpbWVuc2lvbnMiLCJlbGVtZW50IiwiY3NzIiwid2lkdGgiLCJwYXJzZUZsb2F0IiwiaGVpZ2h0IiwiaGFzT2Zmc2V0Iiwib2Zmc2V0V2lkdGgiLCJvZmZzZXRIZWlnaHQiLCJzaG91bGRGYWxsYmFjayIsIiQiLCJ1bndyYXBFbGVtZW50IiwiY29udGV4dEVsZW1lbnQiLCJnZXRTY2FsZSIsImRvbUVsZW1lbnQiLCJyZWN0IiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0IiwieCIsInkiLCJOdW1iZXIiLCJpc0Zpbml0ZSIsIm5vT2Zmc2V0cyIsImdldFZpc3VhbE9mZnNldHMiLCJ3aW4iLCJ2aXN1YWxWaWV3cG9ydCIsIm9mZnNldExlZnQiLCJvZmZzZXRUb3AiLCJzaG91bGRBZGRWaXN1YWxPZmZzZXRzIiwiaXNGaXhlZCIsImZsb2F0aW5nT2Zmc2V0UGFyZW50IiwiaW5jbHVkZVNjYWxlIiwiaXNGaXhlZFN0cmF0ZWd5Iiwib2Zmc2V0UGFyZW50IiwiY2xpZW50UmVjdCIsInNjYWxlIiwidmlzdWFsT2Zmc2V0cyIsImxlZnQiLCJ0b3AiLCJvZmZzZXRXaW4iLCJjdXJyZW50V2luIiwiY3VycmVudElGcmFtZSIsImZyYW1lRWxlbWVudCIsImlmcmFtZVNjYWxlIiwiaWZyYW1lUmVjdCIsImNsaWVudExlZnQiLCJwYWRkaW5nTGVmdCIsImNsaWVudFRvcCIsInBhZGRpbmdUb3AiLCJ0b3BMYXllclNlbGVjdG9ycyIsImlzVG9wTGF5ZXIiLCJmbG9hdGluZyIsInNvbWUiLCJzZWxlY3RvciIsIm1hdGNoZXMiLCJlIiwiY29udmVydE9mZnNldFBhcmVudFJlbGF0aXZlUmVjdFRvVmlld3BvcnRSZWxhdGl2ZVJlY3QiLCJfcmVmIiwiZWxlbWVudHMiLCJzdHJhdGVneSIsImRvY3VtZW50RWxlbWVudCIsInRvcExheWVyIiwic2Nyb2xsIiwic2Nyb2xsTGVmdCIsInNjcm9sbFRvcCIsIm9mZnNldHMiLCJpc09mZnNldFBhcmVudEFuRWxlbWVudCIsIm9mZnNldFJlY3QiLCJnZXRDbGllbnRSZWN0cyIsIkFycmF5IiwiZnJvbSIsImdldFdpbmRvd1Njcm9sbEJhclgiLCJnZXREb2N1bWVudFJlY3QiLCJodG1sIiwiYm9keSIsIm93bmVyRG9jdW1lbnQiLCJzY3JvbGxXaWR0aCIsImNsaWVudFdpZHRoIiwic2Nyb2xsSGVpZ2h0IiwiY2xpZW50SGVpZ2h0IiwiZGlyZWN0aW9uIiwiZ2V0Vmlld3BvcnRSZWN0IiwidmlzdWFsVmlld3BvcnRCYXNlZCIsImdldElubmVyQm91bmRpbmdDbGllbnRSZWN0IiwiZ2V0Q2xpZW50UmVjdEZyb21DbGlwcGluZ0FuY2VzdG9yIiwiY2xpcHBpbmdBbmNlc3RvciIsImhhc0ZpeGVkUG9zaXRpb25BbmNlc3RvciIsInN0b3BOb2RlIiwicGFyZW50Tm9kZSIsInBvc2l0aW9uIiwiZ2V0Q2xpcHBpbmdFbGVtZW50QW5jZXN0b3JzIiwiY2FjaGUiLCJjYWNoZWRSZXN1bHQiLCJnZXQiLCJyZXN1bHQiLCJmaWx0ZXIiLCJlbCIsImN1cnJlbnRDb250YWluaW5nQmxvY2tDb21wdXRlZFN0eWxlIiwiZWxlbWVudElzRml4ZWQiLCJjdXJyZW50Tm9kZSIsImNvbXB1dGVkU3R5bGUiLCJjdXJyZW50Tm9kZUlzQ29udGFpbmluZyIsInNob3VsZERyb3BDdXJyZW50Tm9kZSIsImluY2x1ZGVzIiwiYW5jZXN0b3IiLCJzZXQiLCJnZXRDbGlwcGluZ1JlY3QiLCJib3VuZGFyeSIsInJvb3RCb3VuZGFyeSIsImVsZW1lbnRDbGlwcGluZ0FuY2VzdG9ycyIsIl9jIiwiY29uY2F0IiwiY2xpcHBpbmdBbmNlc3RvcnMiLCJmaXJzdENsaXBwaW5nQW5jZXN0b3IiLCJjbGlwcGluZ1JlY3QiLCJyZWR1Y2UiLCJhY2NSZWN0IiwicmlnaHQiLCJib3R0b20iLCJnZXREaW1lbnNpb25zIiwiZ2V0UmVjdFJlbGF0aXZlVG9PZmZzZXRQYXJlbnQiLCJnZXRUcnVlT2Zmc2V0UGFyZW50IiwicG9seWZpbGwiLCJnZXRPZmZzZXRQYXJlbnQiLCJ3aW5kb3ciLCJnZXRFbGVtZW50UmVjdHMiLCJkYXRhIiwiZ2V0T2Zmc2V0UGFyZW50Rm4iLCJnZXREaW1lbnNpb25zRm4iLCJyZWZlcmVuY2UiLCJpc1JUTCIsInBsYXRmb3JtIiwib2JzZXJ2ZU1vdmUiLCJvbk1vdmUiLCJpbyIsInRpbWVvdXRJZCIsInJvb3QiLCJjbGVhbnVwIiwiX2lvIiwiY2xlYXJUaW1lb3V0IiwiZGlzY29ubmVjdCIsInJlZnJlc2giLCJza2lwIiwidGhyZXNob2xkIiwiaW5zZXRUb3AiLCJpbnNldFJpZ2h0IiwiaW5zZXRCb3R0b20iLCJpbnNldExlZnQiLCJyb290TWFyZ2luIiwib3B0aW9ucyIsImlzRmlyc3RVcGRhdGUiLCJoYW5kbGVPYnNlcnZlIiwiZW50cmllcyIsInJhdGlvIiwiaW50ZXJzZWN0aW9uUmF0aW8iLCJzZXRUaW1lb3V0IiwiSW50ZXJzZWN0aW9uT2JzZXJ2ZXIiLCJvYnNlcnZlIiwiYXV0b1VwZGF0ZSIsInVwZGF0ZSIsImFuY2VzdG9yU2Nyb2xsIiwiYW5jZXN0b3JSZXNpemUiLCJlbGVtZW50UmVzaXplIiwiUmVzaXplT2JzZXJ2ZXIiLCJsYXlvdXRTaGlmdCIsImFuaW1hdGlvbkZyYW1lIiwicmVmZXJlbmNlRWwiLCJhbmNlc3RvcnMiLCJmb3JFYWNoIiwiYWRkRXZlbnRMaXN0ZW5lciIsInBhc3NpdmUiLCJjbGVhbnVwSW8iLCJyZW9ic2VydmVGcmFtZSIsInJlc2l6ZU9ic2VydmVyIiwiZmlyc3RFbnRyeSIsInRhcmdldCIsInVub2JzZXJ2ZSIsImNhbmNlbEFuaW1hdGlvbkZyYW1lIiwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwiX3Jlc2l6ZU9ic2VydmVyIiwiZnJhbWVJZCIsInByZXZSZWZSZWN0IiwiZnJhbWVMb29wIiwibmV4dFJlZlJlY3QiLCJfcmVzaXplT2JzZXJ2ZXIyIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsIk1hcCIsIm1lcmdlZE9wdGlvbnMiLCJwbGF0Zm9ybVdpdGhDYWNoZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@floating-ui/dom/dist/floating-ui.dom.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@floating-ui/react-dom/dist/floating-ui.react-dom.mjs":
/*!****************************************************************************!*\
  !*** ./node_modules/@floating-ui/react-dom/dist/floating-ui.react-dom.mjs ***!
  \****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   arrow: () => (/* binding */ arrow),\n/* harmony export */   autoPlacement: () => (/* reexport safe */ _floating_ui_dom__WEBPACK_IMPORTED_MODULE_0__.autoPlacement),\n/* harmony export */   autoUpdate: () => (/* reexport safe */ _floating_ui_dom__WEBPACK_IMPORTED_MODULE_0__.autoUpdate),\n/* harmony export */   computePosition: () => (/* reexport safe */ _floating_ui_dom__WEBPACK_IMPORTED_MODULE_0__.computePosition),\n/* harmony export */   detectOverflow: () => (/* reexport safe */ _floating_ui_dom__WEBPACK_IMPORTED_MODULE_1__.detectOverflow),\n/* harmony export */   flip: () => (/* reexport safe */ _floating_ui_dom__WEBPACK_IMPORTED_MODULE_0__.flip),\n/* harmony export */   getOverflowAncestors: () => (/* reexport safe */ _floating_ui_dom__WEBPACK_IMPORTED_MODULE_2__.getOverflowAncestors),\n/* harmony export */   hide: () => (/* reexport safe */ _floating_ui_dom__WEBPACK_IMPORTED_MODULE_0__.hide),\n/* harmony export */   inline: () => (/* reexport safe */ _floating_ui_dom__WEBPACK_IMPORTED_MODULE_0__.inline),\n/* harmony export */   limitShift: () => (/* reexport safe */ _floating_ui_dom__WEBPACK_IMPORTED_MODULE_0__.limitShift),\n/* harmony export */   offset: () => (/* reexport safe */ _floating_ui_dom__WEBPACK_IMPORTED_MODULE_1__.offset),\n/* harmony export */   platform: () => (/* reexport safe */ _floating_ui_dom__WEBPACK_IMPORTED_MODULE_0__.platform),\n/* harmony export */   shift: () => (/* reexport safe */ _floating_ui_dom__WEBPACK_IMPORTED_MODULE_0__.shift),\n/* harmony export */   size: () => (/* reexport safe */ _floating_ui_dom__WEBPACK_IMPORTED_MODULE_0__.size),\n/* harmony export */   useFloating: () => (/* binding */ useFloating)\n/* harmony export */ });\n/* harmony import */ var _floating_ui_dom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @floating-ui/dom */ \"(ssr)/./node_modules/@floating-ui/dom/dist/floating-ui.dom.mjs\");\n/* harmony import */ var _floating_ui_dom__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @floating-ui/dom */ \"(ssr)/./node_modules/@floating-ui/core/dist/floating-ui.core.mjs\");\n/* harmony import */ var _floating_ui_dom__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @floating-ui/dom */ \"(ssr)/./node_modules/@floating-ui/utils/dist/floating-ui.utils.dom.mjs\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! react-dom */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react-dom.js\");\n\n\n\n\n\n/**\n * Provides data to position an inner element of the floating element so that it\n * appears centered to the reference element.\n * This wraps the core `arrow` middleware to allow React refs as the element.\n * @see https://floating-ui.com/docs/arrow\n */ const arrow = (options)=>{\n    function isRef(value) {\n        return ({}).hasOwnProperty.call(value, \"current\");\n    }\n    return {\n        name: \"arrow\",\n        options,\n        fn (state) {\n            const { element, padding } = typeof options === \"function\" ? options(state) : options;\n            if (element && isRef(element)) {\n                if (element.current != null) {\n                    return (0,_floating_ui_dom__WEBPACK_IMPORTED_MODULE_0__.arrow)({\n                        element: element.current,\n                        padding\n                    }).fn(state);\n                }\n                return {};\n            }\n            if (element) {\n                return (0,_floating_ui_dom__WEBPACK_IMPORTED_MODULE_0__.arrow)({\n                    element,\n                    padding\n                }).fn(state);\n            }\n            return {};\n        }\n    };\n};\nvar index = typeof document !== \"undefined\" ? react__WEBPACK_IMPORTED_MODULE_3__.useLayoutEffect : react__WEBPACK_IMPORTED_MODULE_3__.useEffect;\n// Fork of `fast-deep-equal` that only does the comparisons we need and compares\n// functions\nfunction deepEqual(a, b) {\n    if (a === b) {\n        return true;\n    }\n    if (typeof a !== typeof b) {\n        return false;\n    }\n    if (typeof a === \"function\" && a.toString() === b.toString()) {\n        return true;\n    }\n    let length;\n    let i;\n    let keys;\n    if (a && b && typeof a === \"object\") {\n        if (Array.isArray(a)) {\n            length = a.length;\n            if (length !== b.length) return false;\n            for(i = length; i-- !== 0;){\n                if (!deepEqual(a[i], b[i])) {\n                    return false;\n                }\n            }\n            return true;\n        }\n        keys = Object.keys(a);\n        length = keys.length;\n        if (length !== Object.keys(b).length) {\n            return false;\n        }\n        for(i = length; i-- !== 0;){\n            if (!({}).hasOwnProperty.call(b, keys[i])) {\n                return false;\n            }\n        }\n        for(i = length; i-- !== 0;){\n            const key = keys[i];\n            if (key === \"_owner\" && a.$$typeof) {\n                continue;\n            }\n            if (!deepEqual(a[key], b[key])) {\n                return false;\n            }\n        }\n        return true;\n    }\n    // biome-ignore lint/suspicious/noSelfCompare: in source\n    return a !== a && b !== b;\n}\nfunction getDPR(element) {\n    if (true) {\n        return 1;\n    }\n    const win = element.ownerDocument.defaultView || window;\n    return win.devicePixelRatio || 1;\n}\nfunction roundByDPR(element, value) {\n    const dpr = getDPR(element);\n    return Math.round(value * dpr) / dpr;\n}\nfunction useLatestRef(value) {\n    const ref = react__WEBPACK_IMPORTED_MODULE_3__.useRef(value);\n    index(()=>{\n        ref.current = value;\n    });\n    return ref;\n}\n/**\n * Provides data to position a floating element.\n * @see https://floating-ui.com/docs/useFloating\n */ function useFloating(options) {\n    if (options === void 0) {\n        options = {};\n    }\n    const { placement = \"bottom\", strategy = \"absolute\", middleware = [], platform, elements: { reference: externalReference, floating: externalFloating } = {}, transform = true, whileElementsMounted, open } = options;\n    const [data, setData] = react__WEBPACK_IMPORTED_MODULE_3__.useState({\n        x: 0,\n        y: 0,\n        strategy,\n        placement,\n        middlewareData: {},\n        isPositioned: false\n    });\n    const [latestMiddleware, setLatestMiddleware] = react__WEBPACK_IMPORTED_MODULE_3__.useState(middleware);\n    if (!deepEqual(latestMiddleware, middleware)) {\n        setLatestMiddleware(middleware);\n    }\n    const [_reference, _setReference] = react__WEBPACK_IMPORTED_MODULE_3__.useState(null);\n    const [_floating, _setFloating] = react__WEBPACK_IMPORTED_MODULE_3__.useState(null);\n    const setReference = react__WEBPACK_IMPORTED_MODULE_3__.useCallback((node)=>{\n        if (node !== referenceRef.current) {\n            referenceRef.current = node;\n            _setReference(node);\n        }\n    }, []);\n    const setFloating = react__WEBPACK_IMPORTED_MODULE_3__.useCallback((node)=>{\n        if (node !== floatingRef.current) {\n            floatingRef.current = node;\n            _setFloating(node);\n        }\n    }, []);\n    const referenceEl = externalReference || _reference;\n    const floatingEl = externalFloating || _floating;\n    const referenceRef = react__WEBPACK_IMPORTED_MODULE_3__.useRef(null);\n    const floatingRef = react__WEBPACK_IMPORTED_MODULE_3__.useRef(null);\n    const dataRef = react__WEBPACK_IMPORTED_MODULE_3__.useRef(data);\n    const hasWhileElementsMounted = whileElementsMounted != null;\n    const whileElementsMountedRef = useLatestRef(whileElementsMounted);\n    const platformRef = useLatestRef(platform);\n    const update = react__WEBPACK_IMPORTED_MODULE_3__.useCallback(()=>{\n        if (!referenceRef.current || !floatingRef.current) {\n            return;\n        }\n        const config = {\n            placement,\n            strategy,\n            middleware: latestMiddleware\n        };\n        if (platformRef.current) {\n            config.platform = platformRef.current;\n        }\n        (0,_floating_ui_dom__WEBPACK_IMPORTED_MODULE_0__.computePosition)(referenceRef.current, floatingRef.current, config).then((data)=>{\n            const fullData = {\n                ...data,\n                isPositioned: true\n            };\n            if (isMountedRef.current && !deepEqual(dataRef.current, fullData)) {\n                dataRef.current = fullData;\n                react_dom__WEBPACK_IMPORTED_MODULE_4__.flushSync(()=>{\n                    setData(fullData);\n                });\n            }\n        });\n    }, [\n        latestMiddleware,\n        placement,\n        strategy,\n        platformRef\n    ]);\n    index(()=>{\n        if (open === false && dataRef.current.isPositioned) {\n            dataRef.current.isPositioned = false;\n            setData((data)=>({\n                    ...data,\n                    isPositioned: false\n                }));\n        }\n    }, [\n        open\n    ]);\n    const isMountedRef = react__WEBPACK_IMPORTED_MODULE_3__.useRef(false);\n    index(()=>{\n        isMountedRef.current = true;\n        return ()=>{\n            isMountedRef.current = false;\n        };\n    }, []);\n    // biome-ignore lint/correctness/useExhaustiveDependencies: `hasWhileElementsMounted` is intentionally included.\n    index(()=>{\n        if (referenceEl) referenceRef.current = referenceEl;\n        if (floatingEl) floatingRef.current = floatingEl;\n        if (referenceEl && floatingEl) {\n            if (whileElementsMountedRef.current) {\n                return whileElementsMountedRef.current(referenceEl, floatingEl, update);\n            }\n            update();\n        }\n    }, [\n        referenceEl,\n        floatingEl,\n        update,\n        whileElementsMountedRef,\n        hasWhileElementsMounted\n    ]);\n    const refs = react__WEBPACK_IMPORTED_MODULE_3__.useMemo(()=>({\n            reference: referenceRef,\n            floating: floatingRef,\n            setReference,\n            setFloating\n        }), [\n        setReference,\n        setFloating\n    ]);\n    const elements = react__WEBPACK_IMPORTED_MODULE_3__.useMemo(()=>({\n            reference: referenceEl,\n            floating: floatingEl\n        }), [\n        referenceEl,\n        floatingEl\n    ]);\n    const floatingStyles = react__WEBPACK_IMPORTED_MODULE_3__.useMemo(()=>{\n        const initialStyles = {\n            position: strategy,\n            left: 0,\n            top: 0\n        };\n        if (!elements.floating) {\n            return initialStyles;\n        }\n        const x = roundByDPR(elements.floating, data.x);\n        const y = roundByDPR(elements.floating, data.y);\n        if (transform) {\n            return {\n                ...initialStyles,\n                transform: \"translate(\" + x + \"px, \" + y + \"px)\",\n                ...getDPR(elements.floating) >= 1.5 && {\n                    willChange: \"transform\"\n                }\n            };\n        }\n        return {\n            position: strategy,\n            left: x,\n            top: y\n        };\n    }, [\n        strategy,\n        transform,\n        elements.floating,\n        data.x,\n        data.y\n    ]);\n    return react__WEBPACK_IMPORTED_MODULE_3__.useMemo(()=>({\n            ...data,\n            update,\n            refs,\n            elements,\n            floatingStyles\n        }), [\n        data,\n        update,\n        refs,\n        elements,\n        floatingStyles\n    ]);\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGZsb2F0aW5nLXVpL3JlYWN0LWRvbS9kaXN0L2Zsb2F0aW5nLXVpLnJlYWN0LWRvbS5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBcUU7QUFDOEc7QUFDcEo7QUFDb0I7QUFDYjtBQUV0Qzs7Ozs7Q0FLQyxHQUNELE1BQU1BLFFBQVFtQixDQUFBQTtJQUNaLFNBQVNDLE1BQU1DLEtBQUs7UUFDbEIsT0FBTyxFQUFDLEdBQUVDLGNBQWMsQ0FBQ0MsSUFBSSxDQUFDRixPQUFPO0lBQ3ZDO0lBQ0EsT0FBTztRQUNMRyxNQUFNO1FBQ05MO1FBQ0FNLElBQUdDLEtBQUs7WUFDTixNQUFNLEVBQ0pDLE9BQU8sRUFDUEMsT0FBTyxFQUNSLEdBQUcsT0FBT1QsWUFBWSxhQUFhQSxRQUFRTyxTQUFTUDtZQUNyRCxJQUFJUSxXQUFXUCxNQUFNTyxVQUFVO2dCQUM3QixJQUFJQSxRQUFRRSxPQUFPLElBQUksTUFBTTtvQkFDM0IsT0FBTzVCLHVEQUFPQSxDQUFDO3dCQUNiMEIsU0FBU0EsUUFBUUUsT0FBTzt3QkFDeEJEO29CQUNGLEdBQUdILEVBQUUsQ0FBQ0M7Z0JBQ1I7Z0JBQ0EsT0FBTyxDQUFDO1lBQ1Y7WUFDQSxJQUFJQyxTQUFTO2dCQUNYLE9BQU8xQix1REFBT0EsQ0FBQztvQkFDYjBCO29CQUNBQztnQkFDRixHQUFHSCxFQUFFLENBQUNDO1lBQ1I7WUFDQSxPQUFPLENBQUM7UUFDVjtJQUNGO0FBQ0Y7QUFFQSxJQUFJSSxRQUFRLE9BQU9DLGFBQWEsY0FBY2Ysa0RBQWVBLEdBQUdDLDRDQUFTQTtBQUV6RSxnRkFBZ0Y7QUFDaEYsWUFBWTtBQUNaLFNBQVNlLFVBQVVDLENBQUMsRUFBRUMsQ0FBQztJQUNyQixJQUFJRCxNQUFNQyxHQUFHO1FBQ1gsT0FBTztJQUNUO0lBQ0EsSUFBSSxPQUFPRCxNQUFNLE9BQU9DLEdBQUc7UUFDekIsT0FBTztJQUNUO0lBQ0EsSUFBSSxPQUFPRCxNQUFNLGNBQWNB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MENBQWEsQ0FBQyxJQUFPO1lBQ3BDK0MsV0FBVzBCO1lBQ1h4QixVQUFVeUI7UUFDWixJQUFJO1FBQUNEO1FBQWFDO0tBQVc7SUFDN0IsTUFBTWEsaUJBQWlCdkYsMENBQWEsQ0FBQztRQUNuQyxNQUFNd0YsZ0JBQWdCO1lBQ3BCQyxVQUFVN0M7WUFDVjhDLE1BQU07WUFDTkMsS0FBSztRQUNQO1FBQ0EsSUFBSSxDQUFDN0MsU0FBU0csUUFBUSxFQUFFO1lBQ3RCLE9BQU91QztRQUNUO1FBQ0EsTUFBTS9CLElBQUl0QixXQUFXVyxTQUFTRyxRQUFRLEVBQUVLLEtBQUtHLENBQUM7UUFDOUMsTUFBTUMsSUFBSXZCLFdBQVdXLFNBQVNHLFFBQVEsRUFBRUssS0FBS0ksQ0FBQztRQUM5QyxJQUFJUCxXQUFXO1lBQ2IsT0FBTztnQkFDTCxHQUFHcUMsYUFBYTtnQkFDaEJyQyxXQUFXLGVBQWVNLElBQUksU0FBU0MsSUFBSTtnQkFDM0MsR0FBSTdCLE9BQU9pQixTQUFTRyxRQUFRLEtBQUssT0FBTztvQkFDdEMyQyxZQUFZO2dCQUNkLENBQUM7WUFDSDtRQUNGO1FBQ0EsT0FBTztZQUNMSCxVQUFVN0M7WUFDVjhDLE1BQU1qQztZQUNOa0MsS0FBS2pDO1FBQ1A7SUFDRixHQUFHO1FBQUNkO1FBQVVPO1FBQVdMLFNBQVNHLFFBQVE7UUFBRUssS0FBS0csQ0FBQztRQUFFSCxLQUFLSSxDQUFDO0tBQUM7SUFDM0QsT0FBTzFELDBDQUFhLENBQUMsSUFBTztZQUMxQixHQUFHc0QsSUFBSTtZQUNQeUI7WUFDQU07WUFDQXZDO1lBQ0F5QztRQUNGLElBQUk7UUFBQ2pDO1FBQU15QjtRQUFRTTtRQUFNdkM7UUFBVXlDO0tBQWU7QUFDcEQ7QUFFOEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9vcGVuLXByby1uZXh0Ly4vbm9kZV9tb2R1bGVzL0BmbG9hdGluZy11aS9yZWFjdC1kb20vZGlzdC9mbG9hdGluZy11aS5yZWFjdC1kb20ubWpzP2M3OWQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgYXJyb3cgYXMgYXJyb3ckMSwgY29tcHV0ZVBvc2l0aW9uIH0gZnJvbSAnQGZsb2F0aW5nLXVpL2RvbSc7XG5leHBvcnQgeyBhdXRvUGxhY2VtZW50LCBhdXRvVXBkYXRlLCBjb21wdXRlUG9zaXRpb24sIGRldGVjdE92ZXJmbG93LCBmbGlwLCBnZXRPdmVyZmxvd0FuY2VzdG9ycywgaGlkZSwgaW5saW5lLCBsaW1pdFNoaWZ0LCBvZmZzZXQsIHBsYXRmb3JtLCBzaGlmdCwgc2l6ZSB9IGZyb20gJ0BmbG9hdGluZy11aS9kb20nO1xuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgdXNlTGF5b3V0RWZmZWN0LCB1c2VFZmZlY3QgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgKiBhcyBSZWFjdERPTSBmcm9tICdyZWFjdC1kb20nO1xuXG4vKipcbiAqIFByb3ZpZGVzIGRhdGEgdG8gcG9zaXRpb24gYW4gaW5uZXIgZWxlbWVudCBvZiB0aGUgZmxvYXRpbmcgZWxlbWVudCBzbyB0aGF0IGl0XG4gKiBhcHBlYXJzIGNlbnRlcmVkIHRvIHRoZSByZWZlcmVuY2UgZWxlbWVudC5cbiAqIFRoaXMgd3JhcHMgdGhlIGNvcmUgYGFycm93YCBtaWRkbGV3YXJlIHRvIGFsbG93IFJlYWN0IHJlZnMgYXMgdGhlIGVsZW1lbnQuXG4gKiBAc2VlIGh0dHBzOi8vZmxvYXRpbmctdWkuY29tL2RvY3MvYXJyb3dcbiAqL1xuY29uc3QgYXJyb3cgPSBvcHRpb25zID0+IHtcbiAgZnVuY3Rpb24gaXNSZWYodmFsdWUpIHtcbiAgICByZXR1cm4ge30uaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgJ2N1cnJlbnQnKTtcbiAgfVxuICByZXR1cm4ge1xuICAgIG5hbWU6ICdhcnJvdycsXG4gICAgb3B0aW9ucyxcbiAgICBmbihzdGF0ZSkge1xuICAgICAgY29uc3Qge1xuICAgICAgICBlbGVtZW50LFxuICAgICAgICBwYWRkaW5nXG4gICAgICB9ID0gdHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicgPyBvcHRpb25zKHN0YXRlKSA6IG9wdGlvbnM7XG4gICAgICBpZiAoZWxlbWVudCAmJiBpc1JlZihlbGVtZW50KSkge1xuICAgICAgICBpZiAoZWxlbWVudC5jdXJyZW50ICE9IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gYXJyb3ckMSh7XG4gICAgICAgICAgICBlbGVtZW50OiBlbGVtZW50LmN1cnJlbnQsXG4gICAgICAgICAgICBwYWRkaW5nXG4gICAgICAgICAgfSkuZm4oc3RhdGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7fTtcbiAgICAgIH1cbiAgICAgIGlmIChlbGVtZW50KSB7XG4gICAgICAgIHJldHVybiBhcnJvdyQxKHtcbiAgICAgICAgICBlbGVtZW50LFxuICAgICAgICAgIHBhZGRpbmdcbiAgICAgICAgfSkuZm4oc3RhdGUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHt9O1xuICAgIH1cbiAgfTtcbn07XG5cbnZhciBpbmRleCA9IHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgPyB1c2VMYXlvdXRFZmZlY3QgOiB1c2VFZmZlY3Q7XG5cbi8vIEZvcmsgb2YgYGZhc3QtZGVlcC1lcXVhbGAgdGhhdCBvbmx5IGRvZXMgdGhlIGNvbXBhcmlzb25zIHdlIG5lZWQgYW5kIGNvbXBhcmVzXG4vLyBmdW5jdGlvbnNcbmZ1bmN0aW9uIGRlZXBFcXVhbChhLCBiKSB7XG4gIGlmIChhID09PSBiKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKHR5cGVvZiBhICE9PSB0eXBlb2YgYikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAodHlwZW9mIGEgPT09ICdmdW5jdGlvbicgJiYgYS50b1N0cmluZygpID09PSBiLnRvU3RyaW5nKCkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBsZXQgbGVuZ3RoO1xuICBsZXQgaTtcbiAgbGV0IGtleXM7XG4gIGlmIChhICYmIGIgJiYgdHlwZW9mIGEgPT09ICdvYmplY3QnKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoYSkpIHtcbiAgICAgIGxlbmd0aCA9IGEubGVuZ3RoO1xuICAgICAgaWYgKGxlbmd0aCAhPT0gYi5sZW5ndGgpIHJldHVybiBmYWxzZTtcbiAgICAgIGZvciAoaSA9IGxlbmd0aDsgaS0tICE9PSAwOykge1xuICAgICAgICBpZiAoIWRlZXBFcXVhbChhW2ldLCBiW2ldKSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGtleXMgPSBPYmplY3Qua2V5cyhhKTtcbiAgICBsZW5ndGggPSBrZXlzLmxlbmd0aDtcbiAgICBpZiAobGVuZ3RoICE9PSBPYmplY3Qua2V5cyhiKS5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZm9yIChpID0gbGVuZ3RoOyBpLS0gIT09IDA7KSB7XG4gICAgICBpZiAoIXt9Lmhhc093blByb3BlcnR5LmNhbGwoYiwga2V5c1tpXSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGkgPSBsZW5ndGg7IGktLSAhPT0gMDspIHtcbiAgICAgIGNvbnN0IGtleSA9IGtleXNbaV07XG4gICAgICBpZiAoa2V5ID09PSAnX293bmVyJyAmJiBhLiQkdHlwZW9mKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKCFkZWVwRXF1YWwoYVtrZXldLCBiW2tleV0pKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvLyBiaW9tZS1pZ25vcmUgbGludC9zdXNwaWNpb3VzL25vU2VsZkNvbXBhcmU6IGluIHNvdXJjZVxuICByZXR1cm4gYSAhPT0gYSAmJiBiICE9PSBiO1xufVxuXG5mdW5jdGlvbiBnZXREUFIoZWxlbWVudCkge1xuICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gMTtcbiAgfVxuICBjb25zdCB3aW4gPSBlbGVtZW50Lm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXcgfHwgd2luZG93O1xuICByZXR1cm4gd2luLmRldmljZVBpeGVsUmF0aW8gfHwgMTtcbn1cblxuZnVuY3Rpb24gcm91bmRCeURQUihlbGVtZW50LCB2YWx1ZSkge1xuICBjb25zdCBkcHIgPSBnZXREUFIoZWxlbWVudCk7XG4gIHJldHVybiBNYXRoLnJvdW5kKHZhbHVlICogZHByKSAvIGRwcjtcbn1cblxuZnVuY3Rpb24gdXNlTGF0ZXN0UmVmKHZhbHVlKSB7XG4gIGNvbnN0IHJlZiA9IFJlYWN0LnVzZVJlZih2YWx1ZSk7XG4gIGluZGV4KCgpID0+IHtcbiAgICByZWYuY3VycmVudCA9IHZhbHVlO1xuICB9KTtcbiAgcmV0dXJuIHJlZjtcbn1cblxuLyoqXG4gKiBQcm92aWRlcyBkYXRhIHRvIHBvc2l0aW9uIGEgZmxvYXRpbmcgZWxlbWVudC5cbiAqIEBzZWUgaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy91c2VGbG9hdGluZ1xuICovXG5mdW5jdGlvbiB1c2VGbG9hdGluZyhvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICBvcHRpb25zID0ge307XG4gIH1cbiAgY29uc3Qge1xuICAgIHBsYWNlbWVudCA9ICdib3R0b20nLFxuICAgIHN0cmF0ZWd5ID0gJ2Fic29sdXRlJyxcbiAgICBtaWRkbGV3YXJlID0gW10sXG4gICAgcGxhdGZvcm0sXG4gICAgZWxlbWVudHM6IHtcbiAgICAgIHJlZmVyZW5jZTogZXh0ZXJuYWxSZWZlcmVuY2UsXG4gICAgICBmbG9hdGluZzogZXh0ZXJuYWxGbG9hdGluZ1xuICAgIH0gPSB7fSxcbiAgICB0cmFuc2Zvcm0gPSB0cnVlLFxuICAgIHdoaWxlRWxlbWVudHNNb3VudGVkLFxuICAgIG9wZW5cbiAgfSA9IG9wdGlvbnM7XG4gIGNvbnN0IFtkYXRhLCBzZXREYXRhXSA9IFJlYWN0LnVzZVN0YXRlKHtcbiAgICB4OiAwLFxuICAgIHk6IDAsXG4gICAgc3RyYXRlZ3ksXG4gICAgcGxhY2VtZW50LFxuICAgIG1pZGRsZXdhcmVEYXRhOiB7fSxcbiAgICBpc1Bvc2l0aW9uZWQ6IGZhbHNlXG4gIH0pO1xuICBjb25zdCBbbGF0ZXN0TWlkZGxld2FyZSwgc2V0TGF0ZXN0TWlkZGxld2FyZV0gPSBSZWFjdC51c2VTdGF0ZShtaWRkbGV3YXJlKTtcbiAgaWYgKCFkZWVwRXF1YWwobGF0ZXN0TWlkZGxld2FyZSwgbWlkZGxld2FyZSkpIHtcbiAgICBzZXRMYXRlc3RNaWRkbGV3YXJlKG1pZGRsZXdhcmUpO1xuICB9XG4gIGNvbnN0IFtfcmVmZXJlbmNlLCBfc2V0UmVmZXJlbmNlXSA9IFJlYWN0LnVzZVN0YXRlKG51bGwpO1xuICBjb25zdCBbX2Zsb2F0aW5nLCBfc2V0RmxvYXRpbmddID0gUmVhY3QudXNlU3RhdGUobnVsbCk7XG4gIGNvbnN0IHNldFJlZmVyZW5jZSA9IFJlYWN0LnVzZUNhbGxiYWNrKG5vZGUgPT4ge1xuICAgIGlmIChub2RlICE9PSByZWZlcmVuY2VSZWYuY3VycmVudCkge1xuICAgICAgcmVmZXJlbmNlUmVmLmN1cnJlbnQgPSBub2RlO1xuICAgICAgX3NldFJlZmVyZW5jZShub2RlKTtcbiAgICB9XG4gIH0sIFtdKTtcbiAgY29uc3Qgc2V0RmxvYXRpbmcgPSBSZWFjdC51c2VDYWxsYmFjayhub2RlID0+IHtcbiAgICBpZiAobm9kZSAhPT0gZmxvYXRpbmdSZWYuY3VycmVudCkge1xuICAgICAgZmxvYXRpbmdSZWYuY3VycmVudCA9IG5vZGU7XG4gICAgICBfc2V0RmxvYXRpbmcobm9kZSk7XG4gICAgfVxuICB9LCBbXSk7XG4gIGNvbnN0IHJlZmVyZW5jZUVsID0gZXh0ZXJuYWxSZWZlcmVuY2UgfHwgX3JlZmVyZW5jZTtcbiAgY29uc3QgZmxvYXRpbmdFbCA9IGV4dGVybmFsRmxvYXRpbmcgfHwgX2Zsb2F0aW5nO1xuICBjb25zdCByZWZlcmVuY2VSZWYgPSBSZWFjdC51c2VSZWYobnVsbCk7XG4gIGNvbnN0IGZsb2F0aW5nUmVmID0gUmVhY3QudXNlUmVmKG51bGwpO1xuICBjb25zdCBkYXRhUmVmID0gUmVhY3QudXNlUmVmKGRhdGEpO1xuICBjb25zdCBoYXNXaGlsZUVsZW1lbnRzTW91bnRlZCA9IHdoaWxlRWxlbWVudHNNb3VudGVkICE9IG51bGw7XG4gIGNvbnN0IHdoaWxlRWxlbWVudHNNb3VudGVkUmVmID0gdXNlTGF0ZXN0UmVmKHdoaWxlRWxlbWVudHNNb3VudGVkKTtcbiAgY29uc3QgcGxhdGZvcm1SZWYgPSB1c2VMYXRlc3RSZWYocGxhdGZvcm0pO1xuICBjb25zdCB1cGRhdGUgPSBSZWFjdC51c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgaWYgKCFyZWZlcmVuY2VSZWYuY3VycmVudCB8fCAhZmxvYXRpbmdSZWYuY3VycmVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBjb25maWcgPSB7XG4gICAgICBwbGFjZW1lbnQsXG4gICAgICBzdHJhdGVneSxcbiAgICAgIG1pZGRsZXdhcmU6IGxhdGVzdE1pZGRsZXdhcmVcbiAgICB9O1xuICAgIGlmIChwbGF0Zm9ybVJlZi5jdXJyZW50KSB7XG4gICAgICBjb25maWcucGxhdGZvcm0gPSBwbGF0Zm9ybVJlZi5jdXJyZW50O1xuICAgIH1cbiAgICBjb21wdXRlUG9zaXRpb24ocmVmZXJlbmNlUmVmLmN1cnJlbnQsIGZsb2F0aW5nUmVmLmN1cnJlbnQsIGNvbmZpZykudGhlbihkYXRhID0+IHtcbiAgICAgIGNvbnN0IGZ1bGxEYXRhID0ge1xuICAgICAgICAuLi5kYXRhLFxuICAgICAgICBpc1Bvc2l0aW9uZWQ6IHRydWVcbiAgICAgIH07XG4gICAgICBpZiAoaXNNb3VudGVkUmVmLmN1cnJlbnQgJiYgIWRlZXBFcXVhbChkYXRhUmVmLmN1cnJlbnQsIGZ1bGxEYXRhKSkge1xuICAgICAgICBkYXRhUmVmLmN1cnJlbnQgPSBmdWxsRGF0YTtcbiAgICAgICAgUmVhY3RET00uZmx1c2hTeW5jKCgpID0+IHtcbiAgICAgICAgICBzZXREYXRhKGZ1bGxEYXRhKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0sIFtsYXRlc3RNaWRkbGV3YXJlLCBwbGFjZW1lbnQsIHN0cmF0ZWd5LCBwbGF0Zm9ybVJlZl0pO1xuICBpbmRleCgoKSA9PiB7XG4gICAgaWYgKG9wZW4gPT09IGZhbHNlICYmIGRhdGFSZWYuY3VycmVudC5pc1Bvc2l0aW9uZWQpIHtcbiAgICAgIGRhdGFSZWYuY3VycmVudC5pc1Bvc2l0aW9uZWQgPSBmYWxzZTtcbiAgICAgIHNldERhdGEoZGF0YSA9PiAoe1xuICAgICAgICAuLi5kYXRhLFxuICAgICAgICBpc1Bvc2l0aW9uZWQ6IGZhbHNlXG4gICAgICB9KSk7XG4gICAgfVxuICB9LCBbb3Blbl0pO1xuICBjb25zdCBpc01vdW50ZWRSZWYgPSBSZWFjdC51c2VSZWYoZmFsc2UpO1xuICBpbmRleCgoKSA9PiB7XG4gICAgaXNNb3VudGVkUmVmLmN1cnJlbnQgPSB0cnVlO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBpc01vdW50ZWRSZWYuY3VycmVudCA9IGZhbHNlO1xuICAgIH07XG4gIH0sIFtdKTtcblxuICAvLyBiaW9tZS1pZ25vcmUgbGludC9jb3JyZWN0bmVzcy91c2VFeGhhdXN0aXZlRGVwZW5kZW5jaWVzOiBgaGFzV2hpbGVFbGVtZW50c01vdW50ZWRgIGlzIGludGVudGlvbmFsbHkgaW5jbHVkZWQuXG4gIGluZGV4KCgpID0+IHtcbiAgICBpZiAocmVmZXJlbmNlRWwpIHJlZmVyZW5jZVJlZi5jdXJyZW50ID0gcmVmZXJlbmNlRWw7XG4gICAgaWYgKGZsb2F0aW5nRWwpIGZsb2F0aW5nUmVmLmN1cnJlbnQgPSBmbG9hdGluZ0VsO1xuICAgIGlmIChyZWZlcmVuY2VFbCAmJiBmbG9hdGluZ0VsKSB7XG4gICAgICBpZiAod2hpbGVFbGVtZW50c01vdW50ZWRSZWYuY3VycmVudCkge1xuICAgICAgICByZXR1cm4gd2hpbGVFbGVtZW50c01vdW50ZWRSZWYuY3VycmVudChyZWZlcmVuY2VFbCwgZmxvYXRpbmdFbCwgdXBkYXRlKTtcbiAgICAgIH1cbiAgICAgIHVwZGF0ZSgpO1xuICAgIH1cbiAgfSwgW3JlZmVyZW5jZUVsLCBmbG9hdGluZ0VsLCB1cGRhdGUsIHdoaWxlRWxlbWVudHNNb3VudGVkUmVmLCBoYXNXaGlsZUVsZW1lbnRzTW91bnRlZF0pO1xuICBjb25zdCByZWZzID0gUmVhY3QudXNlTWVtbygoKSA9PiAoe1xuICAgIHJlZmVyZW5jZTogcmVmZXJlbmNlUmVmLFxuICAgIGZsb2F0aW5nOiBmbG9hdGluZ1JlZixcbiAgICBzZXRSZWZlcmVuY2UsXG4gICAgc2V0RmxvYXRpbmdcbiAgfSksIFtzZXRSZWZlcmVuY2UsIHNldEZsb2F0aW5nXSk7XG4gIGNvbnN0IGVsZW1lbnRzID0gUmVhY3QudXNlTWVtbygoKSA9PiAoe1xuICAgIHJlZmVyZW5jZTogcmVmZXJlbmNlRWwsXG4gICAgZmxvYXRpbmc6IGZsb2F0aW5nRWxcbiAgfSksIFtyZWZlcmVuY2VFbCwgZmxvYXRpbmdFbF0pO1xuICBjb25zdCBmbG9hdGluZ1N0eWxlcyA9IFJlYWN0LnVzZU1lbW8oKCkgPT4ge1xuICAgIGNvbnN0IGluaXRpYWxTdHlsZXMgPSB7XG4gICAgICBwb3NpdGlvbjogc3RyYXRlZ3ksXG4gICAgICBsZWZ0OiAwLFxuICAgICAgdG9wOiAwXG4gICAgfTtcbiAgICBpZiAoIWVsZW1lbnRzLmZsb2F0aW5nKSB7XG4gICAgICByZXR1cm4gaW5pdGlhbFN0eWxlcztcbiAgICB9XG4gICAgY29uc3QgeCA9IHJvdW5kQnlEUFIoZWxlbWVudHMuZmxvYXRpbmcsIGRhdGEueCk7XG4gICAgY29uc3QgeSA9IHJvdW5kQnlEUFIoZWxlbWVudHMuZmxvYXRpbmcsIGRhdGEueSk7XG4gICAgaWYgKHRyYW5zZm9ybSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4uaW5pdGlhbFN0eWxlcyxcbiAgICAgICAgdHJhbnNmb3JtOiBcInRyYW5zbGF0ZShcIiArIHggKyBcInB4LCBcIiArIHkgKyBcInB4KVwiLFxuICAgICAgICAuLi4oZ2V0RFBSKGVsZW1lbnRzLmZsb2F0aW5nKSA+PSAxLjUgJiYge1xuICAgICAgICAgIHdpbGxDaGFuZ2U6ICd0cmFuc2Zvcm0nXG4gICAgICAgIH0pXG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgcG9zaXRpb246IHN0cmF0ZWd5LFxuICAgICAgbGVmdDogeCxcbiAgICAgIHRvcDogeVxuICAgIH07XG4gIH0sIFtzdHJhdGVneSwgdHJhbnNmb3JtLCBlbGVtZW50cy5mbG9hdGluZywgZGF0YS54LCBkYXRhLnldKTtcbiAgcmV0dXJuIFJlYWN0LnVzZU1lbW8oKCkgPT4gKHtcbiAgICAuLi5kYXRhLFxuICAgIHVwZGF0ZSxcbiAgICByZWZzLFxuICAgIGVsZW1lbnRzLFxuICAgIGZsb2F0aW5nU3R5bGVzXG4gIH0pLCBbZGF0YSwgdXBkYXRlLCByZWZzLCBlbGVtZW50cywgZmxvYXRpbmdTdHlsZXNdKTtcbn1cblxuZXhwb3J0IHsgYXJyb3csIHVzZUZsb2F0aW5nIH07XG4iXSwibmFtZXMiOlsiYXJyb3ciLCJhcnJvdyQxIiwiY29tcHV0ZVBvc2l0aW9uIiwiYXV0b1BsYWNlbWVudCIsImF1dG9VcGRhdGUiLCJkZXRlY3RPdmVyZmxvdyIsImZsaXAiLCJnZXRPdmVyZmxvd0FuY2VzdG9ycyIsImhpZGUiLCJpbmxpbmUiLCJsaW1pdFNoaWZ0Iiwib2Zmc2V0IiwicGxhdGZvcm0iLCJzaGlmdCIsInNpemUiLCJSZWFjdCIsInVzZUxheW91dEVmZmVjdCIsInVzZUVmZmVjdCIsIlJlYWN0RE9NIiwib3B0aW9ucyIsImlzUmVmIiwidmFsdWUiLCJoYXNPd25Qcm9wZXJ0eSIsImNhbGwiLCJuYW1lIiwiZm4iLCJzdGF0ZSIsImVsZW1lbnQiLCJwYWRkaW5nIiwiY3VycmVudCIsImluZGV4IiwiZG9jdW1lbnQiLCJkZWVwRXF1YWwiLCJhIiwiYiIsInRvU3RyaW5nIiwibGVuZ3RoIiwiaSIsImtleXMiLCJBcnJheSIsImlzQXJyYXkiLCJPYmplY3QiLCJrZXkiLCIkJHR5cGVvZiIsImdldERQUiIsIndpbiIsIm93bmVyRG9jdW1lbnQiLCJkZWZhdWx0VmlldyIsIndpbmRvdyIsImRldmljZVBpeGVsUmF0aW8iLCJyb3VuZEJ5RFBSIiwiZHByIiwiTWF0aCIsInJvdW5kIiwidXNlTGF0ZXN0UmVmIiwicmVmIiwidXNlUmVmIiwidXNlRmxvYXRpbmciLCJwbGFjZW1lbnQiLCJzdHJhdGVneSIsIm1pZGRsZXdhcmUiLCJlbGVtZW50cyIsInJlZmVyZW5jZSIsImV4dGVybmFsUmVmZXJlbmNlIiwiZmxvYXRpbmciLCJleHRlcm5hbEZsb2F0aW5nIiwidHJhbnNmb3JtIiwid2hpbGVFbGVtZW50c01vdW50ZWQiLCJvcGVuIiwiZGF0YSIsInNldERhdGEiLCJ1c2VTdGF0ZSIsIngiLCJ5IiwibWlkZGxld2FyZURhdGEiLCJpc1Bvc2l0aW9uZWQiLCJsYXRlc3RNaWRkbGV3YXJlIiwic2V0TGF0ZXN0TWlkZGxld2FyZSIsIl9yZWZlcmVuY2UiLCJfc2V0UmVmZXJlbmNlIiwiX2Zsb2F0aW5nIiwiX3NldEZsb2F0aW5nIiwic2V0UmVmZXJlbmNlIiwidXNlQ2FsbGJhY2siLCJub2RlIiwicmVmZXJlbmNlUmVmIiwic2V0RmxvYXRpbmciLCJmbG9hdGluZ1JlZiIsInJlZmVyZW5jZUVsIiwiZmxvYXRpbmdFbCIsImRhdGFSZWYiLCJoYXNXaGlsZUVsZW1lbnRzTW91bnRlZCIsIndoaWxlRWxlbWVudHNNb3VudGVkUmVmIiwicGxhdGZvcm1SZWYiLCJ1cGRhdGUiLCJjb25maWciLCJ0aGVuIiwiZnVsbERhdGEiLCJpc01vdW50ZWRSZWYiLCJmbHVzaFN5bmMiLCJyZWZzIiwidXNlTWVtbyIsImZsb2F0aW5nU3R5bGVzIiwiaW5pdGlhbFN0eWxlcyIsInBvc2l0aW9uIiwibGVmdCIsInRvcCIsIndpbGxDaGFuZ2UiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@floating-ui/react-dom/dist/floating-ui.react-dom.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@floating-ui/react/dist/floating-ui.react.mjs":
/*!********************************************************************!*\
  !*** ./node_modules/@floating-ui/react/dist/floating-ui.react.mjs ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("var react__WEBPACK_IMPORTED_MODULE_0___namespace_cache;\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Composite: () => (/* binding */ Composite),\n/* harmony export */   CompositeItem: () => (/* binding */ CompositeItem),\n/* harmony export */   FloatingArrow: () => (/* binding */ FloatingArrow),\n/* harmony export */   FloatingDelayGroup: () => (/* binding */ FloatingDelayGroup),\n/* harmony export */   FloatingFocusManager: () => (/* binding */ FloatingFocusManager),\n/* harmony export */   FloatingList: () => (/* binding */ FloatingList),\n/* harmony export */   FloatingNode: () => (/* binding */ FloatingNode),\n/* harmony export */   FloatingOverlay: () => (/* binding */ FloatingOverlay),\n/* harmony export */   FloatingPortal: () => (/* binding */ FloatingPortal),\n/* harmony export */   FloatingTree: () => (/* binding */ FloatingTree),\n/* harmony export */   arrow: () => (/* reexport safe */ _floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_1__.arrow),\n/* harmony export */   autoPlacement: () => (/* reexport safe */ _floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_2__.autoPlacement),\n/* harmony export */   autoUpdate: () => (/* reexport safe */ _floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_2__.autoUpdate),\n/* harmony export */   computePosition: () => (/* reexport safe */ _floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_2__.computePosition),\n/* harmony export */   detectOverflow: () => (/* reexport safe */ _floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_3__.detectOverflow),\n/* harmony export */   flip: () => (/* reexport safe */ _floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_2__.flip),\n/* harmony export */   getOverflowAncestors: () => (/* reexport safe */ _floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_4__.getOverflowAncestors),\n/* harmony export */   hide: () => (/* reexport safe */ _floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_2__.hide),\n/* harmony export */   inline: () => (/* reexport safe */ _floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_2__.inline),\n/* harmony export */   inner: () => (/* binding */ inner),\n/* harmony export */   limitShift: () => (/* reexport safe */ _floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_2__.limitShift),\n/* harmony export */   offset: () => (/* reexport safe */ _floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_3__.offset),\n/* harmony export */   platform: () => (/* reexport safe */ _floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_2__.platform),\n/* harmony export */   safePolygon: () => (/* binding */ safePolygon),\n/* harmony export */   shift: () => (/* reexport safe */ _floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_2__.shift),\n/* harmony export */   size: () => (/* reexport safe */ _floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_2__.size),\n/* harmony export */   useClick: () => (/* binding */ useClick),\n/* harmony export */   useClientPoint: () => (/* binding */ useClientPoint),\n/* harmony export */   useDelayGroup: () => (/* binding */ useDelayGroup),\n/* harmony export */   useDelayGroupContext: () => (/* binding */ useDelayGroupContext),\n/* harmony export */   useDismiss: () => (/* binding */ useDismiss),\n/* harmony export */   useFloating: () => (/* binding */ useFloating),\n/* harmony export */   useFloatingNodeId: () => (/* binding */ useFloatingNodeId),\n/* harmony export */   useFloatingParentNodeId: () => (/* binding */ useFloatingParentNodeId),\n/* harmony export */   useFloatingPortalNode: () => (/* binding */ useFloatingPortalNode),\n/* harmony export */   useFloatingTree: () => (/* binding */ useFloatingTree),\n/* harmony export */   useFocus: () => (/* binding */ useFocus),\n/* harmony export */   useHover: () => (/* binding */ useHover),\n/* harmony export */   useId: () => (/* binding */ useId),\n/* harmony export */   useInnerOffset: () => (/* binding */ useInnerOffset),\n/* harmony export */   useInteractions: () => (/* binding */ useInteractions),\n/* harmony export */   useListItem: () => (/* binding */ useListItem),\n/* harmony export */   useListNavigation: () => (/* binding */ useListNavigation),\n/* harmony export */   useMergeRefs: () => (/* binding */ useMergeRefs),\n/* harmony export */   useRole: () => (/* binding */ useRole),\n/* harmony export */   useTransitionStatus: () => (/* binding */ useTransitionStatus),\n/* harmony export */   useTransitionStyles: () => (/* binding */ useTransitionStyles),\n/* harmony export */   useTypeahead: () => (/* binding */ useTypeahead)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var _floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @floating-ui/react/utils */ \"(ssr)/./node_modules/@floating-ui/react/dist/floating-ui.react.utils.mjs\");\n/* harmony import */ var _floating_ui_utils__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @floating-ui/utils */ \"(ssr)/./node_modules/@floating-ui/utils/dist/floating-ui.utils.mjs\");\n/* harmony import */ var _floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @floating-ui/react-dom */ \"(ssr)/./node_modules/@floating-ui/dom/dist/floating-ui.dom.mjs\");\n/* harmony import */ var _floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @floating-ui/utils/dom */ \"(ssr)/./node_modules/@floating-ui/utils/dist/floating-ui.utils.dom.mjs\");\n/* harmony import */ var _floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @floating-ui/react-dom */ \"(ssr)/./node_modules/@floating-ui/react-dom/dist/floating-ui.react-dom.mjs\");\n/* harmony import */ var _floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @floating-ui/react-dom */ \"(ssr)/./node_modules/@floating-ui/core/dist/floating-ui.core.mjs\");\n/* harmony import */ var tabbable__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! tabbable */ \"(ssr)/./node_modules/tabbable/dist/index.esm.js\");\n/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! react-dom */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react-dom.js\");\n\n\n\n\n\n\n\n\n\n/**\n * Merges an array of refs into a single memoized callback ref or `null`.\n * @see https://floating-ui.com/docs/react-utils#usemergerefs\n */ function useMergeRefs(refs) {\n    // biome-ignore lint/correctness/useExhaustiveDependencies: intentional\n    return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>{\n        if (refs.every((ref)=>ref == null)) {\n            return null;\n        }\n        return (value)=>{\n            refs.forEach((ref)=>{\n                if (typeof ref === \"function\") {\n                    ref(value);\n                } else if (ref != null) {\n                    ref.current = value;\n                }\n            });\n        };\n    }, refs);\n}\n// `toString()` prevents bundlers from trying to `import { useInsertionEffect } from 'react'`\nconst useInsertionEffect = /*#__PURE__*/ (react__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (react__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(react__WEBPACK_IMPORTED_MODULE_0__, 2)))[/*#__PURE__*/ \"useInsertionEffect\".toString()];\nconst useSafeInsertionEffect = useInsertionEffect || ((fn)=>fn());\nfunction useEffectEvent(callback) {\n    const ref = react__WEBPACK_IMPORTED_MODULE_0__.useRef(()=>{\n        if (true) {\n            throw new Error(\"Cannot call an event handler while rendering.\");\n        }\n    });\n    useSafeInsertionEffect(()=>{\n        ref.current = callback;\n    });\n    return react__WEBPACK_IMPORTED_MODULE_0__.useCallback(function() {\n        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n            args[_key] = arguments[_key];\n        }\n        return ref.current == null ? void 0 : ref.current(...args);\n    }, []);\n}\nconst ARROW_UP = \"ArrowUp\";\nconst ARROW_DOWN = \"ArrowDown\";\nconst ARROW_LEFT = \"ArrowLeft\";\nconst ARROW_RIGHT = \"ArrowRight\";\nfunction isDifferentRow(index, cols, prevRow) {\n    return Math.floor(index / cols) !== prevRow;\n}\nfunction isIndexOutOfBounds(listRef, index) {\n    return index < 0 || index >= listRef.current.length;\n}\nfunction getMinIndex(listRef, disabledIndices) {\n    return findNonDisabledIndex(listRef, {\n        disabledIndices\n    });\n}\nfunction getMaxIndex(listRef, disabledIndices) {\n    return findNonDisabledIndex(listRef, {\n        decrement: true,\n        startingIndex: listRef.current.length,\n        disabledIndices\n    });\n}\nfunction findNonDisabledIndex(listRef, _temp) {\n    let { startingIndex = -1, decrement = false, disabledIndices, amount = 1 } = _temp === void 0 ? {} : _temp;\n    const list = listRef.current;\n    const isDisabledIndex = disabledIndices ? (index)=>disabledIndices.includes(index) : (index)=>{\n        const element = list[index];\n        return element == null || element.hasAttribute(\"disabled\") || element.getAttribute(\"aria-disabled\") === \"true\";\n    };\n    let index = startingIndex;\n    do {\n        index += decrement ? -amount : amount;\n    }while (index >= 0 && index <= list.length - 1 && isDisabledIndex(index));\n    return index;\n}\nfunction getGridNavigatedIndex(elementsRef, _ref) {\n    let { event, orientation, loop, cols, disabledIndices, minIndex, maxIndex, prevIndex, stopEvent: stop = false } = _ref;\n    let nextIndex = prevIndex;\n    if (event.key === ARROW_UP) {\n        stop && (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.stopEvent)(event);\n        if (prevIndex === -1) {\n            nextIndex = maxIndex;\n        } else {\n            nextIndex = findNonDisabledIndex(elementsRef, {\n                startingIndex: nextIndex,\n                amount: cols,\n                decrement: true,\n                disabledIndices\n            });\n            if (loop && (prevIndex - cols < minIndex || nextIndex < 0)) {\n                const col = prevIndex % cols;\n                const maxCol = maxIndex % cols;\n                const offset = maxIndex - (maxCol - col);\n                if (maxCol === col) {\n                    nextIndex = maxIndex;\n                } else {\n                    nextIndex = maxCol > col ? offset : offset - cols;\n                }\n            }\n        }\n        if (isIndexOutOfBounds(elementsRef, nextIndex)) {\n            nextIndex = prevIndex;\n        }\n    }\n    if (event.key === ARROW_DOWN) {\n        stop && (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.stopEvent)(event);\n        if (prevIndex === -1) {\n            nextIndex = minIndex;\n        } else {\n            nextIndex = findNonDisabledIndex(elementsRef, {\n                startingIndex: prevIndex,\n                amount: cols,\n                disabledIndices\n            });\n            if (loop && prevIndex + cols > maxIndex) {\n                nextIndex = findNonDisabledIndex(elementsRef, {\n                    startingIndex: prevIndex % cols - cols,\n                    amount: cols,\n                    disabledIndices\n                });\n            }\n        }\n        if (isIndexOutOfBounds(elementsRef, nextIndex)) {\n            nextIndex = prevIndex;\n        }\n    }\n    // Remains on the same row/column.\n    if (orientation === \"both\") {\n        const prevRow = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_7__.floor)(prevIndex / cols);\n        if (event.key === ARROW_RIGHT) {\n            stop && (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.stopEvent)(event);\n            if (prevIndex % cols !== cols - 1) {\n                nextIndex = findNonDisabledIndex(elementsRef, {\n                    startingIndex: prevIndex,\n                    disabledIndices\n                });\n                if (loop && isDifferentRow(nextIndex, cols, prevRow)) {\n                    nextIndex = findNonDisabledIndex(elementsRef, {\n                        startingIndex: prevIndex - prevIndex % cols - 1,\n                        disabledIndices\n                    });\n                }\n            } else if (loop) {\n                nextIndex = findNonDisabledIndex(elementsRef, {\n                    startingIndex: prevIndex - prevIndex % cols - 1,\n                    disabledIndices\n                });\n            }\n            if (isDifferentRow(nextIndex, cols, prevRow)) {\n                nextIndex = prevIndex;\n            }\n        }\n        if (event.key === ARROW_LEFT) {\n            stop && (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.stopEvent)(event);\n            if (prevIndex % cols !== 0) {\n                nextIndex = findNonDisabledIndex(elementsRef, {\n                    startingIndex: prevIndex,\n                    disabledIndices,\n                    decrement: true\n                });\n                if (loop && isDifferentRow(nextIndex, cols, prevRow)) {\n                    nextIndex = findNonDisabledIndex(elementsRef, {\n                        startingIndex: prevIndex + (cols - prevIndex % cols),\n                        decrement: true,\n                        disabledIndices\n                    });\n                }\n            } else if (loop) {\n                nextIndex = findNonDisabledIndex(elementsRef, {\n                    startingIndex: prevIndex + (cols - prevIndex % cols),\n                    decrement: true,\n                    disabledIndices\n                });\n            }\n            if (isDifferentRow(nextIndex, cols, prevRow)) {\n                nextIndex = prevIndex;\n            }\n        }\n        const lastRow = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_7__.floor)(maxIndex / cols) === prevRow;\n        if (isIndexOutOfBounds(elementsRef, nextIndex)) {\n            if (loop && lastRow) {\n                nextIndex = event.key === ARROW_LEFT ? maxIndex : findNonDisabledIndex(elementsRef, {\n                    startingIndex: prevIndex - prevIndex % cols - 1,\n                    disabledIndices\n                });\n            } else {\n                nextIndex = prevIndex;\n            }\n        }\n    }\n    return nextIndex;\n}\n/** For each cell index, gets the item index that occupies that cell */ function buildCellMap(sizes, cols, dense) {\n    const cellMap = [];\n    let startIndex = 0;\n    sizes.forEach((_ref2, index)=>{\n        let { width, height } = _ref2;\n        if (width > cols) {\n            if (true) {\n                throw new Error(\"[Floating UI]: Invalid grid - item width at index \" + index + \" is greater than grid columns\");\n            }\n        }\n        let itemPlaced = false;\n        if (dense) {\n            startIndex = 0;\n        }\n        while(!itemPlaced){\n            const targetCells = [];\n            for(let i = 0; i < width; i++){\n                for(let j = 0; j < height; j++){\n                    targetCells.push(startIndex + i + j * cols);\n                }\n            }\n            if (startIndex % cols + width <= cols && targetCells.every((cell)=>cellMap[cell] == null)) {\n                targetCells.forEach((cell)=>{\n                    cellMap[cell] = index;\n                });\n                itemPlaced = true;\n            } else {\n                startIndex++;\n            }\n        }\n    });\n    // convert into a non-sparse array\n    return [\n        ...cellMap\n    ];\n}\n/** Gets cell index of an item's corner or -1 when index is -1. */ function getCellIndexOfCorner(index, sizes, cellMap, cols, corner) {\n    if (index === -1) return -1;\n    const firstCellIndex = cellMap.indexOf(index);\n    switch(corner){\n        case \"tl\":\n            return firstCellIndex;\n        case \"tr\":\n            return firstCellIndex + sizes[index].width - 1;\n        case \"bl\":\n            return firstCellIndex + (sizes[index].height - 1) * cols;\n        case \"br\":\n            return cellMap.lastIndexOf(index);\n    }\n}\n/** Gets all cell indices that correspond to the specified indices */ function getCellIndices(indices, cellMap) {\n    return cellMap.flatMap((index, cellIndex)=>indices.includes(index) ? [\n            cellIndex\n        ] : []);\n}\nlet rafId = 0;\nfunction enqueueFocus(el, options) {\n    if (options === void 0) {\n        options = {};\n    }\n    const { preventScroll = false, cancelPrevious = true, sync = false } = options;\n    cancelPrevious && cancelAnimationFrame(rafId);\n    const exec = ()=>el == null ? void 0 : el.focus({\n            preventScroll\n        });\n    if (sync) {\n        exec();\n    } else {\n        rafId = requestAnimationFrame(exec);\n    }\n}\nvar index = typeof document !== \"undefined\" ? react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect : react__WEBPACK_IMPORTED_MODULE_0__.useEffect;\nfunction sortByDocumentPosition(a, b) {\n    const position = a.compareDocumentPosition(b);\n    if (position & Node.DOCUMENT_POSITION_FOLLOWING || position & Node.DOCUMENT_POSITION_CONTAINED_BY) {\n        return -1;\n    }\n    if (position & Node.DOCUMENT_POSITION_PRECEDING || position & Node.DOCUMENT_POSITION_CONTAINS) {\n        return 1;\n    }\n    return 0;\n}\nfunction areMapsEqual(map1, map2) {\n    if (map1.size !== map2.size) {\n        return false;\n    }\n    for (const [key, value] of map1.entries()){\n        if (value !== map2.get(key)) {\n            return false;\n        }\n    }\n    return true;\n}\nconst FloatingListContext = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createContext({\n    register: ()=>{},\n    unregister: ()=>{},\n    map: /*#__PURE__*/ new Map(),\n    elementsRef: {\n        current: []\n    }\n});\n/**\n * Provides context for a list of items within the floating element.\n * @see https://floating-ui.com/docs/FloatingList\n */ function FloatingList(_ref) {\n    let { children, elementsRef, labelsRef } = _ref;\n    const [map, setMap] = react__WEBPACK_IMPORTED_MODULE_0__.useState(()=>new Map());\n    const register = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((node)=>{\n        setMap((prevMap)=>new Map(prevMap).set(node, null));\n    }, []);\n    const unregister = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((node)=>{\n        setMap((prevMap)=>{\n            const map = new Map(prevMap);\n            map.delete(node);\n            return map;\n        });\n    }, []);\n    index(()=>{\n        const newMap = new Map(map);\n        const nodes = Array.from(newMap.keys()).sort(sortByDocumentPosition);\n        nodes.forEach((node, index)=>{\n            newMap.set(node, index);\n        });\n        if (!areMapsEqual(map, newMap)) {\n            setMap(newMap);\n        }\n    }, [\n        map\n    ]);\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(FloatingListContext.Provider, {\n        value: react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>({\n                register,\n                unregister,\n                map,\n                elementsRef,\n                labelsRef\n            }), [\n            register,\n            unregister,\n            map,\n            elementsRef,\n            labelsRef\n        ])\n    }, children);\n}\n/**\n * Used to register a list item and its index (DOM position) in the\n * `FloatingList`.\n * @see https://floating-ui.com/docs/FloatingList#uselistitem\n */ function useListItem(_temp) {\n    let { label } = _temp === void 0 ? {} : _temp;\n    const [index$1, setIndex] = react__WEBPACK_IMPORTED_MODULE_0__.useState(null);\n    const componentRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n    const { register, unregister, map, elementsRef, labelsRef } = react__WEBPACK_IMPORTED_MODULE_0__.useContext(FloatingListContext);\n    const ref = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((node)=>{\n        componentRef.current = node;\n        if (index$1 !== null) {\n            elementsRef.current[index$1] = node;\n            if (labelsRef) {\n                var _node$textContent;\n                const isLabelDefined = label !== undefined;\n                labelsRef.current[index$1] = isLabelDefined ? label : (_node$textContent = node == null ? void 0 : node.textContent) != null ? _node$textContent : null;\n            }\n        }\n    }, [\n        index$1,\n        elementsRef,\n        labelsRef,\n        label\n    ]);\n    index(()=>{\n        const node = componentRef.current;\n        if (node) {\n            register(node);\n            return ()=>{\n                unregister(node);\n            };\n        }\n    }, [\n        register,\n        unregister\n    ]);\n    index(()=>{\n        const index = componentRef.current ? map.get(componentRef.current) : null;\n        if (index != null) {\n            setIndex(index);\n        }\n    }, [\n        map\n    ]);\n    return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>({\n            ref,\n            index: index$1 == null ? -1 : index$1\n        }), [\n        index$1,\n        ref\n    ]);\n}\nfunction renderJsx(render, computedProps) {\n    if (typeof render === \"function\") {\n        return render(computedProps);\n    }\n    if (render) {\n        return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.cloneElement(render, computedProps);\n    }\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", computedProps);\n}\nconst CompositeContext = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createContext({\n    activeIndex: 0,\n    onNavigate: ()=>{}\n});\nconst horizontalKeys = [\n    ARROW_LEFT,\n    ARROW_RIGHT\n];\nconst verticalKeys = [\n    ARROW_UP,\n    ARROW_DOWN\n];\nconst allKeys = [\n    ...horizontalKeys,\n    ...verticalKeys\n];\n/**\n * Creates a single tab stop whose items are navigated by arrow keys, which\n * provides list navigation outside of floating element contexts.\n *\n * This is useful to enable navigation of a list of items that arenâ€™t part of a\n * floating element. A menubar is an example of a composite, with each reference\n * element being an item.\n * @see https://floating-ui.com/docs/Composite\n */ const Composite = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(function Composite(_ref, forwardedRef) {\n    let { render, orientation = \"both\", loop = true, cols = 1, disabledIndices = [], activeIndex: externalActiveIndex, onNavigate: externalSetActiveIndex, itemSizes, dense = false, ...props } = _ref;\n    const [internalActiveIndex, internalSetActiveIndex] = react__WEBPACK_IMPORTED_MODULE_0__.useState(0);\n    const activeIndex = externalActiveIndex != null ? externalActiveIndex : internalActiveIndex;\n    const onNavigate = useEffectEvent(externalSetActiveIndex != null ? externalSetActiveIndex : internalSetActiveIndex);\n    const elementsRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef([]);\n    const renderElementProps = render && typeof render !== \"function\" ? render.props : {};\n    const contextValue = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>({\n            activeIndex,\n            onNavigate\n        }), [\n        activeIndex,\n        onNavigate\n    ]);\n    const isGrid = cols > 1;\n    function handleKeyDown(event) {\n        if (!allKeys.includes(event.key)) return;\n        let nextIndex = activeIndex;\n        if (isGrid) {\n            const sizes = itemSizes || Array.from({\n                length: elementsRef.current.length\n            }, ()=>({\n                    width: 1,\n                    height: 1\n                }));\n            // To calculate movements on the grid, we use hypothetical cell indices\n            // as if every item was 1x1, then convert back to real indices.\n            const cellMap = buildCellMap(sizes, cols, dense);\n            const minGridIndex = cellMap.findIndex((index)=>index != null && !disabledIndices.includes(index));\n            // last enabled index\n            const maxGridIndex = cellMap.reduce((foundIndex, index, cellIndex)=>index != null && !(disabledIndices != null && disabledIndices.includes(index)) ? cellIndex : foundIndex, -1);\n            nextIndex = cellMap[getGridNavigatedIndex({\n                current: cellMap.map((itemIndex)=>itemIndex ? elementsRef.current[itemIndex] : null)\n            }, {\n                event,\n                orientation,\n                loop,\n                cols,\n                // treat undefined (empty grid spaces) as disabled indices so we\n                // don't end up in them\n                disabledIndices: getCellIndices([\n                    ...disabledIndices,\n                    undefined\n                ], cellMap),\n                minIndex: minGridIndex,\n                maxIndex: maxGridIndex,\n                prevIndex: getCellIndexOfCorner(activeIndex, sizes, cellMap, cols, // use a corner matching the edge closest to the direction we're\n                // moving in so we don't end up in the same item. Prefer\n                // top/left over bottom/right.\n                event.key === ARROW_DOWN ? \"bl\" : event.key === ARROW_RIGHT ? \"tr\" : \"tl\")\n            })]; // navigated cell will never be nullish\n        }\n        const minIndex = getMinIndex(elementsRef, disabledIndices);\n        const maxIndex = getMaxIndex(elementsRef, disabledIndices);\n        const toEndKeys = {\n            horizontal: [\n                ARROW_RIGHT\n            ],\n            vertical: [\n                ARROW_DOWN\n            ],\n            both: [\n                ARROW_RIGHT,\n                ARROW_DOWN\n            ]\n        }[orientation];\n        const toStartKeys = {\n            horizontal: [\n                ARROW_LEFT\n            ],\n            vertical: [\n                ARROW_UP\n            ],\n            both: [\n                ARROW_LEFT,\n                ARROW_UP\n            ]\n        }[orientation];\n        const preventedKeys = isGrid ? allKeys : ({\n            horizontal: horizontalKeys,\n            vertical: verticalKeys,\n            both: allKeys\n        })[orientation];\n        if (nextIndex === activeIndex && [\n            ...toEndKeys,\n            ...toStartKeys\n        ].includes(event.key)) {\n            if (loop && nextIndex === maxIndex && toEndKeys.includes(event.key)) {\n                nextIndex = minIndex;\n            } else if (loop && nextIndex === minIndex && toStartKeys.includes(event.key)) {\n                nextIndex = maxIndex;\n            } else {\n                nextIndex = findNonDisabledIndex(elementsRef, {\n                    startingIndex: nextIndex,\n                    decrement: toStartKeys.includes(event.key),\n                    disabledIndices\n                });\n            }\n        }\n        if (nextIndex !== activeIndex && !isIndexOutOfBounds(elementsRef, nextIndex)) {\n            event.stopPropagation();\n            if (preventedKeys.includes(event.key)) {\n                event.preventDefault();\n            }\n            onNavigate(nextIndex);\n            // Wait for FocusManager `returnFocus` to execute.\n            queueMicrotask(()=>{\n                enqueueFocus(elementsRef.current[nextIndex]);\n            });\n        }\n    }\n    const computedProps = {\n        ...props,\n        ...renderElementProps,\n        ref: forwardedRef,\n        \"aria-orientation\": orientation === \"both\" ? undefined : orientation,\n        onKeyDown (e) {\n            props.onKeyDown == null || props.onKeyDown(e);\n            renderElementProps.onKeyDown == null || renderElementProps.onKeyDown(e);\n            handleKeyDown(e);\n        }\n    };\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(CompositeContext.Provider, {\n        value: contextValue\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(FloatingList, {\n        elementsRef: elementsRef\n    }, renderJsx(render, computedProps)));\n});\n/**\n * @see https://floating-ui.com/docs/Composite\n */ const CompositeItem = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(function CompositeItem(_ref2, forwardedRef) {\n    let { render, ...props } = _ref2;\n    const renderElementProps = render && typeof render !== \"function\" ? render.props : {};\n    const { activeIndex, onNavigate } = react__WEBPACK_IMPORTED_MODULE_0__.useContext(CompositeContext);\n    const { ref, index } = useListItem();\n    const mergedRef = useMergeRefs([\n        ref,\n        forwardedRef,\n        renderElementProps.ref\n    ]);\n    const isActive = activeIndex === index;\n    const computedProps = {\n        ...props,\n        ...renderElementProps,\n        ref: mergedRef,\n        tabIndex: isActive ? 0 : -1,\n        \"data-active\": isActive ? \"\" : undefined,\n        onFocus (e) {\n            props.onFocus == null || props.onFocus(e);\n            renderElementProps.onFocus == null || renderElementProps.onFocus(e);\n            onNavigate(index);\n        }\n    };\n    return renderJsx(render, computedProps);\n});\nfunction _extends() {\n    _extends = Object.assign ? Object.assign.bind() : function(target) {\n        for(var i = 1; i < arguments.length; i++){\n            var source = arguments[i];\n            for(var key in source){\n                if (Object.prototype.hasOwnProperty.call(source, key)) {\n                    target[key] = source[key];\n                }\n            }\n        }\n        return target;\n    };\n    return _extends.apply(this, arguments);\n}\nlet serverHandoffComplete = false;\nlet count = 0;\nconst genId = ()=>\"floating-ui-\" + count++;\nfunction useFloatingId() {\n    const [id, setId] = react__WEBPACK_IMPORTED_MODULE_0__.useState(()=>serverHandoffComplete ? genId() : undefined);\n    // biome-ignore lint/correctness/useExhaustiveDependencies: intentional\n    index(()=>{\n        if (id == null) {\n            setId(genId());\n        }\n    }, []);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        if (!serverHandoffComplete) {\n            serverHandoffComplete = true;\n        }\n    }, []);\n    return id;\n}\n// `toString()` prevents bundlers from trying to `import { useId } from 'react'`\nconst useReactId = /*#__PURE__*/ (react__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (react__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(react__WEBPACK_IMPORTED_MODULE_0__, 2)))[/*#__PURE__*/ \"useId\".toString()];\n/**\n * Uses React 18's built-in `useId()` when available, or falls back to a\n * slightly less performant (requiring a double render) implementation for\n * earlier React versions.\n * @see https://floating-ui.com/docs/react-utils#useid\n */ const useId = useReactId || useFloatingId;\n/**\n * Renders a pointing arrow triangle.\n * @see https://floating-ui.com/docs/FloatingArrow\n */ const FloatingArrow = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(function FloatingArrow(_ref, ref) {\n    let { context: { placement, elements: { floating }, middlewareData: { arrow } }, width = 14, height = 7, tipRadius = 0, strokeWidth = 0, staticOffset, stroke, d, style: { transform, ...restStyle } = {}, ...rest } = _ref;\n    if (true) {\n        if (!ref) {\n            console.warn(\"Floating UI: The `ref` prop is required for the `FloatingArrow`\", \"component.\");\n        }\n    }\n    const clipPathId = useId();\n    if (!floating) {\n        return null;\n    }\n    // Strokes must be double the border width, this ensures the stroke's width\n    // works as you'd expect.\n    strokeWidth *= 2;\n    const halfStrokeWidth = strokeWidth / 2;\n    const svgX = width / 2 * (tipRadius / -8 + 1);\n    const svgY = height / 2 * tipRadius / 4;\n    const [side, alignment] = placement.split(\"-\");\n    const isRTL = _floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_2__.platform.isRTL(floating);\n    const isCustomShape = !!d;\n    const isVerticalSide = side === \"top\" || side === \"bottom\";\n    const yOffsetProp = staticOffset && alignment === \"end\" ? \"bottom\" : \"top\";\n    let xOffsetProp = staticOffset && alignment === \"end\" ? \"right\" : \"left\";\n    if (staticOffset && isRTL) {\n        xOffsetProp = alignment === \"end\" ? \"left\" : \"right\";\n    }\n    const arrowX = (arrow == null ? void 0 : arrow.x) != null ? staticOffset || arrow.x : \"\";\n    const arrowY = (arrow == null ? void 0 : arrow.y) != null ? staticOffset || arrow.y : \"\";\n    const dValue = d || // biome-ignore lint/style/useTemplate: readability\n    \"M0,0\" + (\" H\" + width) + (\" L\" + (width - svgX) + \",\" + (height - svgY)) + (\" Q\" + width / 2 + \",\" + height + \" \" + svgX + \",\" + (height - svgY)) + \" Z\";\n    const rotation = {\n        top: isCustomShape ? \"rotate(180deg)\" : \"\",\n        left: isCustomShape ? \"rotate(90deg)\" : \"rotate(-90deg)\",\n        bottom: isCustomShape ? \"\" : \"rotate(180deg)\",\n        right: isCustomShape ? \"rotate(-90deg)\" : \"rotate(90deg)\"\n    }[side];\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"svg\", _extends({}, rest, {\n        \"aria-hidden\": true,\n        ref: ref,\n        width: isCustomShape ? width : width + strokeWidth,\n        height: width,\n        viewBox: \"0 0 \" + width + \" \" + (height > width ? height : width),\n        style: {\n            position: \"absolute\",\n            pointerEvents: \"none\",\n            [xOffsetProp]: arrowX,\n            [yOffsetProp]: arrowY,\n            [side]: isVerticalSide || isCustomShape ? \"100%\" : \"calc(100% - \" + strokeWidth / 2 + \"px)\",\n            transform: \"\" + rotation + (transform != null ? transform : \"\"),\n            ...restStyle\n        }\n    }), strokeWidth > 0 && /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"path\", {\n        clipPath: \"url(#\" + clipPathId + \")\",\n        fill: \"none\",\n        stroke: stroke,\n        strokeWidth: strokeWidth + (d ? 0 : 1),\n        d: dValue\n    }), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"path\", {\n        stroke: strokeWidth && !d ? rest.fill : \"none\",\n        d: dValue\n    }), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"clipPath\", {\n        id: clipPathId\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"rect\", {\n        x: -halfStrokeWidth,\n        y: halfStrokeWidth * (isCustomShape ? -1 : 1),\n        width: width + strokeWidth,\n        height: width\n    })));\n});\nfunction createPubSub() {\n    const map = new Map();\n    return {\n        emit (event, data) {\n            var _map$get;\n            (_map$get = map.get(event)) == null || _map$get.forEach((handler)=>handler(data));\n        },\n        on (event, listener) {\n            map.set(event, [\n                ...map.get(event) || [],\n                listener\n            ]);\n        },\n        off (event, listener) {\n            var _map$get2;\n            map.set(event, ((_map$get2 = map.get(event)) == null ? void 0 : _map$get2.filter((l)=>l !== listener)) || []);\n        }\n    };\n}\nconst FloatingNodeContext = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);\nconst FloatingTreeContext = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);\n/**\n * Returns the parent node id for nested floating elements, if available.\n * Returns `null` for top-level floating elements.\n */ const useFloatingParentNodeId = ()=>{\n    var _React$useContext;\n    return ((_React$useContext = react__WEBPACK_IMPORTED_MODULE_0__.useContext(FloatingNodeContext)) == null ? void 0 : _React$useContext.id) || null;\n};\n/**\n * Returns the nearest floating tree context, if available.\n */ const useFloatingTree = ()=>react__WEBPACK_IMPORTED_MODULE_0__.useContext(FloatingTreeContext);\n/**\n * Registers a node into the `FloatingTree`, returning its id.\n * @see https://floating-ui.com/docs/FloatingTree\n */ function useFloatingNodeId(customParentId) {\n    const id = useId();\n    const tree = useFloatingTree();\n    const reactParentId = useFloatingParentNodeId();\n    const parentId = customParentId || reactParentId;\n    index(()=>{\n        const node = {\n            id,\n            parentId\n        };\n        tree == null || tree.addNode(node);\n        return ()=>{\n            tree == null || tree.removeNode(node);\n        };\n    }, [\n        tree,\n        id,\n        parentId\n    ]);\n    return id;\n}\n/**\n * Provides parent node context for nested floating elements.\n * @see https://floating-ui.com/docs/FloatingTree\n */ function FloatingNode(_ref) {\n    let { children, id } = _ref;\n    const parentId = useFloatingParentNodeId();\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(FloatingNodeContext.Provider, {\n        value: react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>({\n                id,\n                parentId\n            }), [\n            id,\n            parentId\n        ])\n    }, children);\n}\n/**\n * Provides context for nested floating elements when they are not children of\n * each other on the DOM.\n * This is not necessary in all cases, except when there must be explicit communication between parent and child floating elements. It is necessary for:\n * - The `bubbles` option in the `useDismiss()` Hook\n * - Nested virtual list navigation\n * - Nested floating elements that each open on hover\n * - Custom communication between parent and child floating elements\n * @see https://floating-ui.com/docs/FloatingTree\n */ function FloatingTree(_ref2) {\n    let { children } = _ref2;\n    const nodesRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef([]);\n    const addNode = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((node)=>{\n        nodesRef.current = [\n            ...nodesRef.current,\n            node\n        ];\n    }, []);\n    const removeNode = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((node)=>{\n        nodesRef.current = nodesRef.current.filter((n)=>n !== node);\n    }, []);\n    const events = react__WEBPACK_IMPORTED_MODULE_0__.useState(()=>createPubSub())[0];\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(FloatingTreeContext.Provider, {\n        value: react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>({\n                nodesRef,\n                addNode,\n                removeNode,\n                events\n            }), [\n            addNode,\n            removeNode,\n            events\n        ])\n    }, children);\n}\nfunction createAttribute(name) {\n    return \"data-floating-ui-\" + name;\n}\nfunction useLatestRef(value) {\n    const ref = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(value);\n    index(()=>{\n        ref.current = value;\n    });\n    return ref;\n}\nconst safePolygonIdentifier = /*#__PURE__*/ createAttribute(\"safe-polygon\");\nfunction getDelay(value, prop, pointerType) {\n    if (pointerType && !(0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.isMouseLikePointerType)(pointerType)) {\n        return 0;\n    }\n    if (typeof value === \"number\") {\n        return value;\n    }\n    return value == null ? void 0 : value[prop];\n}\n/**\n * Opens the floating element while hovering over the reference element, like\n * CSS `:hover`.\n * @see https://floating-ui.com/docs/useHover\n */ function useHover(context, props) {\n    if (props === void 0) {\n        props = {};\n    }\n    const { open, onOpenChange, dataRef, events, elements: { domReference, floating }, refs } = context;\n    const { enabled = true, delay = 0, handleClose = null, mouseOnly = false, restMs = 0, move = true } = props;\n    const tree = useFloatingTree();\n    const parentId = useFloatingParentNodeId();\n    const handleCloseRef = useLatestRef(handleClose);\n    const delayRef = useLatestRef(delay);\n    const pointerTypeRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef();\n    const timeoutRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef();\n    const handlerRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef();\n    const restTimeoutRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef();\n    const blockMouseMoveRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(true);\n    const performedPointerEventsMutationRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(false);\n    const unbindMouseMoveRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(()=>{});\n    const isHoverOpen = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(()=>{\n        var _dataRef$current$open;\n        const type = (_dataRef$current$open = dataRef.current.openEvent) == null ? void 0 : _dataRef$current$open.type;\n        return (type == null ? void 0 : type.includes(\"mouse\")) && type !== \"mousedown\";\n    }, [\n        dataRef\n    ]);\n    // When closing before opening, clear the delay timeouts to cancel it\n    // from showing.\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        if (!enabled) {\n            return;\n        }\n        function onOpenChange(_ref) {\n            let { open } = _ref;\n            if (!open) {\n                clearTimeout(timeoutRef.current);\n                clearTimeout(restTimeoutRef.current);\n                blockMouseMoveRef.current = true;\n            }\n        }\n        events.on(\"openchange\", onOpenChange);\n        return ()=>{\n            events.off(\"openchange\", onOpenChange);\n        };\n    }, [\n        enabled,\n        events\n    ]);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        if (!enabled || !handleCloseRef.current || !open) {\n            return;\n        }\n        function onLeave(event) {\n            if (isHoverOpen()) {\n                onOpenChange(false, event, \"hover\");\n            }\n        }\n        const html = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.getDocument)(floating).documentElement;\n        html.addEventListener(\"mouseleave\", onLeave);\n        return ()=>{\n            html.removeEventListener(\"mouseleave\", onLeave);\n        };\n    }, [\n        floating,\n        open,\n        onOpenChange,\n        enabled,\n        handleCloseRef,\n        isHoverOpen\n    ]);\n    const closeWithDelay = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(function(event, runElseBranch, reason) {\n        if (runElseBranch === void 0) {\n            runElseBranch = true;\n        }\n        if (reason === void 0) {\n            reason = \"hover\";\n        }\n        const closeDelay = getDelay(delayRef.current, \"close\", pointerTypeRef.current);\n        if (closeDelay && !handlerRef.current) {\n            clearTimeout(timeoutRef.current);\n            timeoutRef.current = setTimeout(()=>onOpenChange(false, event, reason), closeDelay);\n        } else if (runElseBranch) {\n            clearTimeout(timeoutRef.current);\n            onOpenChange(false, event, reason);\n        }\n    }, [\n        delayRef,\n        onOpenChange\n    ]);\n    const cleanupMouseMoveHandler = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(()=>{\n        unbindMouseMoveRef.current();\n        handlerRef.current = undefined;\n    }, []);\n    const clearPointerEvents = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(()=>{\n        if (performedPointerEventsMutationRef.current) {\n            const body = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.getDocument)(refs.floating.current).body;\n            body.style.pointerEvents = \"\";\n            body.removeAttribute(safePolygonIdentifier);\n            performedPointerEventsMutationRef.current = false;\n        }\n    }, [\n        refs\n    ]);\n    // Registering the mouse events on the reference directly to bypass React's\n    // delegation system. If the cursor was on a disabled element and then entered\n    // the reference (no gap), `mouseenter` doesn't fire in the delegation system.\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        if (!enabled) {\n            return;\n        }\n        function isClickLikeOpenEvent() {\n            return dataRef.current.openEvent ? [\n                \"click\",\n                \"mousedown\"\n            ].includes(dataRef.current.openEvent.type) : false;\n        }\n        function onMouseEnter(event) {\n            clearTimeout(timeoutRef.current);\n            blockMouseMoveRef.current = false;\n            if (mouseOnly && !(0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.isMouseLikePointerType)(pointerTypeRef.current) || restMs > 0 && getDelay(delayRef.current, \"open\") === 0) {\n                return;\n            }\n            const openDelay = getDelay(delayRef.current, \"open\", pointerTypeRef.current);\n            if (openDelay) {\n                timeoutRef.current = setTimeout(()=>{\n                    onOpenChange(true, event, \"hover\");\n                }, openDelay);\n            } else {\n                onOpenChange(true, event, \"hover\");\n            }\n        }\n        function onMouseLeave(event) {\n            if (isClickLikeOpenEvent()) {\n                return;\n            }\n            unbindMouseMoveRef.current();\n            const doc = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.getDocument)(floating);\n            clearTimeout(restTimeoutRef.current);\n            if (handleCloseRef.current) {\n                // Prevent clearing `onScrollMouseLeave` timeout.\n                if (!open) {\n                    clearTimeout(timeoutRef.current);\n                }\n                handlerRef.current = handleCloseRef.current({\n                    ...context,\n                    tree,\n                    x: event.clientX,\n                    y: event.clientY,\n                    onClose () {\n                        clearPointerEvents();\n                        cleanupMouseMoveHandler();\n                        closeWithDelay(event, true, \"safe-polygon\");\n                    }\n                });\n                const handler = handlerRef.current;\n                doc.addEventListener(\"mousemove\", handler);\n                unbindMouseMoveRef.current = ()=>{\n                    doc.removeEventListener(\"mousemove\", handler);\n                };\n                return;\n            }\n            // Allow interactivity without `safePolygon` on touch devices. With a\n            // pointer, a short close delay is an alternative, so it should work\n            // consistently.\n            const shouldClose = pointerTypeRef.current === \"touch\" ? !(0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.contains)(floating, event.relatedTarget) : true;\n            if (shouldClose) {\n                closeWithDelay(event);\n            }\n        }\n        // Ensure the floating element closes after scrolling even if the pointer\n        // did not move.\n        // https://github.com/floating-ui/floating-ui/discussions/1692\n        function onScrollMouseLeave(event) {\n            if (isClickLikeOpenEvent()) {\n                return;\n            }\n            handleCloseRef.current == null || handleCloseRef.current({\n                ...context,\n                tree,\n                x: event.clientX,\n                y: event.clientY,\n                onClose () {\n                    clearPointerEvents();\n                    cleanupMouseMoveHandler();\n                    closeWithDelay(event);\n                }\n            })(event);\n        }\n        if ((0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_4__.isElement)(domReference)) {\n            const ref = domReference;\n            open && ref.addEventListener(\"mouseleave\", onScrollMouseLeave);\n            floating == null || floating.addEventListener(\"mouseleave\", onScrollMouseLeave);\n            move && ref.addEventListener(\"mousemove\", onMouseEnter, {\n                once: true\n            });\n            ref.addEventListener(\"mouseenter\", onMouseEnter);\n            ref.addEventListener(\"mouseleave\", onMouseLeave);\n            return ()=>{\n                open && ref.removeEventListener(\"mouseleave\", onScrollMouseLeave);\n                floating == null || floating.removeEventListener(\"mouseleave\", onScrollMouseLeave);\n                move && ref.removeEventListener(\"mousemove\", onMouseEnter);\n                ref.removeEventListener(\"mouseenter\", onMouseEnter);\n                ref.removeEventListener(\"mouseleave\", onMouseLeave);\n            };\n        }\n    }, [\n        domReference,\n        floating,\n        enabled,\n        context,\n        mouseOnly,\n        restMs,\n        move,\n        closeWithDelay,\n        cleanupMouseMoveHandler,\n        clearPointerEvents,\n        onOpenChange,\n        open,\n        tree,\n        delayRef,\n        handleCloseRef,\n        dataRef\n    ]);\n    // Block pointer-events of every element other than the reference and floating\n    // while the floating element is open and has a `handleClose` handler. Also\n    // handles nested floating elements.\n    // https://github.com/floating-ui/floating-ui/issues/1722\n    index(()=>{\n        var _handleCloseRef$curre;\n        if (!enabled) {\n            return;\n        }\n        if (open && (_handleCloseRef$curre = handleCloseRef.current) != null && _handleCloseRef$curre.__options.blockPointerEvents && isHoverOpen()) {\n            const body = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.getDocument)(floating).body;\n            body.setAttribute(safePolygonIdentifier, \"\");\n            body.style.pointerEvents = \"none\";\n            performedPointerEventsMutationRef.current = true;\n            if ((0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_4__.isElement)(domReference) && floating) {\n                var _tree$nodesRef$curren;\n                const ref = domReference;\n                const parentFloating = tree == null || (_tree$nodesRef$curren = tree.nodesRef.current.find((node)=>node.id === parentId)) == null || (_tree$nodesRef$curren = _tree$nodesRef$curren.context) == null ? void 0 : _tree$nodesRef$curren.elements.floating;\n                if (parentFloating) {\n                    parentFloating.style.pointerEvents = \"\";\n                }\n                ref.style.pointerEvents = \"auto\";\n                floating.style.pointerEvents = \"auto\";\n                return ()=>{\n                    ref.style.pointerEvents = \"\";\n                    floating.style.pointerEvents = \"\";\n                };\n            }\n        }\n    }, [\n        enabled,\n        open,\n        parentId,\n        floating,\n        domReference,\n        tree,\n        handleCloseRef,\n        isHoverOpen\n    ]);\n    index(()=>{\n        if (!open) {\n            pointerTypeRef.current = undefined;\n            cleanupMouseMoveHandler();\n            clearPointerEvents();\n        }\n    }, [\n        open,\n        cleanupMouseMoveHandler,\n        clearPointerEvents\n    ]);\n    // biome-ignore lint/correctness/useExhaustiveDependencies: intentional\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        return ()=>{\n            cleanupMouseMoveHandler();\n            clearTimeout(timeoutRef.current);\n            clearTimeout(restTimeoutRef.current);\n            clearPointerEvents();\n        };\n    }, [\n        enabled,\n        domReference,\n        cleanupMouseMoveHandler,\n        clearPointerEvents\n    ]);\n    return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>{\n        if (!enabled) {\n            return {};\n        }\n        function setPointerRef(event) {\n            pointerTypeRef.current = event.pointerType;\n        }\n        return {\n            reference: {\n                onPointerDown: setPointerRef,\n                onPointerEnter: setPointerRef,\n                onMouseMove (event) {\n                    if (open || restMs === 0) {\n                        return;\n                    }\n                    clearTimeout(restTimeoutRef.current);\n                    restTimeoutRef.current = setTimeout(()=>{\n                        if (!blockMouseMoveRef.current) {\n                            onOpenChange(true, event.nativeEvent, \"hover\");\n                        }\n                    }, restMs);\n                }\n            },\n            floating: {\n                onMouseEnter () {\n                    clearTimeout(timeoutRef.current);\n                },\n                onMouseLeave (event) {\n                    closeWithDelay(event.nativeEvent, false);\n                }\n            }\n        };\n    }, [\n        enabled,\n        restMs,\n        open,\n        onOpenChange,\n        closeWithDelay\n    ]);\n}\nconst FloatingDelayGroupContext = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createContext({\n    delay: 0,\n    initialDelay: 0,\n    timeoutMs: 0,\n    currentId: null,\n    setCurrentId: ()=>{},\n    setState: ()=>{},\n    isInstantPhase: false\n});\nconst useDelayGroupContext = ()=>react__WEBPACK_IMPORTED_MODULE_0__.useContext(FloatingDelayGroupContext);\n/**\n * Provides context for a group of floating elements that should share a\n * `delay`.\n * @see https://floating-ui.com/docs/FloatingDelayGroup\n */ const FloatingDelayGroup = (_ref)=>{\n    let { children, delay, timeoutMs = 0 } = _ref;\n    const [state, setState] = react__WEBPACK_IMPORTED_MODULE_0__.useReducer((prev, next)=>({\n            ...prev,\n            ...next\n        }), {\n        delay,\n        timeoutMs,\n        initialDelay: delay,\n        currentId: null,\n        isInstantPhase: false\n    });\n    const initialCurrentIdRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n    const setCurrentId = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((currentId)=>{\n        setState({\n            currentId\n        });\n    }, []);\n    index(()=>{\n        if (state.currentId) {\n            if (initialCurrentIdRef.current === null) {\n                initialCurrentIdRef.current = state.currentId;\n            } else {\n                setState({\n                    isInstantPhase: true\n                });\n            }\n        } else {\n            setState({\n                isInstantPhase: false\n            });\n            initialCurrentIdRef.current = null;\n        }\n    }, [\n        state.currentId\n    ]);\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(FloatingDelayGroupContext.Provider, {\n        value: react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>({\n                ...state,\n                setState,\n                setCurrentId\n            }), [\n            state,\n            setCurrentId\n        ])\n    }, children);\n};\n/**\n * Enables grouping when called inside a component that's a child of a\n * `FloatingDelayGroup`.\n * @see https://floating-ui.com/docs/FloatingDelayGroup\n */ const useDelayGroup = (_ref2, _ref3)=>{\n    let { open, onOpenChange } = _ref2;\n    let { id } = _ref3;\n    const { currentId, setCurrentId, initialDelay, setState, timeoutMs } = useDelayGroupContext();\n    index(()=>{\n        if (currentId) {\n            setState({\n                delay: {\n                    open: 1,\n                    close: getDelay(initialDelay, \"close\")\n                }\n            });\n            if (currentId !== id) {\n                onOpenChange(false);\n            }\n        }\n    }, [\n        id,\n        onOpenChange,\n        setState,\n        currentId,\n        initialDelay\n    ]);\n    index(()=>{\n        function unset() {\n            onOpenChange(false);\n            setState({\n                delay: initialDelay,\n                currentId: null\n            });\n        }\n        if (!open && currentId === id) {\n            if (timeoutMs) {\n                const timeout = window.setTimeout(unset, timeoutMs);\n                return ()=>{\n                    clearTimeout(timeout);\n                };\n            }\n            unset();\n        }\n    }, [\n        open,\n        setState,\n        currentId,\n        id,\n        onOpenChange,\n        initialDelay,\n        timeoutMs\n    ]);\n    index(()=>{\n        if (open) {\n            setCurrentId(id);\n        }\n    }, [\n        open,\n        setCurrentId,\n        id\n    ]);\n};\nfunction getAncestors(nodes, id) {\n    var _nodes$find;\n    let allAncestors = [];\n    let currentParentId = (_nodes$find = nodes.find((node)=>node.id === id)) == null ? void 0 : _nodes$find.parentId;\n    while(currentParentId){\n        const currentNode = nodes.find((node)=>node.id === currentParentId);\n        currentParentId = currentNode == null ? void 0 : currentNode.parentId;\n        if (currentNode) {\n            allAncestors = allAncestors.concat(currentNode);\n        }\n    }\n    return allAncestors;\n}\nfunction getChildren(nodes, id) {\n    let allChildren = nodes.filter((node)=>{\n        var _node$context;\n        return node.parentId === id && ((_node$context = node.context) == null ? void 0 : _node$context.open);\n    });\n    let currentChildren = allChildren;\n    while(currentChildren.length){\n        currentChildren = nodes.filter((node)=>{\n            var _currentChildren;\n            return (_currentChildren = currentChildren) == null ? void 0 : _currentChildren.some((n)=>{\n                var _node$context2;\n                return node.parentId === n.id && ((_node$context2 = node.context) == null ? void 0 : _node$context2.open);\n            });\n        });\n        allChildren = allChildren.concat(currentChildren);\n    }\n    return allChildren;\n}\nfunction getDeepestNode(nodes, id) {\n    let deepestNodeId;\n    let maxDepth = -1;\n    function findDeepest(nodeId, depth) {\n        if (depth > maxDepth) {\n            deepestNodeId = nodeId;\n            maxDepth = depth;\n        }\n        const children = getChildren(nodes, nodeId);\n        children.forEach((child)=>{\n            findDeepest(child.id, depth + 1);\n        });\n    }\n    findDeepest(id, 0);\n    return nodes.find((node)=>node.id === deepestNodeId);\n}\n// Modified to add conditional `aria-hidden` support:\n// https://github.com/theKashey/aria-hidden/blob/9220c8f4a4fd35f63bee5510a9f41a37264382d4/src/index.ts\nlet counterMap = /*#__PURE__*/ new WeakMap();\nlet uncontrolledElementsSet = /*#__PURE__*/ new WeakSet();\nlet markerMap = {};\nlet lockCount = 0;\nconst supportsInert = ()=>typeof HTMLElement !== \"undefined\" && \"inert\" in HTMLElement.prototype;\nconst unwrapHost = (node)=>node && (node.host || unwrapHost(node.parentNode));\nconst correctElements = (parent, targets)=>targets.map((target)=>{\n        if (parent.contains(target)) {\n            return target;\n        }\n        const correctedTarget = unwrapHost(target);\n        if (parent.contains(correctedTarget)) {\n            return correctedTarget;\n        }\n        return null;\n    }).filter((x)=>x != null);\nfunction applyAttributeToOthers(uncorrectedAvoidElements, body, ariaHidden, inert) {\n    const markerName = \"data-floating-ui-inert\";\n    const controlAttribute = inert ? \"inert\" : ariaHidden ? \"aria-hidden\" : null;\n    const avoidElements = correctElements(body, uncorrectedAvoidElements);\n    const elementsToKeep = new Set();\n    const elementsToStop = new Set(avoidElements);\n    const hiddenElements = [];\n    if (!markerMap[markerName]) {\n        markerMap[markerName] = new WeakMap();\n    }\n    const markerCounter = markerMap[markerName];\n    avoidElements.forEach(keep);\n    deep(body);\n    elementsToKeep.clear();\n    function keep(el) {\n        if (!el || elementsToKeep.has(el)) {\n            return;\n        }\n        elementsToKeep.add(el);\n        el.parentNode && keep(el.parentNode);\n    }\n    function deep(parent) {\n        if (!parent || elementsToStop.has(parent)) {\n            return;\n        }\n        Array.prototype.forEach.call(parent.children, (node)=>{\n            if (elementsToKeep.has(node)) {\n                deep(node);\n            } else {\n                const attr = controlAttribute ? node.getAttribute(controlAttribute) : null;\n                const alreadyHidden = attr !== null && attr !== \"false\";\n                const counterValue = (counterMap.get(node) || 0) + 1;\n                const markerValue = (markerCounter.get(node) || 0) + 1;\n                counterMap.set(node, counterValue);\n                markerCounter.set(node, markerValue);\n                hiddenElements.push(node);\n                if (counterValue === 1 && alreadyHidden) {\n                    uncontrolledElementsSet.add(node);\n                }\n                if (markerValue === 1) {\n                    node.setAttribute(markerName, \"\");\n                }\n                if (!alreadyHidden && controlAttribute) {\n                    node.setAttribute(controlAttribute, \"true\");\n                }\n            }\n        });\n    }\n    lockCount++;\n    return ()=>{\n        hiddenElements.forEach((element)=>{\n            const counterValue = (counterMap.get(element) || 0) - 1;\n            const markerValue = (markerCounter.get(element) || 0) - 1;\n            counterMap.set(element, counterValue);\n            markerCounter.set(element, markerValue);\n            if (!counterValue) {\n                if (!uncontrolledElementsSet.has(element) && controlAttribute) {\n                    element.removeAttribute(controlAttribute);\n                }\n                uncontrolledElementsSet.delete(element);\n            }\n            if (!markerValue) {\n                element.removeAttribute(markerName);\n            }\n        });\n        lockCount--;\n        if (!lockCount) {\n            counterMap = new WeakMap();\n            counterMap = new WeakMap();\n            uncontrolledElementsSet = new WeakSet();\n            markerMap = {};\n        }\n    };\n}\nfunction markOthers(avoidElements, ariaHidden, inert) {\n    if (ariaHidden === void 0) {\n        ariaHidden = false;\n    }\n    if (inert === void 0) {\n        inert = false;\n    }\n    const body = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.getDocument)(avoidElements[0]).body;\n    return applyAttributeToOthers(avoidElements.concat(Array.from(body.querySelectorAll(\"[aria-live]\"))), body, ariaHidden, inert);\n}\nconst getTabbableOptions = ()=>({\n        getShadowRoot: true,\n        displayCheck: // JSDOM does not support the `tabbable` library. To solve this we can\n        // check if `ResizeObserver` is a real function (not polyfilled), which\n        // determines if the current environment is JSDOM-like.\n        typeof ResizeObserver === \"function\" && ResizeObserver.toString().includes(\"[native code]\") ? \"full\" : \"none\"\n    });\nfunction getTabbableIn(container, direction) {\n    const allTabbable = (0,tabbable__WEBPACK_IMPORTED_MODULE_8__.tabbable)(container, getTabbableOptions());\n    if (direction === \"prev\") {\n        allTabbable.reverse();\n    }\n    const activeIndex = allTabbable.indexOf((0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.activeElement)((0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.getDocument)(container)));\n    const nextTabbableElements = allTabbable.slice(activeIndex + 1);\n    return nextTabbableElements[0];\n}\nfunction getNextTabbable() {\n    return getTabbableIn(document.body, \"next\");\n}\nfunction getPreviousTabbable() {\n    return getTabbableIn(document.body, \"prev\");\n}\nfunction isOutsideEvent(event, container) {\n    const containerElement = container || event.currentTarget;\n    const relatedTarget = event.relatedTarget;\n    return !relatedTarget || !(0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.contains)(containerElement, relatedTarget);\n}\nfunction disableFocusInside(container) {\n    const tabbableElements = (0,tabbable__WEBPACK_IMPORTED_MODULE_8__.tabbable)(container, getTabbableOptions());\n    tabbableElements.forEach((element)=>{\n        element.dataset.tabindex = element.getAttribute(\"tabindex\") || \"\";\n        element.setAttribute(\"tabindex\", \"-1\");\n    });\n}\nfunction enableFocusInside(container) {\n    const elements = container.querySelectorAll(\"[data-tabindex]\");\n    elements.forEach((element)=>{\n        const tabindex = element.dataset.tabindex;\n        // biome-ignore lint/performance/noDelete: purity\n        delete element.dataset.tabindex;\n        if (tabindex) {\n            element.setAttribute(\"tabindex\", tabindex);\n        } else {\n            element.removeAttribute(\"tabindex\");\n        }\n    });\n}\n// See Diego Haz's Sandbox for making this logic work well on Safari/iOS:\n// https://codesandbox.io/s/tabbable-portal-f4tng?file=/src/FocusTrap.tsx\nconst HIDDEN_STYLES = {\n    border: 0,\n    clip: \"rect(0 0 0 0)\",\n    height: \"1px\",\n    margin: \"-1px\",\n    overflow: \"hidden\",\n    padding: 0,\n    position: \"fixed\",\n    whiteSpace: \"nowrap\",\n    width: \"1px\",\n    top: 0,\n    left: 0\n};\nlet timeoutId;\nfunction setActiveElementOnTab(event) {\n    if (event.key === \"Tab\") {\n        event.target;\n        clearTimeout(timeoutId);\n    }\n}\nconst FocusGuard = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(function FocusGuard(props, ref) {\n    const [role, setRole] = react__WEBPACK_IMPORTED_MODULE_0__.useState();\n    index(()=>{\n        if ((0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.isSafari)()) {\n            // Unlike other screen readers such as NVDA and JAWS, the virtual cursor\n            // on VoiceOver does trigger the onFocus event, so we can use the focus\n            // trap element. On Safari, only buttons trigger the onFocus event.\n            // NB: \"group\" role in the Sandbox no longer appears to work, must be a\n            // button role.\n            setRole(\"button\");\n        }\n        document.addEventListener(\"keydown\", setActiveElementOnTab);\n        return ()=>{\n            document.removeEventListener(\"keydown\", setActiveElementOnTab);\n        };\n    }, []);\n    const restProps = {\n        ref,\n        tabIndex: 0,\n        // Role is only for VoiceOver\n        role,\n        \"aria-hidden\": role ? undefined : true,\n        [createAttribute(\"focus-guard\")]: \"\",\n        style: HIDDEN_STYLES\n    };\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"span\", _extends({}, props, restProps));\n});\nconst PortalContext = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);\nconst attr = /*#__PURE__*/ createAttribute(\"portal\");\n/**\n * @see https://floating-ui.com/docs/FloatingPortal#usefloatingportalnode\n */ function useFloatingPortalNode(_temp) {\n    let { id, root } = _temp === void 0 ? {} : _temp;\n    const [portalNode, setPortalNode] = react__WEBPACK_IMPORTED_MODULE_0__.useState(null);\n    const uniqueId = useId();\n    const portalContext = usePortalContext();\n    const portalNodeRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n    index(()=>{\n        return ()=>{\n            portalNode == null || portalNode.remove();\n            // Allow the subsequent layout effects to create a new node on updates.\n            // The portal node will still be cleaned up on unmount.\n            // https://github.com/floating-ui/floating-ui/issues/2454\n            queueMicrotask(()=>{\n                portalNodeRef.current = null;\n            });\n        };\n    }, [\n        portalNode\n    ]);\n    index(()=>{\n        if (portalNodeRef.current) return;\n        const existingIdRoot = id ? document.getElementById(id) : null;\n        if (!existingIdRoot) return;\n        const subRoot = document.createElement(\"div\");\n        subRoot.id = uniqueId;\n        subRoot.setAttribute(attr, \"\");\n        existingIdRoot.appendChild(subRoot);\n        portalNodeRef.current = subRoot;\n        setPortalNode(subRoot);\n    }, [\n        id,\n        uniqueId\n    ]);\n    index(()=>{\n        if (portalNodeRef.current) return;\n        let container = root || (portalContext == null ? void 0 : portalContext.portalNode);\n        if (container && !(0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_4__.isElement)(container)) container = container.current;\n        container = container || document.body;\n        let idWrapper = null;\n        if (id) {\n            idWrapper = document.createElement(\"div\");\n            idWrapper.id = id;\n            container.appendChild(idWrapper);\n        }\n        const subRoot = document.createElement(\"div\");\n        subRoot.id = uniqueId;\n        subRoot.setAttribute(attr, \"\");\n        container = idWrapper || container;\n        container.appendChild(subRoot);\n        portalNodeRef.current = subRoot;\n        setPortalNode(subRoot);\n    }, [\n        id,\n        root,\n        uniqueId,\n        portalContext\n    ]);\n    return portalNode;\n}\n/**\n * Portals the floating element into a given container element â€” by default,\n * outside of the app root and into the body.\n * This is necessary to ensure the floating element can appear outside any\n * potential parent containers that cause clipping (such as `overflow: hidden`),\n * while retaining its location in the React tree.\n * @see https://floating-ui.com/docs/FloatingPortal\n */ function FloatingPortal(_ref) {\n    let { children, id, root = null, preserveTabOrder = true } = _ref;\n    const portalNode = useFloatingPortalNode({\n        id,\n        root\n    });\n    const [focusManagerState, setFocusManagerState] = react__WEBPACK_IMPORTED_MODULE_0__.useState(null);\n    const beforeOutsideRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n    const afterOutsideRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n    const beforeInsideRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n    const afterInsideRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n    const shouldRenderGuards = // The FocusManager and therefore floating element are currently open/\n    // rendered.\n    !!focusManagerState && // Guards are only for non-modal focus management.\n    !focusManagerState.modal && // Don't render if unmount is transitioning.\n    focusManagerState.open && preserveTabOrder && !!(root || portalNode);\n    // https://codesandbox.io/s/tabbable-portal-f4tng?file=/src/TabbablePortal.tsx\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        if (!portalNode || !preserveTabOrder || focusManagerState != null && focusManagerState.modal) {\n            return;\n        }\n        // Make sure elements inside the portal element are tabbable only when the\n        // portal has already been focused, either by tabbing into a focus trap\n        // element outside or using the mouse.\n        function onFocus(event) {\n            if (portalNode && isOutsideEvent(event)) {\n                const focusing = event.type === \"focusin\";\n                const manageFocus = focusing ? enableFocusInside : disableFocusInside;\n                manageFocus(portalNode);\n            }\n        }\n        // Listen to the event on the capture phase so they run before the focus\n        // trap elements onFocus prop is called.\n        portalNode.addEventListener(\"focusin\", onFocus, true);\n        portalNode.addEventListener(\"focusout\", onFocus, true);\n        return ()=>{\n            portalNode.removeEventListener(\"focusin\", onFocus, true);\n            portalNode.removeEventListener(\"focusout\", onFocus, true);\n        };\n    }, [\n        portalNode,\n        preserveTabOrder,\n        focusManagerState == null ? void 0 : focusManagerState.modal\n    ]);\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(PortalContext.Provider, {\n        value: react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>({\n                preserveTabOrder,\n                beforeOutsideRef,\n                afterOutsideRef,\n                beforeInsideRef,\n                afterInsideRef,\n                portalNode,\n                setFocusManagerState\n            }), [\n            preserveTabOrder,\n            portalNode\n        ])\n    }, shouldRenderGuards && portalNode && /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(FocusGuard, {\n        \"data-type\": \"outside\",\n        ref: beforeOutsideRef,\n        onFocus: (event)=>{\n            if (isOutsideEvent(event, portalNode)) {\n                var _beforeInsideRef$curr;\n                (_beforeInsideRef$curr = beforeInsideRef.current) == null || _beforeInsideRef$curr.focus();\n            } else {\n                const prevTabbable = getPreviousTabbable() || (focusManagerState == null ? void 0 : focusManagerState.refs.domReference.current);\n                prevTabbable == null || prevTabbable.focus();\n            }\n        }\n    }), shouldRenderGuards && portalNode && /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"span\", {\n        \"aria-owns\": portalNode.id,\n        style: HIDDEN_STYLES\n    }), portalNode && /*#__PURE__*/ (0,react_dom__WEBPACK_IMPORTED_MODULE_5__.createPortal)(children, portalNode), shouldRenderGuards && portalNode && /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(FocusGuard, {\n        \"data-type\": \"outside\",\n        ref: afterOutsideRef,\n        onFocus: (event)=>{\n            if (isOutsideEvent(event, portalNode)) {\n                var _afterInsideRef$curre;\n                (_afterInsideRef$curre = afterInsideRef.current) == null || _afterInsideRef$curre.focus();\n            } else {\n                const nextTabbable = getNextTabbable() || (focusManagerState == null ? void 0 : focusManagerState.refs.domReference.current);\n                nextTabbable == null || nextTabbable.focus();\n                (focusManagerState == null ? void 0 : focusManagerState.closeOnFocusOut) && (focusManagerState == null ? void 0 : focusManagerState.onOpenChange(false, event.nativeEvent));\n            }\n        }\n    }));\n}\nconst usePortalContext = ()=>react__WEBPACK_IMPORTED_MODULE_0__.useContext(PortalContext);\nconst LIST_LIMIT = 20;\nlet previouslyFocusedElements = [];\nfunction addPreviouslyFocusedElement(element) {\n    previouslyFocusedElements = previouslyFocusedElements.filter((el)=>el.isConnected);\n    if (element && (0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_4__.getNodeName)(element) !== \"body\") {\n        previouslyFocusedElements.push(element);\n        if (previouslyFocusedElements.length > LIST_LIMIT) {\n            previouslyFocusedElements = previouslyFocusedElements.slice(-LIST_LIMIT);\n        }\n    }\n}\nfunction getPreviouslyFocusedElement() {\n    return previouslyFocusedElements.slice().reverse().find((el)=>el.isConnected);\n}\nconst VisuallyHiddenDismiss = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(function VisuallyHiddenDismiss(props, ref) {\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"button\", _extends({}, props, {\n        type: \"button\",\n        ref: ref,\n        tabIndex: -1,\n        style: HIDDEN_STYLES\n    }));\n});\n/**\n * Provides focus management for the floating element.\n * @see https://floating-ui.com/docs/FloatingFocusManager\n */ function FloatingFocusManager(props) {\n    const { context, children, disabled = false, order = [\n        \"content\"\n    ], guards: _guards = true, initialFocus = 0, returnFocus = true, modal = true, visuallyHiddenDismiss = false, closeOnFocusOut = true } = props;\n    const { open, refs, nodeId, onOpenChange, events, dataRef, elements: { domReference, floating } } = context;\n    const ignoreInitialFocus = typeof initialFocus === \"number\" && initialFocus < 0;\n    // If the reference is a combobox and is typeable (e.g. input/textarea),\n    // there are different focus semantics. The guards should not be rendered, but\n    // aria-hidden should be applied to all nodes still. Further, the visually\n    // hidden dismiss button should only appear at the end of the list, not the\n    // start.\n    const isUntrappedTypeableCombobox = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.isTypeableCombobox)(domReference) && ignoreInitialFocus;\n    // Force the guards to be rendered if the `inert` attribute is not supported.\n    const guards = supportsInert() ? _guards : true;\n    const orderRef = useLatestRef(order);\n    const initialFocusRef = useLatestRef(initialFocus);\n    const returnFocusRef = useLatestRef(returnFocus);\n    const tree = useFloatingTree();\n    const portalContext = usePortalContext();\n    const startDismissButtonRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n    const endDismissButtonRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n    const preventReturnFocusRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(false);\n    const isPointerDownRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(false);\n    const isInsidePortal = portalContext != null;\n    const getTabbableContent = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(function(container) {\n        if (container === void 0) {\n            container = floating;\n        }\n        return container ? (0,tabbable__WEBPACK_IMPORTED_MODULE_8__.tabbable)(container, getTabbableOptions()) : [];\n    }, [\n        floating\n    ]);\n    const getTabbableElements = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((container)=>{\n        const content = getTabbableContent(container);\n        return orderRef.current.map((type)=>{\n            if (domReference && type === \"reference\") {\n                return domReference;\n            }\n            if (floating && type === \"floating\") {\n                return floating;\n            }\n            return content;\n        }).filter(Boolean).flat();\n    }, [\n        domReference,\n        floating,\n        orderRef,\n        getTabbableContent\n    ]);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        if (disabled || !modal) return;\n        function onKeyDown(event) {\n            if (event.key === \"Tab\") {\n                // The focus guards have nothing to focus, so we need to stop the event.\n                if ((0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.contains)(floating, (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.activeElement)((0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.getDocument)(floating))) && getTabbableContent().length === 0 && !isUntrappedTypeableCombobox) {\n                    (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.stopEvent)(event);\n                }\n                const els = getTabbableElements();\n                const target = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.getTarget)(event);\n                if (orderRef.current[0] === \"reference\" && target === domReference) {\n                    (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.stopEvent)(event);\n                    if (event.shiftKey) {\n                        enqueueFocus(els[els.length - 1]);\n                    } else {\n                        enqueueFocus(els[1]);\n                    }\n                }\n                if (orderRef.current[1] === \"floating\" && target === floating && event.shiftKey) {\n                    (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.stopEvent)(event);\n                    enqueueFocus(els[0]);\n                }\n            }\n        }\n        const doc = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.getDocument)(floating);\n        doc.addEventListener(\"keydown\", onKeyDown);\n        return ()=>{\n            doc.removeEventListener(\"keydown\", onKeyDown);\n        };\n    }, [\n        disabled,\n        domReference,\n        floating,\n        modal,\n        orderRef,\n        isUntrappedTypeableCombobox,\n        getTabbableContent,\n        getTabbableElements\n    ]);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        if (disabled || !closeOnFocusOut) return;\n        // In Safari, buttons lose focus when pressing them.\n        function handlePointerDown() {\n            isPointerDownRef.current = true;\n            setTimeout(()=>{\n                isPointerDownRef.current = false;\n            });\n        }\n        function handleFocusOutside(event) {\n            const relatedTarget = event.relatedTarget;\n            queueMicrotask(()=>{\n                const movedToUnrelatedNode = !((0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.contains)(domReference, relatedTarget) || (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.contains)(floating, relatedTarget) || (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.contains)(relatedTarget, floating) || (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.contains)(portalContext == null ? void 0 : portalContext.portalNode, relatedTarget) || relatedTarget != null && relatedTarget.hasAttribute(createAttribute(\"focus-guard\")) || tree && (getChildren(tree.nodesRef.current, nodeId).find((node)=>{\n                    var _node$context, _node$context2;\n                    return (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.contains)((_node$context = node.context) == null ? void 0 : _node$context.elements.floating, relatedTarget) || (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.contains)((_node$context2 = node.context) == null ? void 0 : _node$context2.elements.domReference, relatedTarget);\n                }) || getAncestors(tree.nodesRef.current, nodeId).find((node)=>{\n                    var _node$context3, _node$context4;\n                    return ((_node$context3 = node.context) == null ? void 0 : _node$context3.elements.floating) === relatedTarget || ((_node$context4 = node.context) == null ? void 0 : _node$context4.elements.domReference) === relatedTarget;\n                })));\n                // Focus did not move inside the floating tree, and there are no tabbable\n                // portal guards to handle closing.\n                if (relatedTarget && movedToUnrelatedNode && !isPointerDownRef.current && // Fix React 18 Strict Mode returnFocus due to double rendering.\n                relatedTarget !== getPreviouslyFocusedElement()) {\n                    preventReturnFocusRef.current = true;\n                    onOpenChange(false, event);\n                }\n            });\n        }\n        if (floating && (0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_4__.isHTMLElement)(domReference)) {\n            domReference.addEventListener(\"focusout\", handleFocusOutside);\n            domReference.addEventListener(\"pointerdown\", handlePointerDown);\n            !modal && floating.addEventListener(\"focusout\", handleFocusOutside);\n            return ()=>{\n                domReference.removeEventListener(\"focusout\", handleFocusOutside);\n                domReference.removeEventListener(\"pointerdown\", handlePointerDown);\n                !modal && floating.removeEventListener(\"focusout\", handleFocusOutside);\n            };\n        }\n    }, [\n        disabled,\n        domReference,\n        floating,\n        modal,\n        nodeId,\n        tree,\n        portalContext,\n        onOpenChange,\n        closeOnFocusOut\n    ]);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        var _portalContext$portal;\n        if (disabled) return;\n        // Don't hide portals nested within the parent portal.\n        const portalNodes = Array.from((portalContext == null || (_portalContext$portal = portalContext.portalNode) == null ? void 0 : _portalContext$portal.querySelectorAll(\"[\" + createAttribute(\"portal\") + \"]\")) || []);\n        if (floating) {\n            const insideElements = [\n                floating,\n                ...portalNodes,\n                startDismissButtonRef.current,\n                endDismissButtonRef.current,\n                orderRef.current.includes(\"reference\") || isUntrappedTypeableCombobox ? domReference : null\n            ].filter((x)=>x != null);\n            const cleanup = modal || isUntrappedTypeableCombobox ? markOthers(insideElements, guards, !guards) : markOthers(insideElements);\n            return ()=>{\n                cleanup();\n            };\n        }\n    }, [\n        disabled,\n        domReference,\n        floating,\n        modal,\n        orderRef,\n        portalContext,\n        isUntrappedTypeableCombobox,\n        guards\n    ]);\n    index(()=>{\n        if (disabled || !floating) return;\n        const doc = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.getDocument)(floating);\n        const previouslyFocusedElement = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.activeElement)(doc);\n        // Wait for any layout effect state setters to execute to set `tabIndex`.\n        queueMicrotask(()=>{\n            const focusableElements = getTabbableElements(floating);\n            const initialFocusValue = initialFocusRef.current;\n            const elToFocus = (typeof initialFocusValue === \"number\" ? focusableElements[initialFocusValue] : initialFocusValue.current) || floating;\n            const focusAlreadyInsideFloatingEl = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.contains)(floating, previouslyFocusedElement);\n            if (!ignoreInitialFocus && !focusAlreadyInsideFloatingEl && open) {\n                enqueueFocus(elToFocus, {\n                    preventScroll: elToFocus === floating\n                });\n            }\n        });\n    }, [\n        disabled,\n        open,\n        floating,\n        ignoreInitialFocus,\n        getTabbableElements,\n        initialFocusRef\n    ]);\n    index(()=>{\n        if (disabled || !floating) return;\n        let preventReturnFocusScroll = false;\n        const doc = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.getDocument)(floating);\n        const previouslyFocusedElement = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.activeElement)(doc);\n        const contextData = dataRef.current;\n        addPreviouslyFocusedElement(previouslyFocusedElement);\n        // Dismissing via outside press should always ignore `returnFocus` to\n        // prevent unwanted scrolling.\n        function onOpenChange(_ref) {\n            let { reason, event, nested } = _ref;\n            if (reason === \"escape-key\" && refs.domReference.current) {\n                addPreviouslyFocusedElement(refs.domReference.current);\n            }\n            if (reason === \"hover\" && event.type === \"mouseleave\") {\n                preventReturnFocusRef.current = true;\n            }\n            if (reason !== \"outside-press\") return;\n            if (nested) {\n                preventReturnFocusRef.current = false;\n                preventReturnFocusScroll = true;\n            } else {\n                preventReturnFocusRef.current = !((0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.isVirtualClick)(event) || (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.isVirtualPointerEvent)(event));\n            }\n        }\n        events.on(\"openchange\", onOpenChange);\n        return ()=>{\n            events.off(\"openchange\", onOpenChange);\n            const activeEl = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.activeElement)(doc);\n            const isFocusInsideFloatingTree = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.contains)(floating, activeEl) || tree && getChildren(tree.nodesRef.current, nodeId).some((node)=>{\n                var _node$context5;\n                return (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.contains)((_node$context5 = node.context) == null ? void 0 : _node$context5.elements.floating, activeEl);\n            });\n            const shouldFocusReference = isFocusInsideFloatingTree || contextData.openEvent && [\n                \"click\",\n                \"mousedown\"\n            ].includes(contextData.openEvent.type);\n            if (shouldFocusReference && refs.domReference.current) {\n                addPreviouslyFocusedElement(refs.domReference.current);\n            }\n            const returnElement = getPreviouslyFocusedElement();\n            if (returnFocusRef.current && !preventReturnFocusRef.current && (0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_4__.isHTMLElement)(returnElement) && // If the focus moved somewhere else after mount, avoid returning focus\n            // since it likely entered a different element which should be\n            // respected: https://github.com/floating-ui/floating-ui/issues/2607\n            (returnElement !== activeEl && activeEl !== doc.body ? isFocusInsideFloatingTree : true)) {\n                enqueueFocus(returnElement, {\n                    // When dismissing nested floating elements, by the time the rAF has\n                    // executed, the menus will all have been unmounted. When they try\n                    // to get focused, the calls get ignored â€” leaving the root\n                    // reference focused as desired.\n                    cancelPrevious: false,\n                    preventScroll: preventReturnFocusScroll\n                });\n            }\n        };\n    }, [\n        disabled,\n        floating,\n        returnFocusRef,\n        dataRef,\n        refs,\n        events,\n        tree,\n        nodeId\n    ]);\n    // Synchronize the `context` & `modal` value to the FloatingPortal context.\n    // It will decide whether or not it needs to render its own guards.\n    index(()=>{\n        if (disabled || !portalContext) return;\n        portalContext.setFocusManagerState({\n            modal,\n            closeOnFocusOut,\n            open,\n            onOpenChange,\n            refs\n        });\n        return ()=>{\n            portalContext.setFocusManagerState(null);\n        };\n    }, [\n        disabled,\n        portalContext,\n        modal,\n        open,\n        onOpenChange,\n        refs,\n        closeOnFocusOut\n    ]);\n    index(()=>{\n        if (disabled || !floating || typeof MutationObserver !== \"function\" || ignoreInitialFocus) {\n            return;\n        }\n        const handleMutation = ()=>{\n            const tabIndex = floating.getAttribute(\"tabindex\");\n            if (orderRef.current.includes(\"floating\") || (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.activeElement)((0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.getDocument)(floating)) !== refs.domReference.current && getTabbableContent().length === 0) {\n                if (tabIndex !== \"0\") {\n                    floating.setAttribute(\"tabindex\", \"0\");\n                }\n            } else if (tabIndex !== \"-1\") {\n                floating.setAttribute(\"tabindex\", \"-1\");\n            }\n        };\n        handleMutation();\n        const observer = new MutationObserver(handleMutation);\n        observer.observe(floating, {\n            childList: true,\n            subtree: true,\n            attributes: true\n        });\n        return ()=>{\n            observer.disconnect();\n        };\n    }, [\n        disabled,\n        floating,\n        refs,\n        orderRef,\n        getTabbableContent,\n        ignoreInitialFocus\n    ]);\n    function renderDismissButton(location) {\n        if (disabled || !visuallyHiddenDismiss || !modal) {\n            return null;\n        }\n        return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(VisuallyHiddenDismiss, {\n            ref: location === \"start\" ? startDismissButtonRef : endDismissButtonRef,\n            onClick: (event)=>onOpenChange(false, event.nativeEvent)\n        }, typeof visuallyHiddenDismiss === \"string\" ? visuallyHiddenDismiss : \"Dismiss\");\n    }\n    const shouldRenderGuards = !disabled && guards && (isInsidePortal || modal);\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, shouldRenderGuards && /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(FocusGuard, {\n        \"data-type\": \"inside\",\n        ref: portalContext == null ? void 0 : portalContext.beforeInsideRef,\n        onFocus: (event)=>{\n            if (modal) {\n                const els = getTabbableElements();\n                enqueueFocus(order[0] === \"reference\" ? els[0] : els[els.length - 1]);\n            } else if (portalContext != null && portalContext.preserveTabOrder && portalContext.portalNode) {\n                preventReturnFocusRef.current = false;\n                if (isOutsideEvent(event, portalContext.portalNode)) {\n                    const nextTabbable = getNextTabbable() || domReference;\n                    nextTabbable == null || nextTabbable.focus();\n                } else {\n                    var _portalContext$before;\n                    (_portalContext$before = portalContext.beforeOutsideRef.current) == null || _portalContext$before.focus();\n                }\n            }\n        }\n    }), !isUntrappedTypeableCombobox && renderDismissButton(\"start\"), children, renderDismissButton(\"end\"), shouldRenderGuards && /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(FocusGuard, {\n        \"data-type\": \"inside\",\n        ref: portalContext == null ? void 0 : portalContext.afterInsideRef,\n        onFocus: (event)=>{\n            if (modal) {\n                enqueueFocus(getTabbableElements()[0]);\n            } else if (portalContext != null && portalContext.preserveTabOrder && portalContext.portalNode) {\n                if (closeOnFocusOut) {\n                    preventReturnFocusRef.current = true;\n                }\n                if (isOutsideEvent(event, portalContext.portalNode)) {\n                    const prevTabbable = getPreviousTabbable() || domReference;\n                    prevTabbable == null || prevTabbable.focus();\n                } else {\n                    var _portalContext$afterO;\n                    (_portalContext$afterO = portalContext.afterOutsideRef.current) == null || _portalContext$afterO.focus();\n                }\n            }\n        }\n    }));\n}\nconst activeLocks = /*#__PURE__*/ new Set();\n/**\n * Provides base styling for a fixed overlay element to dim content or block\n * pointer events behind a floating element.\n * It's a regular `<div>`, so it can be styled via any CSS solution you prefer.\n * @see https://floating-ui.com/docs/FloatingOverlay\n */ const FloatingOverlay = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(function FloatingOverlay(_ref, ref) {\n    let { lockScroll = false, ...rest } = _ref;\n    const lockId = useId();\n    index(()=>{\n        if (!lockScroll) return;\n        activeLocks.add(lockId);\n        const isIOS = /iP(hone|ad|od)|iOS/.test((0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.getPlatform)());\n        const bodyStyle = document.body.style;\n        // RTL <body> scrollbar\n        const scrollbarX = Math.round(document.documentElement.getBoundingClientRect().left) + document.documentElement.scrollLeft;\n        const paddingProp = scrollbarX ? \"paddingLeft\" : \"paddingRight\";\n        const scrollbarWidth = window.innerWidth - document.documentElement.clientWidth;\n        const scrollX = bodyStyle.left ? parseFloat(bodyStyle.left) : window.pageXOffset;\n        const scrollY = bodyStyle.top ? parseFloat(bodyStyle.top) : window.pageYOffset;\n        bodyStyle.overflow = \"hidden\";\n        if (scrollbarWidth) {\n            bodyStyle[paddingProp] = scrollbarWidth + \"px\";\n        }\n        // Only iOS doesn't respect `overflow: hidden` on document.body, and this\n        // technique has fewer side effects.\n        if (isIOS) {\n            var _window$visualViewpor, _window$visualViewpor2;\n            // iOS 12 does not support `visualViewport`.\n            const offsetLeft = ((_window$visualViewpor = window.visualViewport) == null ? void 0 : _window$visualViewpor.offsetLeft) || 0;\n            const offsetTop = ((_window$visualViewpor2 = window.visualViewport) == null ? void 0 : _window$visualViewpor2.offsetTop) || 0;\n            Object.assign(bodyStyle, {\n                position: \"fixed\",\n                top: -(scrollY - Math.floor(offsetTop)) + \"px\",\n                left: -(scrollX - Math.floor(offsetLeft)) + \"px\",\n                right: \"0\"\n            });\n        }\n        return ()=>{\n            activeLocks.delete(lockId);\n            if (activeLocks.size === 0) {\n                Object.assign(bodyStyle, {\n                    overflow: \"\",\n                    [paddingProp]: \"\"\n                });\n                if (isIOS) {\n                    Object.assign(bodyStyle, {\n                        position: \"\",\n                        top: \"\",\n                        left: \"\",\n                        right: \"\"\n                    });\n                    window.scrollTo(scrollX, scrollY);\n                }\n            }\n        };\n    }, [\n        lockId,\n        lockScroll\n    ]);\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", _extends({\n        ref: ref\n    }, rest, {\n        style: {\n            position: \"fixed\",\n            overflow: \"auto\",\n            top: 0,\n            right: 0,\n            bottom: 0,\n            left: 0,\n            ...rest.style\n        }\n    }));\n});\nfunction isButtonTarget(event) {\n    return (0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_4__.isHTMLElement)(event.target) && event.target.tagName === \"BUTTON\";\n}\nfunction isSpaceIgnored(element) {\n    return (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.isTypeableElement)(element);\n}\n/**\n * Opens or closes the floating element when clicking the reference element.\n * @see https://floating-ui.com/docs/useClick\n */ function useClick(context, props) {\n    if (props === void 0) {\n        props = {};\n    }\n    const { open, onOpenChange, dataRef, elements: { domReference } } = context;\n    const { enabled = true, event: eventOption = \"click\", toggle = true, ignoreMouse = false, keyboardHandlers = true } = props;\n    const pointerTypeRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef();\n    const didKeyDownRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(false);\n    return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>{\n        if (!enabled) return {};\n        return {\n            reference: {\n                onPointerDown (event) {\n                    pointerTypeRef.current = event.pointerType;\n                },\n                onMouseDown (event) {\n                    // Ignore all buttons except for the \"main\" button.\n                    // https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/button\n                    if (event.button !== 0) {\n                        return;\n                    }\n                    if ((0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.isMouseLikePointerType)(pointerTypeRef.current, true) && ignoreMouse) {\n                        return;\n                    }\n                    if (eventOption === \"click\") {\n                        return;\n                    }\n                    if (open && toggle && (dataRef.current.openEvent ? dataRef.current.openEvent.type === \"mousedown\" : true)) {\n                        onOpenChange(false, event.nativeEvent, \"click\");\n                    } else {\n                        // Prevent stealing focus from the floating element\n                        event.preventDefault();\n                        onOpenChange(true, event.nativeEvent, \"click\");\n                    }\n                },\n                onClick (event) {\n                    if (eventOption === \"mousedown\" && pointerTypeRef.current) {\n                        pointerTypeRef.current = undefined;\n                        return;\n                    }\n                    if ((0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.isMouseLikePointerType)(pointerTypeRef.current, true) && ignoreMouse) {\n                        return;\n                    }\n                    if (open && toggle && (dataRef.current.openEvent ? dataRef.current.openEvent.type === \"click\" : true)) {\n                        onOpenChange(false, event.nativeEvent, \"click\");\n                    } else {\n                        onOpenChange(true, event.nativeEvent, \"click\");\n                    }\n                },\n                onKeyDown (event) {\n                    pointerTypeRef.current = undefined;\n                    if (event.defaultPrevented || !keyboardHandlers || isButtonTarget(event)) {\n                        return;\n                    }\n                    if (event.key === \" \" && !isSpaceIgnored(domReference)) {\n                        // Prevent scrolling\n                        event.preventDefault();\n                        didKeyDownRef.current = true;\n                    }\n                    if (event.key === \"Enter\") {\n                        if (open && toggle) {\n                            onOpenChange(false, event.nativeEvent, \"click\");\n                        } else {\n                            onOpenChange(true, event.nativeEvent, \"click\");\n                        }\n                    }\n                },\n                onKeyUp (event) {\n                    if (event.defaultPrevented || !keyboardHandlers || isButtonTarget(event) || isSpaceIgnored(domReference)) {\n                        return;\n                    }\n                    if (event.key === \" \" && didKeyDownRef.current) {\n                        didKeyDownRef.current = false;\n                        if (open && toggle) {\n                            onOpenChange(false, event.nativeEvent, \"click\");\n                        } else {\n                            onOpenChange(true, event.nativeEvent, \"click\");\n                        }\n                    }\n                }\n            }\n        };\n    }, [\n        enabled,\n        dataRef,\n        eventOption,\n        ignoreMouse,\n        keyboardHandlers,\n        domReference,\n        toggle,\n        open,\n        onOpenChange\n    ]);\n}\nfunction createVirtualElement(domRef, data) {\n    let offsetX = null;\n    let offsetY = null;\n    let isAutoUpdateEvent = false;\n    return {\n        contextElement: domRef.current || undefined,\n        getBoundingClientRect () {\n            var _domRef$current, _data$dataRef$current;\n            const domRect = ((_domRef$current = domRef.current) == null ? void 0 : _domRef$current.getBoundingClientRect()) || {\n                width: 0,\n                height: 0,\n                x: 0,\n                y: 0\n            };\n            const isXAxis = data.axis === \"x\" || data.axis === \"both\";\n            const isYAxis = data.axis === \"y\" || data.axis === \"both\";\n            const canTrackCursorOnAutoUpdate = [\n                \"mouseenter\",\n                \"mousemove\"\n            ].includes(((_data$dataRef$current = data.dataRef.current.openEvent) == null ? void 0 : _data$dataRef$current.type) || \"\") && data.pointerType !== \"touch\";\n            let width = domRect.width;\n            let height = domRect.height;\n            let x = domRect.x;\n            let y = domRect.y;\n            if (offsetX == null && data.x && isXAxis) {\n                offsetX = domRect.x - data.x;\n            }\n            if (offsetY == null && data.y && isYAxis) {\n                offsetY = domRect.y - data.y;\n            }\n            x -= offsetX || 0;\n            y -= offsetY || 0;\n            width = 0;\n            height = 0;\n            if (!isAutoUpdateEvent || canTrackCursorOnAutoUpdate) {\n                width = data.axis === \"y\" ? domRect.width : 0;\n                height = data.axis === \"x\" ? domRect.height : 0;\n                x = isXAxis && data.x != null ? data.x : x;\n                y = isYAxis && data.y != null ? data.y : y;\n            } else if (isAutoUpdateEvent && !canTrackCursorOnAutoUpdate) {\n                height = data.axis === \"x\" ? domRect.height : height;\n                width = data.axis === \"y\" ? domRect.width : width;\n            }\n            isAutoUpdateEvent = true;\n            return {\n                width,\n                height,\n                x,\n                y,\n                top: y,\n                right: x + width,\n                bottom: y + height,\n                left: x\n            };\n        }\n    };\n}\nfunction isMouseBasedEvent(event) {\n    return event != null && event.clientX != null;\n}\n/**\n * Positions the floating element relative to a client point (in the viewport),\n * such as the mouse position. By default, it follows the mouse cursor.\n * @see https://floating-ui.com/docs/useClientPoint\n */ function useClientPoint(context, props) {\n    if (props === void 0) {\n        props = {};\n    }\n    const { open, refs, dataRef, elements: { floating } } = context;\n    const { enabled = true, axis = \"both\", x = null, y = null } = props;\n    const initialRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(false);\n    const cleanupListenerRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n    const [pointerType, setPointerType] = react__WEBPACK_IMPORTED_MODULE_0__.useState();\n    const [reactive, setReactive] = react__WEBPACK_IMPORTED_MODULE_0__.useState([]);\n    const setReference = useEffectEvent((x, y)=>{\n        if (initialRef.current) return;\n        // Prevent setting if the open event was not a mouse-like one\n        // (e.g. focus to open, then hover over the reference element).\n        // Only apply if the event exists.\n        if (dataRef.current.openEvent && !isMouseBasedEvent(dataRef.current.openEvent)) {\n            return;\n        }\n        refs.setPositionReference(createVirtualElement(refs.domReference, {\n            x,\n            y,\n            axis,\n            dataRef,\n            pointerType\n        }));\n    });\n    const handleReferenceEnterOrMove = useEffectEvent((event)=>{\n        if (x != null || y != null) return;\n        if (!open) {\n            setReference(event.clientX, event.clientY);\n        } else if (!cleanupListenerRef.current) {\n            // If there's no cleanup, there's no listener, but we want to ensure\n            // we add the listener if the cursor landed on the floating element and\n            // then back on the reference (i.e. it's interactive).\n            setReactive([]);\n        }\n    });\n    // If the pointer is a mouse-like pointer, we want to continue following the\n    // mouse even if the floating element is transitioning out. On touch\n    // devices, this is undesirable because the floating element will move to\n    // the dismissal touch point.\n    const openCheck = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.isMouseLikePointerType)(pointerType) ? floating : open;\n    const addListener = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(()=>{\n        // Explicitly specified `x`/`y` coordinates shouldn't add a listener.\n        if (!openCheck || !enabled || x != null || y != null) return;\n        const win = (0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_4__.getWindow)(refs.floating.current);\n        function handleMouseMove(event) {\n            const target = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.getTarget)(event);\n            if (!(0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.contains)(refs.floating.current, target)) {\n                setReference(event.clientX, event.clientY);\n            } else {\n                win.removeEventListener(\"mousemove\", handleMouseMove);\n                cleanupListenerRef.current = null;\n            }\n        }\n        if (!dataRef.current.openEvent || isMouseBasedEvent(dataRef.current.openEvent)) {\n            win.addEventListener(\"mousemove\", handleMouseMove);\n            const cleanup = ()=>{\n                win.removeEventListener(\"mousemove\", handleMouseMove);\n                cleanupListenerRef.current = null;\n            };\n            cleanupListenerRef.current = cleanup;\n            return cleanup;\n        }\n        refs.setPositionReference(refs.domReference.current);\n    }, [\n        dataRef,\n        enabled,\n        openCheck,\n        refs,\n        setReference,\n        x,\n        y\n    ]);\n    // biome-ignore lint/correctness/useExhaustiveDependencies: intentionally specifying `reactive`\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        return addListener();\n    }, [\n        addListener,\n        reactive\n    ]);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        if (enabled && !floating) {\n            initialRef.current = false;\n        }\n    }, [\n        enabled,\n        floating\n    ]);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        if (!enabled && open) {\n            initialRef.current = true;\n        }\n    }, [\n        enabled,\n        open\n    ]);\n    index(()=>{\n        if (enabled && (x != null || y != null)) {\n            initialRef.current = false;\n            setReference(x, y);\n        }\n    }, [\n        enabled,\n        x,\n        y,\n        setReference\n    ]);\n    return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>{\n        if (!enabled) return {};\n        function setPointerTypeRef(_ref) {\n            let { pointerType } = _ref;\n            setPointerType(pointerType);\n        }\n        return {\n            reference: {\n                onPointerDown: setPointerTypeRef,\n                onPointerEnter: setPointerTypeRef,\n                onMouseMove: handleReferenceEnterOrMove,\n                onMouseEnter: handleReferenceEnterOrMove\n            }\n        };\n    }, [\n        enabled,\n        handleReferenceEnterOrMove\n    ]);\n}\nconst bubbleHandlerKeys = {\n    pointerdown: \"onPointerDown\",\n    mousedown: \"onMouseDown\",\n    click: \"onClick\"\n};\nconst captureHandlerKeys = {\n    pointerdown: \"onPointerDownCapture\",\n    mousedown: \"onMouseDownCapture\",\n    click: \"onClickCapture\"\n};\nconst normalizeProp = (normalizable)=>{\n    var _normalizable$escapeK, _normalizable$outside;\n    return {\n        escapeKey: typeof normalizable === \"boolean\" ? normalizable : (_normalizable$escapeK = normalizable == null ? void 0 : normalizable.escapeKey) != null ? _normalizable$escapeK : false,\n        outsidePress: typeof normalizable === \"boolean\" ? normalizable : (_normalizable$outside = normalizable == null ? void 0 : normalizable.outsidePress) != null ? _normalizable$outside : true\n    };\n};\n/**\n * Closes the floating element when a dismissal is requested â€” by default, when\n * the user presses the `escape` key or outside of the floating element.\n * @see https://floating-ui.com/docs/useDismiss\n */ function useDismiss(context, props) {\n    if (props === void 0) {\n        props = {};\n    }\n    const { open, onOpenChange, nodeId, elements: { reference, domReference, floating }, dataRef } = context;\n    const { enabled = true, escapeKey = true, outsidePress: unstable_outsidePress = true, outsidePressEvent = \"pointerdown\", referencePress = false, referencePressEvent = \"pointerdown\", ancestorScroll = false, bubbles, capture } = props;\n    const tree = useFloatingTree();\n    const outsidePressFn = useEffectEvent(typeof unstable_outsidePress === \"function\" ? unstable_outsidePress : ()=>false);\n    const outsidePress = typeof unstable_outsidePress === \"function\" ? outsidePressFn : unstable_outsidePress;\n    const insideReactTreeRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(false);\n    const endedOrStartedInsideRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(false);\n    const { escapeKey: escapeKeyBubbles, outsidePress: outsidePressBubbles } = normalizeProp(bubbles);\n    const { escapeKey: escapeKeyCapture, outsidePress: outsidePressCapture } = normalizeProp(capture);\n    const closeOnEscapeKeyDown = useEffectEvent((event)=>{\n        if (!open || !enabled || !escapeKey || event.key !== \"Escape\") {\n            return;\n        }\n        const children = tree ? getChildren(tree.nodesRef.current, nodeId) : [];\n        if (!escapeKeyBubbles) {\n            event.stopPropagation();\n            if (children.length > 0) {\n                let shouldDismiss = true;\n                children.forEach((child)=>{\n                    var _child$context;\n                    if ((_child$context = child.context) != null && _child$context.open && !child.context.dataRef.current.__escapeKeyBubbles) {\n                        shouldDismiss = false;\n                        return;\n                    }\n                });\n                if (!shouldDismiss) {\n                    return;\n                }\n            }\n        }\n        onOpenChange(false, (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.isReactEvent)(event) ? event.nativeEvent : event, \"escape-key\");\n    });\n    const closeOnEscapeKeyDownCapture = useEffectEvent((event)=>{\n        var _getTarget2;\n        const callback = ()=>{\n            var _getTarget;\n            closeOnEscapeKeyDown(event);\n            (_getTarget = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.getTarget)(event)) == null || _getTarget.removeEventListener(\"keydown\", callback);\n        };\n        (_getTarget2 = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.getTarget)(event)) == null || _getTarget2.addEventListener(\"keydown\", callback);\n    });\n    const closeOnPressOutside = useEffectEvent((event)=>{\n        // Given developers can stop the propagation of the synthetic event,\n        // we can only be confident with a positive value.\n        const insideReactTree = insideReactTreeRef.current;\n        insideReactTreeRef.current = false;\n        // When click outside is lazy (`click` event), handle dragging.\n        // Don't close if:\n        // - The click started inside the floating element.\n        // - The click ended inside the floating element.\n        const endedOrStartedInside = endedOrStartedInsideRef.current;\n        endedOrStartedInsideRef.current = false;\n        if (outsidePressEvent === \"click\" && endedOrStartedInside) {\n            return;\n        }\n        if (insideReactTree) {\n            return;\n        }\n        if (typeof outsidePress === \"function\" && !outsidePress(event)) {\n            return;\n        }\n        const target = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.getTarget)(event);\n        const inertSelector = \"[\" + createAttribute(\"inert\") + \"]\";\n        const markers = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.getDocument)(floating).querySelectorAll(inertSelector);\n        let targetRootAncestor = (0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_4__.isElement)(target) ? target : null;\n        while(targetRootAncestor && !(0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_4__.isLastTraversableNode)(targetRootAncestor)){\n            const nextParent = (0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_4__.getParentNode)(targetRootAncestor);\n            if ((0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_4__.isLastTraversableNode)(nextParent) || !(0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_4__.isElement)(nextParent)) {\n                break;\n            }\n            targetRootAncestor = nextParent;\n        }\n        // Check if the click occurred on a third-party element injected after the\n        // floating element rendered.\n        if (markers.length && (0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_4__.isElement)(target) && !(0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.isRootElement)(target) && // Clicked on a direct ancestor (e.g. FloatingOverlay).\n        !(0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.contains)(target, floating) && // If the target root element contains none of the markers, then the\n        // element was injected after the floating element rendered.\n        Array.from(markers).every((marker)=>!(0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.contains)(targetRootAncestor, marker))) {\n            return;\n        }\n        // Check if the click occurred on the scrollbar\n        if ((0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_4__.isHTMLElement)(target) && floating) {\n            // In Firefox, `target.scrollWidth > target.clientWidth` for inline\n            // elements.\n            const canScrollX = target.clientWidth > 0 && target.scrollWidth > target.clientWidth;\n            const canScrollY = target.clientHeight > 0 && target.scrollHeight > target.clientHeight;\n            let xCond = canScrollY && event.offsetX > target.clientWidth;\n            // In some browsers it is possible to change the <body> (or window)\n            // scrollbar to the left side, but is very rare and is difficult to\n            // check for. Plus, for modal dialogs with backdrops, it is more\n            // important that the backdrop is checked but not so much the window.\n            if (canScrollY) {\n                const isRTL = (0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_4__.getComputedStyle)(target).direction === \"rtl\";\n                if (isRTL) {\n                    xCond = event.offsetX <= target.offsetWidth - target.clientWidth;\n                }\n            }\n            if (xCond || canScrollX && event.offsetY > target.clientHeight) {\n                return;\n            }\n        }\n        const targetIsInsideChildren = tree && getChildren(tree.nodesRef.current, nodeId).some((node)=>{\n            var _node$context;\n            return (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.isEventTargetWithin)(event, (_node$context = node.context) == null ? void 0 : _node$context.elements.floating);\n        });\n        if ((0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.isEventTargetWithin)(event, floating) || (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.isEventTargetWithin)(event, domReference) || targetIsInsideChildren) {\n            return;\n        }\n        const children = tree ? getChildren(tree.nodesRef.current, nodeId) : [];\n        if (children.length > 0) {\n            let shouldDismiss = true;\n            children.forEach((child)=>{\n                var _child$context2;\n                if ((_child$context2 = child.context) != null && _child$context2.open && !child.context.dataRef.current.__outsidePressBubbles) {\n                    shouldDismiss = false;\n                    return;\n                }\n            });\n            if (!shouldDismiss) {\n                return;\n            }\n        }\n        onOpenChange(false, event, \"outside-press\");\n    });\n    const closeOnPressOutsideCapture = useEffectEvent((event)=>{\n        var _getTarget4;\n        const callback = ()=>{\n            var _getTarget3;\n            closeOnPressOutside(event);\n            (_getTarget3 = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.getTarget)(event)) == null || _getTarget3.removeEventListener(outsidePressEvent, callback);\n        };\n        (_getTarget4 = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.getTarget)(event)) == null || _getTarget4.addEventListener(outsidePressEvent, callback);\n    });\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        if (!open || !enabled) {\n            return;\n        }\n        dataRef.current.__escapeKeyBubbles = escapeKeyBubbles;\n        dataRef.current.__outsidePressBubbles = outsidePressBubbles;\n        function onScroll(event) {\n            onOpenChange(false, event, \"ancestor-scroll\");\n        }\n        const doc = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.getDocument)(floating);\n        escapeKey && doc.addEventListener(\"keydown\", escapeKeyCapture ? closeOnEscapeKeyDownCapture : closeOnEscapeKeyDown, escapeKeyCapture);\n        outsidePress && doc.addEventListener(outsidePressEvent, outsidePressCapture ? closeOnPressOutsideCapture : closeOnPressOutside, outsidePressCapture);\n        let ancestors = [];\n        if (ancestorScroll) {\n            if ((0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_4__.isElement)(domReference)) {\n                ancestors = (0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_4__.getOverflowAncestors)(domReference);\n            }\n            if ((0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_4__.isElement)(floating)) {\n                ancestors = ancestors.concat((0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_4__.getOverflowAncestors)(floating));\n            }\n            if (!(0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_4__.isElement)(reference) && reference && reference.contextElement) {\n                ancestors = ancestors.concat((0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_4__.getOverflowAncestors)(reference.contextElement));\n            }\n        }\n        // Ignore the visual viewport for scrolling dismissal (allow pinch-zoom)\n        ancestors = ancestors.filter((ancestor)=>{\n            var _doc$defaultView;\n            return ancestor !== ((_doc$defaultView = doc.defaultView) == null ? void 0 : _doc$defaultView.visualViewport);\n        });\n        ancestors.forEach((ancestor)=>{\n            ancestor.addEventListener(\"scroll\", onScroll, {\n                passive: true\n            });\n        });\n        return ()=>{\n            escapeKey && doc.removeEventListener(\"keydown\", escapeKeyCapture ? closeOnEscapeKeyDownCapture : closeOnEscapeKeyDown, escapeKeyCapture);\n            outsidePress && doc.removeEventListener(outsidePressEvent, outsidePressCapture ? closeOnPressOutsideCapture : closeOnPressOutside, outsidePressCapture);\n            ancestors.forEach((ancestor)=>{\n                ancestor.removeEventListener(\"scroll\", onScroll);\n            });\n        };\n    }, [\n        dataRef,\n        floating,\n        domReference,\n        reference,\n        escapeKey,\n        outsidePress,\n        outsidePressEvent,\n        open,\n        onOpenChange,\n        ancestorScroll,\n        enabled,\n        escapeKeyBubbles,\n        outsidePressBubbles,\n        closeOnEscapeKeyDown,\n        escapeKeyCapture,\n        closeOnEscapeKeyDownCapture,\n        closeOnPressOutside,\n        outsidePressCapture,\n        closeOnPressOutsideCapture\n    ]);\n    // biome-ignore lint/correctness/useExhaustiveDependencies: intentional\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        insideReactTreeRef.current = false;\n    }, [\n        outsidePress,\n        outsidePressEvent\n    ]);\n    return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>{\n        if (!enabled) {\n            return {};\n        }\n        return {\n            reference: {\n                onKeyDown: closeOnEscapeKeyDown,\n                [bubbleHandlerKeys[referencePressEvent]]: (event)=>{\n                    if (referencePress) {\n                        onOpenChange(false, event.nativeEvent, \"reference-press\");\n                    }\n                }\n            },\n            floating: {\n                onKeyDown: closeOnEscapeKeyDown,\n                onMouseDown () {\n                    endedOrStartedInsideRef.current = true;\n                },\n                onMouseUp () {\n                    endedOrStartedInsideRef.current = true;\n                },\n                [captureHandlerKeys[outsidePressEvent]]: ()=>{\n                    insideReactTreeRef.current = true;\n                }\n            }\n        };\n    }, [\n        enabled,\n        referencePress,\n        outsidePressEvent,\n        referencePressEvent,\n        onOpenChange,\n        closeOnEscapeKeyDown\n    ]);\n}\nlet devMessageSet;\nif (true) {\n    devMessageSet = /*#__PURE__*/ new Set();\n}\n/**\n * Provides data to position a floating element and context to add interactions.\n * @see https://floating-ui.com/docs/useFloating\n */ function useFloating(options) {\n    var _options$elements2;\n    if (options === void 0) {\n        options = {};\n    }\n    const { open = false, onOpenChange: unstable_onOpenChange, nodeId } = options;\n    if (true) {\n        var _options$elements;\n        const err = \"Floating UI: Cannot pass a virtual element to the \" + \"`elements.reference` option, as it must be a real DOM element. \" + \"Use `refs.setPositionReference` instead.\";\n        if ((_options$elements = options.elements) != null && _options$elements.reference && !(0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_4__.isElement)(options.elements.reference)) {\n            var _devMessageSet;\n            if (!((_devMessageSet = devMessageSet) != null && _devMessageSet.has(err))) {\n                var _devMessageSet2;\n                (_devMessageSet2 = devMessageSet) == null || _devMessageSet2.add(err);\n                console.error(err);\n            }\n        }\n    }\n    const [_domReference, setDomReference] = react__WEBPACK_IMPORTED_MODULE_0__.useState(null);\n    const domReference = ((_options$elements2 = options.elements) == null ? void 0 : _options$elements2.reference) || _domReference;\n    const position = (0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_1__.useFloating)(options);\n    const tree = useFloatingTree();\n    const nested = useFloatingParentNodeId() != null;\n    const onOpenChange = useEffectEvent((open, event, reason)=>{\n        if (open) {\n            dataRef.current.openEvent = event;\n        }\n        events.emit(\"openchange\", {\n            open,\n            event,\n            reason,\n            nested\n        });\n        unstable_onOpenChange == null || unstable_onOpenChange(open, event, reason);\n    });\n    const domReferenceRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n    const dataRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef({});\n    const events = react__WEBPACK_IMPORTED_MODULE_0__.useState(()=>createPubSub())[0];\n    const floatingId = useId();\n    const setPositionReference = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((node)=>{\n        const positionReference = (0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_4__.isElement)(node) ? {\n            getBoundingClientRect: ()=>node.getBoundingClientRect(),\n            contextElement: node\n        } : node;\n        position.refs.setReference(positionReference);\n    }, [\n        position.refs\n    ]);\n    const setReference = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((node)=>{\n        if ((0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_4__.isElement)(node) || node === null) {\n            domReferenceRef.current = node;\n            setDomReference(node);\n        }\n        // Backwards-compatibility for passing a virtual element to `reference`\n        // after it has set the DOM reference.\n        if ((0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_4__.isElement)(position.refs.reference.current) || position.refs.reference.current === null || // Don't allow setting virtual elements using the old technique back to\n        // `null` to support `positionReference` + an unstable `reference`\n        // callback ref.\n        node !== null && !(0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_4__.isElement)(node)) {\n            position.refs.setReference(node);\n        }\n    }, [\n        position.refs\n    ]);\n    const refs = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>({\n            ...position.refs,\n            setReference,\n            setPositionReference,\n            domReference: domReferenceRef\n        }), [\n        position.refs,\n        setReference,\n        setPositionReference\n    ]);\n    const elements = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>({\n            ...position.elements,\n            domReference: domReference\n        }), [\n        position.elements,\n        domReference\n    ]);\n    const context = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>({\n            ...position,\n            refs,\n            elements,\n            dataRef,\n            nodeId,\n            floatingId,\n            events,\n            open,\n            onOpenChange\n        }), [\n        position,\n        nodeId,\n        floatingId,\n        events,\n        open,\n        onOpenChange,\n        refs,\n        elements\n    ]);\n    index(()=>{\n        const node = tree == null ? void 0 : tree.nodesRef.current.find((node)=>node.id === nodeId);\n        if (node) {\n            node.context = context;\n        }\n    });\n    return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>({\n            ...position,\n            context,\n            refs,\n            elements\n        }), [\n        position,\n        refs,\n        elements,\n        context\n    ]);\n}\n/**\n * Opens the floating element while the reference element has focus, like CSS\n * `:focus`.\n * @see https://floating-ui.com/docs/useFocus\n */ function useFocus(context, props) {\n    if (props === void 0) {\n        props = {};\n    }\n    const { open, onOpenChange, events, refs, elements: { domReference } } = context;\n    const { enabled = true, visibleOnly = true } = props;\n    const blockFocusRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(false);\n    const timeoutRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef();\n    const keyboardModalityRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(true);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        if (!enabled) {\n            return;\n        }\n        const win = (0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_4__.getWindow)(domReference);\n        // If the reference was focused and the user left the tab/window, and the\n        // floating element was not open, the focus should be blocked when they\n        // return to the tab/window.\n        function onBlur() {\n            if (!open && (0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_4__.isHTMLElement)(domReference) && domReference === (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.activeElement)((0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.getDocument)(domReference))) {\n                blockFocusRef.current = true;\n            }\n        }\n        function onKeyDown() {\n            keyboardModalityRef.current = true;\n        }\n        win.addEventListener(\"blur\", onBlur);\n        win.addEventListener(\"keydown\", onKeyDown, true);\n        return ()=>{\n            win.removeEventListener(\"blur\", onBlur);\n            win.removeEventListener(\"keydown\", onKeyDown, true);\n        };\n    }, [\n        domReference,\n        open,\n        enabled\n    ]);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        if (!enabled) {\n            return;\n        }\n        function onOpenChange(_ref) {\n            let { reason } = _ref;\n            if (reason === \"reference-press\" || reason === \"escape-key\") {\n                blockFocusRef.current = true;\n            }\n        }\n        events.on(\"openchange\", onOpenChange);\n        return ()=>{\n            events.off(\"openchange\", onOpenChange);\n        };\n    }, [\n        events,\n        enabled\n    ]);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        return ()=>{\n            clearTimeout(timeoutRef.current);\n        };\n    }, []);\n    return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>{\n        if (!enabled) {\n            return {};\n        }\n        return {\n            reference: {\n                onPointerDown (event) {\n                    if ((0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.isVirtualPointerEvent)(event.nativeEvent)) return;\n                    keyboardModalityRef.current = false;\n                },\n                onMouseLeave () {\n                    blockFocusRef.current = false;\n                },\n                onFocus (event) {\n                    if (blockFocusRef.current) return;\n                    const target = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.getTarget)(event.nativeEvent);\n                    if (visibleOnly && (0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_4__.isElement)(target)) {\n                        try {\n                            // Mac Safari unreliably matches `:focus-visible` on the reference\n                            // if focus was outside the page initially - use the fallback\n                            // instead.\n                            if ((0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.isSafari)() && (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.isMac)()) throw Error();\n                            if (!target.matches(\":focus-visible\")) return;\n                        } catch (e) {\n                            // Old browsers will throw an error when using `:focus-visible`.\n                            if (!keyboardModalityRef.current && !(0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.isTypeableElement)(target)) {\n                                return;\n                            }\n                        }\n                    }\n                    onOpenChange(true, event.nativeEvent, \"focus\");\n                },\n                onBlur (event) {\n                    blockFocusRef.current = false;\n                    const relatedTarget = event.relatedTarget;\n                    // Hit the non-modal focus management portal guard. Focus will be\n                    // moved into the floating element immediately after.\n                    const movedToFocusGuard = (0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_4__.isElement)(relatedTarget) && relatedTarget.hasAttribute(createAttribute(\"focus-guard\")) && relatedTarget.getAttribute(\"data-type\") === \"outside\";\n                    // Wait for the window blur listener to fire.\n                    timeoutRef.current = window.setTimeout(()=>{\n                        const activeEl = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.activeElement)(domReference ? domReference.ownerDocument : document);\n                        // Focus left the page, keep it open.\n                        if (!relatedTarget && activeEl === domReference) return;\n                        // When focusing the reference element (e.g. regular click), then\n                        // clicking into the floating element, prevent it from hiding.\n                        // Note: it must be focusable, e.g. `tabindex=\"-1\"`.\n                        // We can not rely on relatedTarget to point to the correct element\n                        // as it will only point to the shadow host of the newly focused element\n                        // and not the element that actually has received focus if it is located\n                        // inside a shadow root.\n                        if ((0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.contains)(refs.floating.current, activeEl) || (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.contains)(domReference, activeEl) || movedToFocusGuard) {\n                            return;\n                        }\n                        onOpenChange(false, event.nativeEvent, \"focus\");\n                    });\n                }\n            }\n        };\n    }, [\n        enabled,\n        visibleOnly,\n        domReference,\n        refs,\n        onOpenChange\n    ]);\n}\nconst ACTIVE_KEY = \"active\";\nconst SELECTED_KEY = \"selected\";\nfunction mergeProps(userProps, propsList, elementKey) {\n    const map = new Map();\n    const isItem = elementKey === \"item\";\n    let domUserProps = userProps;\n    if (isItem && userProps) {\n        const { [ACTIVE_KEY]: _, [SELECTED_KEY]: __, ...validProps } = userProps;\n        domUserProps = validProps;\n    }\n    return {\n        ...elementKey === \"floating\" && {\n            tabIndex: -1\n        },\n        ...domUserProps,\n        ...propsList.map((value)=>{\n            const propsOrGetProps = value ? value[elementKey] : null;\n            if (typeof propsOrGetProps === \"function\") {\n                return userProps ? propsOrGetProps(userProps) : null;\n            }\n            return propsOrGetProps;\n        }).concat(userProps).reduce((acc, props)=>{\n            if (!props) {\n                return acc;\n            }\n            Object.entries(props).forEach((_ref)=>{\n                let [key, value] = _ref;\n                if (isItem && [\n                    ACTIVE_KEY,\n                    SELECTED_KEY\n                ].includes(key)) {\n                    return;\n                }\n                if (key.indexOf(\"on\") === 0) {\n                    if (!map.has(key)) {\n                        map.set(key, []);\n                    }\n                    if (typeof value === \"function\") {\n                        var _map$get;\n                        (_map$get = map.get(key)) == null || _map$get.push(value);\n                        acc[key] = function() {\n                            var _map$get2;\n                            for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n                                args[_key] = arguments[_key];\n                            }\n                            return (_map$get2 = map.get(key)) == null ? void 0 : _map$get2.map((fn)=>fn(...args)).find((val)=>val !== undefined);\n                        };\n                    }\n                } else {\n                    acc[key] = value;\n                }\n            });\n            return acc;\n        }, {})\n    };\n}\n/**\n * Merges an array of interaction hooks' props into prop getters, allowing\n * event handler functions to be composed together without overwriting one\n * another.\n * @see https://floating-ui.com/docs/useInteractions\n */ function useInteractions(propsList) {\n    if (propsList === void 0) {\n        propsList = [];\n    }\n    // The dependencies are a dynamic array, so we can't use the linter's\n    // suggestion to add it to the deps array.\n    const deps = propsList;\n    // biome-ignore lint/correctness/useExhaustiveDependencies: intentional\n    const getReferenceProps = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((userProps)=>mergeProps(userProps, propsList, \"reference\"), deps);\n    // biome-ignore lint/correctness/useExhaustiveDependencies: intentional\n    const getFloatingProps = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((userProps)=>mergeProps(userProps, propsList, \"floating\"), deps);\n    // biome-ignore lint/correctness/useExhaustiveDependencies: intentional\n    const getItemProps = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((userProps)=>mergeProps(userProps, propsList, \"item\"), // Granularly check for `item` changes, because the `getItemProps` getter\n    // should be as referentially stable as possible since it may be passed as\n    // a prop to many components. All `item` key values must therefore be\n    // memoized.\n    propsList.map((key)=>key == null ? void 0 : key.item));\n    return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>({\n            getReferenceProps,\n            getFloatingProps,\n            getItemProps\n        }), [\n        getReferenceProps,\n        getFloatingProps,\n        getItemProps\n    ]);\n}\nlet isPreventScrollSupported = false;\nfunction doSwitch(orientation, vertical, horizontal) {\n    switch(orientation){\n        case \"vertical\":\n            return vertical;\n        case \"horizontal\":\n            return horizontal;\n        default:\n            return vertical || horizontal;\n    }\n}\nfunction isMainOrientationKey(key, orientation) {\n    const vertical = key === ARROW_UP || key === ARROW_DOWN;\n    const horizontal = key === ARROW_LEFT || key === ARROW_RIGHT;\n    return doSwitch(orientation, vertical, horizontal);\n}\nfunction isMainOrientationToEndKey(key, orientation, rtl) {\n    const vertical = key === ARROW_DOWN;\n    const horizontal = rtl ? key === ARROW_LEFT : key === ARROW_RIGHT;\n    return doSwitch(orientation, vertical, horizontal) || key === \"Enter\" || key === \" \" || key === \"\";\n}\nfunction isCrossOrientationOpenKey(key, orientation, rtl) {\n    const vertical = rtl ? key === ARROW_LEFT : key === ARROW_RIGHT;\n    const horizontal = key === ARROW_DOWN;\n    return doSwitch(orientation, vertical, horizontal);\n}\nfunction isCrossOrientationCloseKey(key, orientation, rtl) {\n    const vertical = rtl ? key === ARROW_RIGHT : key === ARROW_LEFT;\n    const horizontal = key === ARROW_UP;\n    return doSwitch(orientation, vertical, horizontal);\n}\n/**\n * Adds arrow key-based navigation of a list of items, either using real DOM\n * focus or virtual focus.\n * @see https://floating-ui.com/docs/useListNavigation\n */ function useListNavigation(context, props) {\n    const { open, onOpenChange, refs, elements: { domReference, floating } } = context;\n    const { listRef, activeIndex, onNavigate: unstable_onNavigate = ()=>{}, enabled = true, selectedIndex = null, allowEscape = false, loop = false, nested = false, rtl = false, virtual = false, focusItemOnOpen = \"auto\", focusItemOnHover = true, openOnArrowKeyDown = true, disabledIndices = undefined, orientation = \"vertical\", cols = 1, scrollItemIntoView = true, virtualItemRef, itemSizes, dense = false } = props;\n    if (true) {\n        if (allowEscape) {\n            if (!loop) {\n                console.warn([\n                    \"Floating UI: `useListNavigation` looping must be enabled to allow\",\n                    \"escaping.\"\n                ].join(\" \"));\n            }\n            if (!virtual) {\n                console.warn([\n                    \"Floating UI: `useListNavigation` must be virtual to allow\",\n                    \"escaping.\"\n                ].join(\" \"));\n            }\n        }\n        if (orientation === \"vertical\" && cols > 1) {\n            console.warn([\n                \"Floating UI: In grid list navigation mode (`cols` > 1), the\",\n                '`orientation` should be either \"horizontal\" or \"both\".'\n            ].join(\" \"));\n        }\n    }\n    const parentId = useFloatingParentNodeId();\n    const tree = useFloatingTree();\n    const onNavigate = useEffectEvent(unstable_onNavigate);\n    const focusItemOnOpenRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(focusItemOnOpen);\n    const indexRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(selectedIndex != null ? selectedIndex : -1);\n    const keyRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n    const isPointerModalityRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(true);\n    const previousOnNavigateRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(onNavigate);\n    const previousMountedRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(!!floating);\n    const forceSyncFocus = react__WEBPACK_IMPORTED_MODULE_0__.useRef(false);\n    const forceScrollIntoViewRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(false);\n    const disabledIndicesRef = useLatestRef(disabledIndices);\n    const latestOpenRef = useLatestRef(open);\n    const scrollItemIntoViewRef = useLatestRef(scrollItemIntoView);\n    const [activeId, setActiveId] = react__WEBPACK_IMPORTED_MODULE_0__.useState();\n    const [virtualId, setVirtualId] = react__WEBPACK_IMPORTED_MODULE_0__.useState();\n    const focusItem = useEffectEvent(function(listRef, indexRef, forceScrollIntoView) {\n        if (forceScrollIntoView === void 0) {\n            forceScrollIntoView = false;\n        }\n        const item = listRef.current[indexRef.current];\n        if (!item) return;\n        if (virtual) {\n            setActiveId(item.id);\n            tree == null || tree.events.emit(\"virtualfocus\", item);\n            if (virtualItemRef) {\n                virtualItemRef.current = item;\n            }\n        } else {\n            enqueueFocus(item, {\n                preventScroll: true,\n                // Mac Safari does not move the virtual cursor unless the focus call\n                // is sync. However, for the very first focus call, we need to wait\n                // for the position to be ready in order to prevent unwanted\n                // scrolling. This means the virtual cursor will not move to the first\n                // item when first opening the floating element, but will on\n                // subsequent calls. `preventScroll` is supported in modern Safari,\n                // so we can use that instead.\n                // iOS Safari must be async or the first item will not be focused.\n                sync: (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.isMac)() && (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.isSafari)() ? isPreventScrollSupported || forceSyncFocus.current : false\n            });\n        }\n        requestAnimationFrame(()=>{\n            const scrollIntoViewOptions = scrollItemIntoViewRef.current;\n            const shouldScrollIntoView = scrollIntoViewOptions && item && (forceScrollIntoView || !isPointerModalityRef.current);\n            if (shouldScrollIntoView) {\n                // JSDOM doesn't support `.scrollIntoView()` but it's widely supported\n                // by all browsers.\n                item.scrollIntoView == null || item.scrollIntoView(typeof scrollIntoViewOptions === \"boolean\" ? {\n                    block: \"nearest\",\n                    inline: \"nearest\"\n                } : scrollIntoViewOptions);\n            }\n        });\n    });\n    index(()=>{\n        document.createElement(\"div\").focus({\n            get preventScroll () {\n                isPreventScrollSupported = true;\n                return false;\n            }\n        });\n    }, []);\n    // Sync `selectedIndex` to be the `activeIndex` upon opening the floating\n    // element. Also, reset `activeIndex` upon closing the floating element.\n    index(()=>{\n        if (!enabled) {\n            return;\n        }\n        if (open && floating) {\n            if (focusItemOnOpenRef.current && selectedIndex != null) {\n                // Regardless of the pointer modality, we want to ensure the selected\n                // item comes into view when the floating element is opened.\n                forceScrollIntoViewRef.current = true;\n                indexRef.current = selectedIndex;\n                onNavigate(selectedIndex);\n            }\n        } else if (previousMountedRef.current) {\n            // Since the user can specify `onNavigate` conditionally\n            // (onNavigate: open ? setActiveIndex : setSelectedIndex),\n            // we store and call the previous function.\n            indexRef.current = -1;\n            previousOnNavigateRef.current(null);\n        }\n    }, [\n        enabled,\n        open,\n        floating,\n        selectedIndex,\n        onNavigate\n    ]);\n    // Sync `activeIndex` to be the focused item while the floating element is\n    // open.\n    index(()=>{\n        if (!enabled) {\n            return;\n        }\n        if (open && floating) {\n            if (activeIndex == null) {\n                forceSyncFocus.current = false;\n                if (selectedIndex != null) {\n                    return;\n                }\n                // Reset while the floating element was open (e.g. the list changed).\n                if (previousMountedRef.current) {\n                    indexRef.current = -1;\n                    focusItem(listRef, indexRef);\n                }\n                // Initial sync.\n                if (!previousMountedRef.current && focusItemOnOpenRef.current && (keyRef.current != null || focusItemOnOpenRef.current === true && keyRef.current == null)) {\n                    let runs = 0;\n                    const waitForListPopulated = ()=>{\n                        if (listRef.current[0] == null) {\n                            // Avoid letting the browser paint if possible on the first try,\n                            // otherwise use rAF. Don't try more than twice, since something\n                            // is wrong otherwise.\n                            if (runs < 2) {\n                                const scheduler = runs ? requestAnimationFrame : queueMicrotask;\n                                scheduler(waitForListPopulated);\n                            }\n                            runs++;\n                        } else {\n                            indexRef.current = keyRef.current == null || isMainOrientationToEndKey(keyRef.current, orientation, rtl) || nested ? getMinIndex(listRef, disabledIndicesRef.current) : getMaxIndex(listRef, disabledIndicesRef.current);\n                            keyRef.current = null;\n                            onNavigate(indexRef.current);\n                        }\n                    };\n                    waitForListPopulated();\n                }\n            } else if (!isIndexOutOfBounds(listRef, activeIndex)) {\n                indexRef.current = activeIndex;\n                focusItem(listRef, indexRef, forceScrollIntoViewRef.current);\n                forceScrollIntoViewRef.current = false;\n            }\n        }\n    }, [\n        enabled,\n        open,\n        floating,\n        activeIndex,\n        selectedIndex,\n        nested,\n        listRef,\n        orientation,\n        rtl,\n        onNavigate,\n        focusItem,\n        disabledIndicesRef\n    ]);\n    // Ensure the parent floating element has focus when a nested child closes\n    // to allow arrow key navigation to work after the pointer leaves the child.\n    index(()=>{\n        var _nodes$find;\n        if (!enabled || floating || !tree || virtual || !previousMountedRef.current) {\n            return;\n        }\n        const nodes = tree.nodesRef.current;\n        const parent = (_nodes$find = nodes.find((node)=>node.id === parentId)) == null || (_nodes$find = _nodes$find.context) == null ? void 0 : _nodes$find.elements.floating;\n        const activeEl = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.activeElement)((0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.getDocument)(floating));\n        const treeContainsActiveEl = nodes.some((node)=>node.context && (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.contains)(node.context.elements.floating, activeEl));\n        if (parent && !treeContainsActiveEl && isPointerModalityRef.current) {\n            parent.focus({\n                preventScroll: true\n            });\n        }\n    }, [\n        enabled,\n        floating,\n        tree,\n        parentId,\n        virtual\n    ]);\n    index(()=>{\n        if (!enabled || !tree || !virtual || parentId) return;\n        function handleVirtualFocus(item) {\n            setVirtualId(item.id);\n            if (virtualItemRef) {\n                virtualItemRef.current = item;\n            }\n        }\n        tree.events.on(\"virtualfocus\", handleVirtualFocus);\n        return ()=>{\n            tree.events.off(\"virtualfocus\", handleVirtualFocus);\n        };\n    }, [\n        enabled,\n        tree,\n        virtual,\n        parentId,\n        virtualItemRef\n    ]);\n    index(()=>{\n        previousOnNavigateRef.current = onNavigate;\n        previousMountedRef.current = !!floating;\n    });\n    index(()=>{\n        if (!open) {\n            keyRef.current = null;\n        }\n    }, [\n        open\n    ]);\n    const hasActiveIndex = activeIndex != null;\n    const item = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>{\n        function syncCurrentTarget(currentTarget) {\n            if (!open) return;\n            const index = listRef.current.indexOf(currentTarget);\n            if (index !== -1) {\n                onNavigate(index);\n            }\n        }\n        const props = {\n            onFocus (_ref) {\n                let { currentTarget } = _ref;\n                syncCurrentTarget(currentTarget);\n            },\n            onClick: (_ref2)=>{\n                let { currentTarget } = _ref2;\n                return currentTarget.focus({\n                    preventScroll: true\n                });\n            },\n            // Safari\n            ...focusItemOnHover && {\n                onMouseMove (_ref3) {\n                    let { currentTarget } = _ref3;\n                    syncCurrentTarget(currentTarget);\n                },\n                onPointerLeave (_ref4) {\n                    let { pointerType } = _ref4;\n                    if (!isPointerModalityRef.current || pointerType === \"touch\") {\n                        return;\n                    }\n                    indexRef.current = -1;\n                    focusItem(listRef, indexRef);\n                    onNavigate(null);\n                    if (!virtual) {\n                        enqueueFocus(refs.floating.current, {\n                            preventScroll: true\n                        });\n                    }\n                }\n            }\n        };\n        return props;\n    }, [\n        open,\n        refs,\n        focusItem,\n        focusItemOnHover,\n        listRef,\n        onNavigate,\n        virtual\n    ]);\n    return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>{\n        if (!enabled) {\n            return {};\n        }\n        const disabledIndices = disabledIndicesRef.current;\n        function onKeyDown(event) {\n            isPointerModalityRef.current = false;\n            forceSyncFocus.current = true;\n            // If the floating element is animating out, ignore navigation. Otherwise,\n            // the `activeIndex` gets set to 0 despite not being open so the next time\n            // the user ArrowDowns, the first item won't be focused.\n            if (!latestOpenRef.current && event.currentTarget === refs.floating.current) {\n                return;\n            }\n            if (nested && isCrossOrientationCloseKey(event.key, orientation, rtl)) {\n                (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.stopEvent)(event);\n                onOpenChange(false, event.nativeEvent, \"list-navigation\");\n                if ((0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_4__.isHTMLElement)(domReference) && !virtual) {\n                    domReference.focus();\n                }\n                return;\n            }\n            const currentIndex = indexRef.current;\n            const minIndex = getMinIndex(listRef, disabledIndices);\n            const maxIndex = getMaxIndex(listRef, disabledIndices);\n            if (event.key === \"Home\") {\n                (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.stopEvent)(event);\n                indexRef.current = minIndex;\n                onNavigate(indexRef.current);\n            }\n            if (event.key === \"End\") {\n                (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.stopEvent)(event);\n                indexRef.current = maxIndex;\n                onNavigate(indexRef.current);\n            }\n            // Grid navigation.\n            if (cols > 1) {\n                const sizes = itemSizes || Array.from({\n                    length: listRef.current.length\n                }, ()=>({\n                        width: 1,\n                        height: 1\n                    }));\n                // To calculate movements on the grid, we use hypothetical cell indices\n                // as if every item was 1x1, then convert back to real indices.\n                const cellMap = buildCellMap(sizes, cols, dense);\n                const minGridIndex = cellMap.findIndex((index)=>index != null && !(disabledIndices != null && disabledIndices.includes(index)));\n                // last enabled index\n                const maxGridIndex = cellMap.reduce((foundIndex, index, cellIndex)=>index != null && !(disabledIndices != null && disabledIndices.includes(index)) ? cellIndex : foundIndex, -1);\n                indexRef.current = cellMap[getGridNavigatedIndex({\n                    current: cellMap.map((itemIndex)=>itemIndex != null ? listRef.current[itemIndex] : null)\n                }, {\n                    event,\n                    orientation,\n                    loop,\n                    cols,\n                    // treat undefined (empty grid spaces) as disabled indices so we\n                    // don't end up in them\n                    disabledIndices: getCellIndices([\n                        ...disabledIndices || [],\n                        undefined\n                    ], cellMap),\n                    minIndex: minGridIndex,\n                    maxIndex: maxGridIndex,\n                    prevIndex: getCellIndexOfCorner(indexRef.current, sizes, cellMap, cols, // use a corner matching the edge closest to the direction\n                    // we're moving in so we don't end up in the same item. Prefer\n                    // top/left over bottom/right.\n                    event.key === ARROW_DOWN ? \"bl\" : event.key === ARROW_RIGHT ? \"tr\" : \"tl\"),\n                    stopEvent: true\n                })]; // navigated cell will never be nullish\n                onNavigate(indexRef.current);\n                if (orientation === \"both\") {\n                    return;\n                }\n            }\n            if (isMainOrientationKey(event.key, orientation)) {\n                (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.stopEvent)(event);\n                // Reset the index if no item is focused.\n                if (open && !virtual && (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.activeElement)(event.currentTarget.ownerDocument) === event.currentTarget) {\n                    indexRef.current = isMainOrientationToEndKey(event.key, orientation, rtl) ? minIndex : maxIndex;\n                    onNavigate(indexRef.current);\n                    return;\n                }\n                if (isMainOrientationToEndKey(event.key, orientation, rtl)) {\n                    if (loop) {\n                        indexRef.current = currentIndex >= maxIndex ? allowEscape && currentIndex !== listRef.current.length ? -1 : minIndex : findNonDisabledIndex(listRef, {\n                            startingIndex: currentIndex,\n                            disabledIndices\n                        });\n                    } else {\n                        indexRef.current = Math.min(maxIndex, findNonDisabledIndex(listRef, {\n                            startingIndex: currentIndex,\n                            disabledIndices\n                        }));\n                    }\n                } else {\n                    if (loop) {\n                        indexRef.current = currentIndex <= minIndex ? allowEscape && currentIndex !== -1 ? listRef.current.length : maxIndex : findNonDisabledIndex(listRef, {\n                            startingIndex: currentIndex,\n                            decrement: true,\n                            disabledIndices\n                        });\n                    } else {\n                        indexRef.current = Math.max(minIndex, findNonDisabledIndex(listRef, {\n                            startingIndex: currentIndex,\n                            decrement: true,\n                            disabledIndices\n                        }));\n                    }\n                }\n                if (isIndexOutOfBounds(listRef, indexRef.current)) {\n                    onNavigate(null);\n                } else {\n                    onNavigate(indexRef.current);\n                }\n            }\n        }\n        function checkVirtualMouse(event) {\n            if (focusItemOnOpen === \"auto\" && (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.isVirtualClick)(event.nativeEvent)) {\n                focusItemOnOpenRef.current = true;\n            }\n        }\n        function checkVirtualPointer(event) {\n            // `pointerdown` fires first, reset the state then perform the checks.\n            focusItemOnOpenRef.current = focusItemOnOpen;\n            if (focusItemOnOpen === \"auto\" && (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.isVirtualPointerEvent)(event.nativeEvent)) {\n                focusItemOnOpenRef.current = true;\n            }\n        }\n        const ariaActiveDescendantProp = virtual && open && hasActiveIndex && {\n            \"aria-activedescendant\": virtualId || activeId\n        };\n        const activeItem = listRef.current.find((item)=>(item == null ? void 0 : item.id) === activeId);\n        return {\n            reference: {\n                ...ariaActiveDescendantProp,\n                onKeyDown (event) {\n                    isPointerModalityRef.current = false;\n                    const isArrowKey = event.key.indexOf(\"Arrow\") === 0;\n                    const isCrossOpenKey = isCrossOrientationOpenKey(event.key, orientation, rtl);\n                    const isCrossCloseKey = isCrossOrientationCloseKey(event.key, orientation, rtl);\n                    const isMainKey = isMainOrientationKey(event.key, orientation);\n                    const isNavigationKey = (nested ? isCrossOpenKey : isMainKey) || event.key === \"Enter\" || event.key.trim() === \"\";\n                    if (virtual && open) {\n                        const rootNode = tree == null ? void 0 : tree.nodesRef.current.find((node)=>node.parentId == null);\n                        const deepestNode = tree && rootNode ? getDeepestNode(tree.nodesRef.current, rootNode.id) : null;\n                        if (isArrowKey && deepestNode && virtualItemRef) {\n                            const eventObject = new KeyboardEvent(\"keydown\", {\n                                key: event.key,\n                                bubbles: true\n                            });\n                            if (isCrossOpenKey || isCrossCloseKey) {\n                                var _deepestNode$context, _deepestNode$context2;\n                                const isCurrentTarget = ((_deepestNode$context = deepestNode.context) == null ? void 0 : _deepestNode$context.elements.domReference) === event.currentTarget;\n                                const dispatchItem = isCrossCloseKey && !isCurrentTarget ? (_deepestNode$context2 = deepestNode.context) == null ? void 0 : _deepestNode$context2.elements.domReference : isCrossOpenKey ? activeItem : null;\n                                if (dispatchItem) {\n                                    (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.stopEvent)(event);\n                                    dispatchItem.dispatchEvent(eventObject);\n                                    setVirtualId(undefined);\n                                }\n                            }\n                            if (isMainKey && deepestNode.context) {\n                                if (deepestNode.context.open && deepestNode.parentId && event.currentTarget !== deepestNode.context.elements.domReference) {\n                                    var _deepestNode$context$;\n                                    (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.stopEvent)(event);\n                                    (_deepestNode$context$ = deepestNode.context.elements.domReference) == null || _deepestNode$context$.dispatchEvent(eventObject);\n                                    return;\n                                }\n                            }\n                        }\n                        return onKeyDown(event);\n                    }\n                    // If a floating element should not open on arrow key down, avoid\n                    // setting `activeIndex` while it's closed.\n                    if (!open && !openOnArrowKeyDown && isArrowKey) {\n                        return;\n                    }\n                    if (isNavigationKey) {\n                        keyRef.current = nested && isMainKey ? null : event.key;\n                    }\n                    if (nested) {\n                        if (isCrossOpenKey) {\n                            (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.stopEvent)(event);\n                            if (open) {\n                                indexRef.current = getMinIndex(listRef, disabledIndices);\n                                onNavigate(indexRef.current);\n                            } else {\n                                onOpenChange(true, event.nativeEvent, \"list-navigation\");\n                            }\n                        }\n                        return;\n                    }\n                    if (isMainKey) {\n                        if (selectedIndex != null) {\n                            indexRef.current = selectedIndex;\n                        }\n                        (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.stopEvent)(event);\n                        if (!open && openOnArrowKeyDown) {\n                            onOpenChange(true, event.nativeEvent, \"list-navigation\");\n                        } else {\n                            onKeyDown(event);\n                        }\n                        if (open) {\n                            onNavigate(indexRef.current);\n                        }\n                    }\n                },\n                onFocus () {\n                    if (open) {\n                        onNavigate(null);\n                    }\n                },\n                onPointerDown: checkVirtualPointer,\n                onMouseDown: checkVirtualMouse,\n                onClick: checkVirtualMouse\n            },\n            floating: {\n                \"aria-orientation\": orientation === \"both\" ? undefined : orientation,\n                ...!(0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.isTypeableCombobox)(domReference) && ariaActiveDescendantProp,\n                onKeyDown,\n                onPointerMove () {\n                    isPointerModalityRef.current = true;\n                }\n            },\n            item\n        };\n    }, [\n        domReference,\n        refs,\n        activeId,\n        virtualId,\n        disabledIndicesRef,\n        latestOpenRef,\n        listRef,\n        enabled,\n        orientation,\n        rtl,\n        virtual,\n        open,\n        hasActiveIndex,\n        nested,\n        selectedIndex,\n        openOnArrowKeyDown,\n        allowEscape,\n        cols,\n        loop,\n        focusItemOnOpen,\n        onNavigate,\n        onOpenChange,\n        item,\n        tree,\n        virtualItemRef,\n        itemSizes,\n        dense\n    ]);\n}\nconst componentRoleToAriaRoleMap = /*#__PURE__*/ new Map([\n    [\n        \"select\",\n        \"listbox\"\n    ],\n    [\n        \"combobox\",\n        \"listbox\"\n    ],\n    [\n        \"label\",\n        false\n    ]\n]);\n/**\n * Adds base screen reader props to the reference and floating elements for a\n * given floating element `role`.\n * @see https://floating-ui.com/docs/useRole\n */ function useRole(context, props) {\n    var _componentRoleToAriaR;\n    if (props === void 0) {\n        props = {};\n    }\n    const { open, floatingId } = context;\n    const { enabled = true, role = \"dialog\" } = props;\n    const ariaRole = (_componentRoleToAriaR = componentRoleToAriaRoleMap.get(role)) != null ? _componentRoleToAriaR : role;\n    const referenceId = useId();\n    const parentId = useFloatingParentNodeId();\n    const isNested = parentId != null;\n    return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>{\n        if (!enabled) return {};\n        const floatingProps = {\n            id: floatingId,\n            ...ariaRole && {\n                role: ariaRole\n            }\n        };\n        if (ariaRole === \"tooltip\" || role === \"label\") {\n            return {\n                reference: {\n                    [\"aria-\" + (role === \"label\" ? \"labelledby\" : \"describedby\")]: open ? floatingId : undefined\n                },\n                floating: floatingProps\n            };\n        }\n        return {\n            reference: {\n                \"aria-expanded\": open ? \"true\" : \"false\",\n                \"aria-haspopup\": ariaRole === \"alertdialog\" ? \"dialog\" : ariaRole,\n                \"aria-controls\": open ? floatingId : undefined,\n                ...ariaRole === \"listbox\" && {\n                    role: \"combobox\"\n                },\n                ...ariaRole === \"menu\" && {\n                    id: referenceId\n                },\n                ...ariaRole === \"menu\" && isNested && {\n                    role: \"menuitem\"\n                },\n                ...role === \"select\" && {\n                    \"aria-autocomplete\": \"none\"\n                },\n                ...role === \"combobox\" && {\n                    \"aria-autocomplete\": \"list\"\n                }\n            },\n            floating: {\n                ...floatingProps,\n                ...ariaRole === \"menu\" && {\n                    \"aria-labelledby\": referenceId\n                }\n            },\n            item (_ref) {\n                let { active, selected } = _ref;\n                const commonProps = {\n                    role: \"option\",\n                    ...active && {\n                        id: floatingId + \"-option\"\n                    }\n                };\n                // For `menu`, we are unable to tell if the item is a `menuitemradio`\n                // or `menuitemcheckbox`. For backwards-compatibility reasons, also\n                // avoid defaulting to `menuitem` as it may overwrite custom role props.\n                switch(role){\n                    case \"select\":\n                        return {\n                            ...commonProps,\n                            \"aria-selected\": active && selected\n                        };\n                    case \"combobox\":\n                        {\n                            return {\n                                ...commonProps,\n                                ...active && {\n                                    \"aria-selected\": true\n                                }\n                            };\n                        }\n                }\n                return {};\n            }\n        };\n    }, [\n        enabled,\n        role,\n        ariaRole,\n        open,\n        floatingId,\n        referenceId,\n        isNested\n    ]);\n}\n// Converts a JS style key like `backgroundColor` to a CSS transition-property\n// like `background-color`.\nconst camelCaseToKebabCase = (str)=>str.replace(/[A-Z]+(?![a-z])|[A-Z]/g, ($, ofs)=>(ofs ? \"-\" : \"\") + $.toLowerCase());\nfunction execWithArgsOrReturn(valueOrFn, args) {\n    return typeof valueOrFn === \"function\" ? valueOrFn(args) : valueOrFn;\n}\nfunction useDelayUnmount(open, durationMs) {\n    const [isMounted, setIsMounted] = react__WEBPACK_IMPORTED_MODULE_0__.useState(open);\n    if (open && !isMounted) {\n        setIsMounted(true);\n    }\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        if (!open) {\n            const timeout = setTimeout(()=>setIsMounted(false), durationMs);\n            return ()=>clearTimeout(timeout);\n        }\n    }, [\n        open,\n        durationMs\n    ]);\n    return isMounted;\n}\n/**\n * Provides a status string to apply CSS transitions to a floating element,\n * correctly handling placement-aware transitions.\n * @see https://floating-ui.com/docs/useTransition#usetransitionstatus\n */ function useTransitionStatus(context, props) {\n    if (props === void 0) {\n        props = {};\n    }\n    const { open, elements: { floating } } = context;\n    const { duration = 250 } = props;\n    const isNumberDuration = typeof duration === \"number\";\n    const closeDuration = (isNumberDuration ? duration : duration.close) || 0;\n    const [initiated, setInitiated] = react__WEBPACK_IMPORTED_MODULE_0__.useState(false);\n    const [status, setStatus] = react__WEBPACK_IMPORTED_MODULE_0__.useState(\"unmounted\");\n    const isMounted = useDelayUnmount(open, closeDuration);\n    // `initiated` check prevents this `setState` call from breaking\n    // <FloatingPortal />. This call is necessary to ensure subsequent opens\n    // after the initial one allows the correct side animation to play when the\n    // placement has changed.\n    index(()=>{\n        if (initiated && !isMounted) {\n            setStatus(\"unmounted\");\n        }\n    }, [\n        initiated,\n        isMounted\n    ]);\n    index(()=>{\n        if (!floating) return;\n        if (open) {\n            setStatus(\"initial\");\n            const frame = requestAnimationFrame(()=>{\n                setStatus(\"open\");\n            });\n            return ()=>{\n                cancelAnimationFrame(frame);\n            };\n        }\n        setInitiated(true);\n        setStatus(\"close\");\n    }, [\n        open,\n        floating\n    ]);\n    return {\n        isMounted,\n        status\n    };\n}\n/**\n * Provides styles to apply CSS transitions to a floating element, correctly\n * handling placement-aware transitions. Wrapper around `useTransitionStatus`.\n * @see https://floating-ui.com/docs/useTransition#usetransitionstyles\n */ function useTransitionStyles(context, props) {\n    if (props === void 0) {\n        props = {};\n    }\n    const { initial: unstable_initial = {\n        opacity: 0\n    }, open: unstable_open, close: unstable_close, common: unstable_common, duration = 250 } = props;\n    const placement = context.placement;\n    const side = placement.split(\"-\")[0];\n    const fnArgs = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>({\n            side,\n            placement\n        }), [\n        side,\n        placement\n    ]);\n    const isNumberDuration = typeof duration === \"number\";\n    const openDuration = (isNumberDuration ? duration : duration.open) || 0;\n    const closeDuration = (isNumberDuration ? duration : duration.close) || 0;\n    const [styles, setStyles] = react__WEBPACK_IMPORTED_MODULE_0__.useState(()=>({\n            ...execWithArgsOrReturn(unstable_common, fnArgs),\n            ...execWithArgsOrReturn(unstable_initial, fnArgs)\n        }));\n    const { isMounted, status } = useTransitionStatus(context, {\n        duration\n    });\n    const initialRef = useLatestRef(unstable_initial);\n    const openRef = useLatestRef(unstable_open);\n    const closeRef = useLatestRef(unstable_close);\n    const commonRef = useLatestRef(unstable_common);\n    index(()=>{\n        const initialStyles = execWithArgsOrReturn(initialRef.current, fnArgs);\n        const closeStyles = execWithArgsOrReturn(closeRef.current, fnArgs);\n        const commonStyles = execWithArgsOrReturn(commonRef.current, fnArgs);\n        const openStyles = execWithArgsOrReturn(openRef.current, fnArgs) || Object.keys(initialStyles).reduce((acc, key)=>{\n            acc[key] = \"\";\n            return acc;\n        }, {});\n        if (status === \"initial\") {\n            setStyles((styles)=>({\n                    transitionProperty: styles.transitionProperty,\n                    ...commonStyles,\n                    ...initialStyles\n                }));\n        }\n        if (status === \"open\") {\n            setStyles({\n                transitionProperty: Object.keys(openStyles).map(camelCaseToKebabCase).join(\",\"),\n                transitionDuration: openDuration + \"ms\",\n                ...commonStyles,\n                ...openStyles\n            });\n        }\n        if (status === \"close\") {\n            const styles = closeStyles || initialStyles;\n            setStyles({\n                transitionProperty: Object.keys(styles).map(camelCaseToKebabCase).join(\",\"),\n                transitionDuration: closeDuration + \"ms\",\n                ...commonStyles,\n                ...styles\n            });\n        }\n    }, [\n        closeDuration,\n        closeRef,\n        initialRef,\n        openRef,\n        commonRef,\n        openDuration,\n        status,\n        fnArgs\n    ]);\n    return {\n        isMounted,\n        styles\n    };\n}\n/**\n * Provides a matching callback that can be used to focus an item as the user\n * types, often used in tandem with `useListNavigation()`.\n * @see https://floating-ui.com/docs/useTypeahead\n */ function useTypeahead(context, props) {\n    var _ref;\n    const { open, dataRef } = context;\n    const { listRef, activeIndex, onMatch: unstable_onMatch, onTypingChange: unstable_onTypingChange, enabled = true, findMatch = null, resetMs = 750, ignoreKeys = [], selectedIndex = null } = props;\n    const timeoutIdRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef();\n    const stringRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(\"\");\n    const prevIndexRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef((_ref = selectedIndex != null ? selectedIndex : activeIndex) != null ? _ref : -1);\n    const matchIndexRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n    const onMatch = useEffectEvent(unstable_onMatch);\n    const onTypingChange = useEffectEvent(unstable_onTypingChange);\n    const findMatchRef = useLatestRef(findMatch);\n    const ignoreKeysRef = useLatestRef(ignoreKeys);\n    index(()=>{\n        if (open) {\n            clearTimeout(timeoutIdRef.current);\n            matchIndexRef.current = null;\n            stringRef.current = \"\";\n        }\n    }, [\n        open\n    ]);\n    index(()=>{\n        // Sync arrow key navigation but not typeahead navigation.\n        if (open && stringRef.current === \"\") {\n            var _ref2;\n            prevIndexRef.current = (_ref2 = selectedIndex != null ? selectedIndex : activeIndex) != null ? _ref2 : -1;\n        }\n    }, [\n        open,\n        selectedIndex,\n        activeIndex\n    ]);\n    return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>{\n        if (!enabled) {\n            return {};\n        }\n        function setTypingChange(value) {\n            if (value) {\n                if (!dataRef.current.typing) {\n                    dataRef.current.typing = value;\n                    onTypingChange(value);\n                }\n            } else {\n                if (dataRef.current.typing) {\n                    dataRef.current.typing = value;\n                    onTypingChange(value);\n                }\n            }\n        }\n        function getMatchingIndex(list, orderedList, string) {\n            const str = findMatchRef.current ? findMatchRef.current(orderedList, string) : orderedList.find((text)=>(text == null ? void 0 : text.toLocaleLowerCase().indexOf(string.toLocaleLowerCase())) === 0);\n            return str ? list.indexOf(str) : -1;\n        }\n        function onKeyDown(event) {\n            const listContent = listRef.current;\n            if (stringRef.current.length > 0 && stringRef.current[0] !== \" \") {\n                if (getMatchingIndex(listContent, listContent, stringRef.current) === -1) {\n                    setTypingChange(false);\n                } else if (event.key === \" \") {\n                    (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.stopEvent)(event);\n                }\n            }\n            if (listContent == null || ignoreKeysRef.current.includes(event.key) || // Character key.\n            event.key.length !== 1 || // Modifier key.\n            event.ctrlKey || event.metaKey || event.altKey) {\n                return;\n            }\n            if (open && event.key !== \" \") {\n                (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.stopEvent)(event);\n                setTypingChange(true);\n            }\n            // Bail out if the list contains a word like \"llama\" or \"aaron\". TODO:\n            // allow it in this case, too.\n            const allowRapidSuccessionOfFirstLetter = listContent.every((text)=>{\n                var _text$, _text$2;\n                return text ? ((_text$ = text[0]) == null ? void 0 : _text$.toLocaleLowerCase()) !== ((_text$2 = text[1]) == null ? void 0 : _text$2.toLocaleLowerCase()) : true;\n            });\n            // Allows the user to cycle through items that start with the same letter\n            // in rapid succession.\n            if (allowRapidSuccessionOfFirstLetter && stringRef.current === event.key) {\n                stringRef.current = \"\";\n                prevIndexRef.current = matchIndexRef.current;\n            }\n            stringRef.current += event.key;\n            clearTimeout(timeoutIdRef.current);\n            timeoutIdRef.current = setTimeout(()=>{\n                stringRef.current = \"\";\n                prevIndexRef.current = matchIndexRef.current;\n                setTypingChange(false);\n            }, resetMs);\n            const prevIndex = prevIndexRef.current;\n            const index = getMatchingIndex(listContent, [\n                ...listContent.slice((prevIndex || 0) + 1),\n                ...listContent.slice(0, (prevIndex || 0) + 1)\n            ], stringRef.current);\n            if (index !== -1) {\n                onMatch(index);\n                matchIndexRef.current = index;\n            } else if (event.key !== \" \") {\n                stringRef.current = \"\";\n                setTypingChange(false);\n            }\n        }\n        return {\n            reference: {\n                onKeyDown\n            },\n            floating: {\n                onKeyDown,\n                onKeyUp (event) {\n                    if (event.key === \" \") {\n                        setTypingChange(false);\n                    }\n                }\n            }\n        };\n    }, [\n        enabled,\n        open,\n        dataRef,\n        listRef,\n        resetMs,\n        ignoreKeysRef,\n        findMatchRef,\n        onMatch,\n        onTypingChange\n    ]);\n}\nfunction getArgsWithCustomFloatingHeight(state, height) {\n    return {\n        ...state,\n        rects: {\n            ...state.rects,\n            floating: {\n                ...state.rects.floating,\n                height\n            }\n        }\n    };\n}\n/**\n * Positions the floating element such that an inner element inside\n * of it is anchored to the reference element.\n * @see https://floating-ui.com/docs/inner\n */ const inner = (props)=>({\n        name: \"inner\",\n        options: props,\n        async fn (state) {\n            const { listRef, overflowRef, onFallbackChange, offset: innerOffset = 0, index = 0, minItemsVisible = 4, referenceOverflowThreshold = 0, scrollRef, ...detectOverflowOptions } = props;\n            const { rects, elements: { floating } } = state;\n            const item = listRef.current[index];\n            if (true) {\n                if (!state.placement.startsWith(\"bottom\")) {\n                    console.warn([\n                        'Floating UI: `placement` side must be \"bottom\" when using the',\n                        \"`inner` middleware.\"\n                    ].join(\" \"));\n                }\n            }\n            if (!item) {\n                return {};\n            }\n            const nextArgs = {\n                ...state,\n                ...await (0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_3__.offset)(-item.offsetTop - floating.clientTop - rects.reference.height / 2 - item.offsetHeight / 2 - innerOffset).fn(state)\n            };\n            const el = (scrollRef == null ? void 0 : scrollRef.current) || floating;\n            const overflow = await (0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_3__.detectOverflow)(getArgsWithCustomFloatingHeight(nextArgs, el.scrollHeight), detectOverflowOptions);\n            const refOverflow = await (0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_3__.detectOverflow)(nextArgs, {\n                ...detectOverflowOptions,\n                elementContext: \"reference\"\n            });\n            const diffY = Math.max(0, overflow.top);\n            const nextY = nextArgs.y + diffY;\n            const maxHeight = Math.max(0, el.scrollHeight - diffY - Math.max(0, overflow.bottom));\n            el.style.maxHeight = maxHeight + \"px\";\n            el.scrollTop = diffY;\n            // There is not enough space, fallback to standard anchored positioning\n            if (onFallbackChange) {\n                if (el.offsetHeight < item.offsetHeight * Math.min(minItemsVisible, listRef.current.length - 1) - 1 || refOverflow.top >= -referenceOverflowThreshold || refOverflow.bottom >= -referenceOverflowThreshold) {\n                    (0,react_dom__WEBPACK_IMPORTED_MODULE_5__.flushSync)(()=>onFallbackChange(true));\n                } else {\n                    (0,react_dom__WEBPACK_IMPORTED_MODULE_5__.flushSync)(()=>onFallbackChange(false));\n                }\n            }\n            if (overflowRef) {\n                overflowRef.current = await (0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_3__.detectOverflow)(getArgsWithCustomFloatingHeight({\n                    ...nextArgs,\n                    y: nextY\n                }, el.offsetHeight), detectOverflowOptions);\n            }\n            return {\n                y: nextY\n            };\n        }\n    });\n/**\n * Changes the `inner` middleware's `offset` upon a `wheel` event to\n * expand the floating element's height, revealing more list items.\n * @see https://floating-ui.com/docs/inner\n */ function useInnerOffset(context, props) {\n    const { open, elements } = context;\n    const { enabled = true, overflowRef, scrollRef, onChange: unstable_onChange } = props;\n    const onChange = useEffectEvent(unstable_onChange);\n    const controlledScrollingRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(false);\n    const prevScrollTopRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n    const initialOverflowRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        if (!enabled) {\n            return;\n        }\n        function onWheel(e) {\n            if (e.ctrlKey || !el || overflowRef.current == null) {\n                return;\n            }\n            const dY = e.deltaY;\n            const isAtTop = overflowRef.current.top >= -0.5;\n            const isAtBottom = overflowRef.current.bottom >= -0.5;\n            const remainingScroll = el.scrollHeight - el.clientHeight;\n            const sign = dY < 0 ? -1 : 1;\n            const method = dY < 0 ? \"max\" : \"min\";\n            if (el.scrollHeight <= el.clientHeight) {\n                return;\n            }\n            if (!isAtTop && dY > 0 || !isAtBottom && dY < 0) {\n                e.preventDefault();\n                (0,react_dom__WEBPACK_IMPORTED_MODULE_5__.flushSync)(()=>{\n                    onChange((d)=>d + Math[method](dY, remainingScroll * sign));\n                });\n            } else if (/firefox/i.test((0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.getUserAgent)())) {\n                // Needed to propagate scrolling during momentum scrolling phase once\n                // it gets limited by the boundary. UX improvement, not critical.\n                el.scrollTop += dY;\n            }\n        }\n        const el = (scrollRef == null ? void 0 : scrollRef.current) || elements.floating;\n        if (open && el) {\n            el.addEventListener(\"wheel\", onWheel);\n            // Wait for the position to be ready.\n            requestAnimationFrame(()=>{\n                prevScrollTopRef.current = el.scrollTop;\n                if (overflowRef.current != null) {\n                    initialOverflowRef.current = {\n                        ...overflowRef.current\n                    };\n                }\n            });\n            return ()=>{\n                prevScrollTopRef.current = null;\n                initialOverflowRef.current = null;\n                el.removeEventListener(\"wheel\", onWheel);\n            };\n        }\n    }, [\n        enabled,\n        open,\n        elements.floating,\n        overflowRef,\n        scrollRef,\n        onChange\n    ]);\n    return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>{\n        if (!enabled) {\n            return {};\n        }\n        return {\n            floating: {\n                onKeyDown () {\n                    controlledScrollingRef.current = true;\n                },\n                onWheel () {\n                    controlledScrollingRef.current = false;\n                },\n                onPointerMove () {\n                    controlledScrollingRef.current = false;\n                },\n                onScroll () {\n                    const el = (scrollRef == null ? void 0 : scrollRef.current) || elements.floating;\n                    if (!overflowRef.current || !el || !controlledScrollingRef.current) {\n                        return;\n                    }\n                    if (prevScrollTopRef.current !== null) {\n                        const scrollDiff = el.scrollTop - prevScrollTopRef.current;\n                        if (overflowRef.current.bottom < -0.5 && scrollDiff < -1 || overflowRef.current.top < -0.5 && scrollDiff > 1) {\n                            (0,react_dom__WEBPACK_IMPORTED_MODULE_5__.flushSync)(()=>onChange((d)=>d + scrollDiff));\n                        }\n                    }\n                    // [Firefox] Wait for the height change to have been applied.\n                    requestAnimationFrame(()=>{\n                        prevScrollTopRef.current = el.scrollTop;\n                    });\n                }\n            }\n        };\n    }, [\n        enabled,\n        overflowRef,\n        elements.floating,\n        scrollRef,\n        onChange\n    ]);\n}\nfunction isPointInPolygon(point, polygon) {\n    const [x, y] = point;\n    let isInside = false;\n    const length = polygon.length;\n    for(let i = 0, j = length - 1; i < length; j = i++){\n        const [xi, yi] = polygon[i] || [\n            0,\n            0\n        ];\n        const [xj, yj] = polygon[j] || [\n            0,\n            0\n        ];\n        const intersect = yi >= y !== yj >= y && x <= (xj - xi) * (y - yi) / (yj - yi) + xi;\n        if (intersect) {\n            isInside = !isInside;\n        }\n    }\n    return isInside;\n}\nfunction isInside(point, rect) {\n    return point[0] >= rect.x && point[0] <= rect.x + rect.width && point[1] >= rect.y && point[1] <= rect.y + rect.height;\n}\n/**\n * Generates a safe polygon area that the user can traverse without closing the\n * floating element once leaving the reference element.\n * @see https://floating-ui.com/docs/useHover#safepolygon\n */ function safePolygon(options) {\n    if (options === void 0) {\n        options = {};\n    }\n    const { buffer = 0.5, blockPointerEvents = false, requireIntent = true } = options;\n    let timeoutId;\n    let hasLanded = false;\n    let lastX = null;\n    let lastY = null;\n    let lastCursorTime = performance.now();\n    function getCursorSpeed(x, y) {\n        const currentTime = performance.now();\n        const elapsedTime = currentTime - lastCursorTime;\n        if (lastX === null || lastY === null || elapsedTime === 0) {\n            lastX = x;\n            lastY = y;\n            lastCursorTime = currentTime;\n            return null;\n        }\n        const deltaX = x - lastX;\n        const deltaY = y - lastY;\n        const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);\n        const speed = distance / elapsedTime; // px / ms\n        lastX = x;\n        lastY = y;\n        lastCursorTime = currentTime;\n        return speed;\n    }\n    const fn = (_ref)=>{\n        let { x, y, placement, elements, onClose, nodeId, tree } = _ref;\n        return function onMouseMove(event) {\n            function close() {\n                clearTimeout(timeoutId);\n                onClose();\n            }\n            clearTimeout(timeoutId);\n            if (!elements.domReference || !elements.floating || placement == null || x == null || y == null) {\n                return;\n            }\n            const { clientX, clientY } = event;\n            const clientPoint = [\n                clientX,\n                clientY\n            ];\n            const target = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.getTarget)(event);\n            const isLeave = event.type === \"mouseleave\";\n            const isOverFloatingEl = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.contains)(elements.floating, target);\n            const isOverReferenceEl = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.contains)(elements.domReference, target);\n            const refRect = elements.domReference.getBoundingClientRect();\n            const rect = elements.floating.getBoundingClientRect();\n            const side = placement.split(\"-\")[0];\n            const cursorLeaveFromRight = x > rect.right - rect.width / 2;\n            const cursorLeaveFromBottom = y > rect.bottom - rect.height / 2;\n            const isOverReferenceRect = isInside(clientPoint, refRect);\n            const isFloatingWider = rect.width > refRect.width;\n            const isFloatingTaller = rect.height > refRect.height;\n            const left = (isFloatingWider ? refRect : rect).left;\n            const right = (isFloatingWider ? refRect : rect).right;\n            const top = (isFloatingTaller ? refRect : rect).top;\n            const bottom = (isFloatingTaller ? refRect : rect).bottom;\n            if (isOverFloatingEl) {\n                hasLanded = true;\n                if (!isLeave) {\n                    return;\n                }\n            }\n            if (isOverReferenceEl) {\n                hasLanded = false;\n            }\n            if (isOverReferenceEl && !isLeave) {\n                hasLanded = true;\n                return;\n            }\n            // Prevent overlapping floating element from being stuck in an open-close\n            // loop: https://github.com/floating-ui/floating-ui/issues/1910\n            if (isLeave && (0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_4__.isElement)(event.relatedTarget) && (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.contains)(elements.floating, event.relatedTarget)) {\n                return;\n            }\n            // If any nested child is open, abort.\n            if (tree && getChildren(tree.nodesRef.current, nodeId).some((_ref2)=>{\n                let { context } = _ref2;\n                return context == null ? void 0 : context.open;\n            })) {\n                return;\n            }\n            // If the pointer is leaving from the opposite side, the \"buffer\" logic\n            // creates a point where the floating element remains open, but should be\n            // ignored.\n            // A constant of 1 handles floating point rounding errors.\n            if (side === \"top\" && y >= refRect.bottom - 1 || side === \"bottom\" && y <= refRect.top + 1 || side === \"left\" && x >= refRect.right - 1 || side === \"right\" && x <= refRect.left + 1) {\n                return close();\n            }\n            // Ignore when the cursor is within the rectangular trough between the\n            // two elements. Since the triangle is created from the cursor point,\n            // which can start beyond the ref element's edge, traversing back and\n            // forth from the ref to the floating element can cause it to close. This\n            // ensures it always remains open in that case.\n            let rectPoly = [];\n            switch(side){\n                case \"top\":\n                    rectPoly = [\n                        [\n                            left,\n                            refRect.top + 1\n                        ],\n                        [\n                            left,\n                            rect.bottom - 1\n                        ],\n                        [\n                            right,\n                            rect.bottom - 1\n                        ],\n                        [\n                            right,\n                            refRect.top + 1\n                        ]\n                    ];\n                    break;\n                case \"bottom\":\n                    rectPoly = [\n                        [\n                            left,\n                            rect.top + 1\n                        ],\n                        [\n                            left,\n                            refRect.bottom - 1\n                        ],\n                        [\n                            right,\n                            refRect.bottom - 1\n                        ],\n                        [\n                            right,\n                            rect.top + 1\n                        ]\n                    ];\n                    break;\n                case \"left\":\n                    rectPoly = [\n                        [\n                            rect.right - 1,\n                            bottom\n                        ],\n                        [\n                            rect.right - 1,\n                            top\n                        ],\n                        [\n                            refRect.left + 1,\n                            top\n                        ],\n                        [\n                            refRect.left + 1,\n                            bottom\n                        ]\n                    ];\n                    break;\n                case \"right\":\n                    rectPoly = [\n                        [\n                            refRect.right - 1,\n                            bottom\n                        ],\n                        [\n                            refRect.right - 1,\n                            top\n                        ],\n                        [\n                            rect.left + 1,\n                            top\n                        ],\n                        [\n                            rect.left + 1,\n                            bottom\n                        ]\n                    ];\n                    break;\n            }\n            function getPolygon(_ref3) {\n                let [x, y] = _ref3;\n                switch(side){\n                    case \"top\":\n                        {\n                            const cursorPointOne = [\n                                isFloatingWider ? x + buffer / 2 : cursorLeaveFromRight ? x + buffer * 4 : x - buffer * 4,\n                                y + buffer + 1\n                            ];\n                            const cursorPointTwo = [\n                                isFloatingWider ? x - buffer / 2 : cursorLeaveFromRight ? x + buffer * 4 : x - buffer * 4,\n                                y + buffer + 1\n                            ];\n                            const commonPoints = [\n                                [\n                                    rect.left,\n                                    cursorLeaveFromRight ? rect.bottom - buffer : isFloatingWider ? rect.bottom - buffer : rect.top\n                                ],\n                                [\n                                    rect.right,\n                                    cursorLeaveFromRight ? isFloatingWider ? rect.bottom - buffer : rect.top : rect.bottom - buffer\n                                ]\n                            ];\n                            return [\n                                cursorPointOne,\n                                cursorPointTwo,\n                                ...commonPoints\n                            ];\n                        }\n                    case \"bottom\":\n                        {\n                            const cursorPointOne = [\n                                isFloatingWider ? x + buffer / 2 : cursorLeaveFromRight ? x + buffer * 4 : x - buffer * 4,\n                                y - buffer\n                            ];\n                            const cursorPointTwo = [\n                                isFloatingWider ? x - buffer / 2 : cursorLeaveFromRight ? x + buffer * 4 : x - buffer * 4,\n                                y - buffer\n                            ];\n                            const commonPoints = [\n                                [\n                                    rect.left,\n                                    cursorLeaveFromRight ? rect.top + buffer : isFloatingWider ? rect.top + buffer : rect.bottom\n                                ],\n                                [\n                                    rect.right,\n                                    cursorLeaveFromRight ? isFloatingWider ? rect.top + buffer : rect.bottom : rect.top + buffer\n                                ]\n                            ];\n                            return [\n                                cursorPointOne,\n                                cursorPointTwo,\n                                ...commonPoints\n                            ];\n                        }\n                    case \"left\":\n                        {\n                            const cursorPointOne = [\n                                x + buffer + 1,\n                                isFloatingTaller ? y + buffer / 2 : cursorLeaveFromBottom ? y + buffer * 4 : y - buffer * 4\n                            ];\n                            const cursorPointTwo = [\n                                x + buffer + 1,\n                                isFloatingTaller ? y - buffer / 2 : cursorLeaveFromBottom ? y + buffer * 4 : y - buffer * 4\n                            ];\n                            const commonPoints = [\n                                [\n                                    cursorLeaveFromBottom ? rect.right - buffer : isFloatingTaller ? rect.right - buffer : rect.left,\n                                    rect.top\n                                ],\n                                [\n                                    cursorLeaveFromBottom ? isFloatingTaller ? rect.right - buffer : rect.left : rect.right - buffer,\n                                    rect.bottom\n                                ]\n                            ];\n                            return [\n                                ...commonPoints,\n                                cursorPointOne,\n                                cursorPointTwo\n                            ];\n                        }\n                    case \"right\":\n                        {\n                            const cursorPointOne = [\n                                x - buffer,\n                                isFloatingTaller ? y + buffer / 2 : cursorLeaveFromBottom ? y + buffer * 4 : y - buffer * 4\n                            ];\n                            const cursorPointTwo = [\n                                x - buffer,\n                                isFloatingTaller ? y - buffer / 2 : cursorLeaveFromBottom ? y + buffer * 4 : y - buffer * 4\n                            ];\n                            const commonPoints = [\n                                [\n                                    cursorLeaveFromBottom ? rect.left + buffer : isFloatingTaller ? rect.left + buffer : rect.right,\n                                    rect.top\n                                ],\n                                [\n                                    cursorLeaveFromBottom ? isFloatingTaller ? rect.left + buffer : rect.right : rect.left + buffer,\n                                    rect.bottom\n                                ]\n                            ];\n                            return [\n                                cursorPointOne,\n                                cursorPointTwo,\n                                ...commonPoints\n                            ];\n                        }\n                }\n            }\n            if (isPointInPolygon([\n                clientX,\n                clientY\n            ], rectPoly)) {\n                return;\n            }\n            if (hasLanded && !isOverReferenceRect) {\n                return close();\n            }\n            if (!isLeave && requireIntent) {\n                const cursorSpeed = getCursorSpeed(event.clientX, event.clientY);\n                const cursorSpeedThreshold = 0.1;\n                if (cursorSpeed !== null && cursorSpeed < cursorSpeedThreshold) {\n                    return close();\n                }\n            }\n            if (!isPointInPolygon([\n                clientX,\n                clientY\n            ], getPolygon([\n                x,\n                y\n            ]))) {\n                close();\n            } else if (!hasLanded && requireIntent) {\n                timeoutId = window.setTimeout(close, 40);\n            }\n        };\n    };\n    fn.__options = {\n        blockPointerEvents\n    };\n    return fn;\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGZsb2F0aW5nLXVpL3JlYWN0L2Rpc3QvZmxvYXRpbmctdWkucmVhY3QubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBK0I7QUFDNEI7QUFDK087QUFDL1A7QUFDbUY7QUFDa0U7QUFDOUM7QUFDOUc7QUFDZ0I7QUFFcEQ7OztDQUdDLEdBQ0QsU0FBU2dELGFBQWFDLElBQUk7SUFDeEIsdUVBQXVFO0lBQ3ZFLE9BQU9qRCwwQ0FBYSxDQUFDO1FBQ25CLElBQUlpRCxLQUFLRSxLQUFLLENBQUNDLENBQUFBLE1BQU9BLE9BQU8sT0FBTztZQUNsQyxPQUFPO1FBQ1Q7UUFDQSxPQUFPQyxDQUFBQTtZQUNMSixLQUFLSyxPQUFPLENBQUNGLENBQUFBO2dCQUNYLElBQUksT0FBT0EsUUFBUSxZQUFZO29CQUM3QkEsSUFBSUM7Z0JBQ04sT0FBTyxJQUFJRCxPQUFPLE1BQU07b0JBQ3RCQSxJQUFJRyxPQUFPLEdBQUdGO2dCQUNoQjtZQUNGO1FBQ0Y7SUFDRixHQUFHSjtBQUNMO0FBRUEsNkZBQTZGO0FBQzdGLE1BQU1PLHFCQUFxQnhELHlMQUFLLENBQUMsV0FBVyxHQUFFLHFCQUFxQnlELFFBQVEsR0FBRztBQUM5RSxNQUFNQyx5QkFBeUJGLHNCQUF1QkcsQ0FBQUEsQ0FBQUEsS0FBTUEsSUFBRztBQUMvRCxTQUFTQyxlQUFlQyxRQUFRO0lBQzlCLE1BQU1ULE1BQU1wRCx5Q0FBWSxDQUFDO1FBQ3ZCLElBQUk4RCxJQUFxQyxFQUFFO1lBQ3pDLE1BQU0sSUFBSUMsTUFBTTtRQUNsQjtJQUNGO0lBQ0FMLHVCQUF1QjtRQUNyQk4sSUFBSUcsT0FBTyxHQUFHTTtJQUNoQjtJQUNBLE9BQU83RCw4Q0FBaUIsQ0FBQztRQUN2QixJQUFLLElBQUlpRSxPQUFPQyxVQUFVQyxNQUFNLEVBQUVDLE9BQU8sSUFBSUMsTUFBTUosT0FBT0ssT0FBTyxH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LElBQUlELGdCQUFnQixRQUFRQSxjQUFjQyxzQkFBc0I7b0JBQzlELE9BQU9qbEI7Z0JBQ1Q7WUFDRjtZQUNBLElBQUksQ0FBQ3VpQixpQkFBaUI7Z0JBQUMza0I7Z0JBQVNDO2FBQVEsRUFBRSttQixXQUFXO2dCQUFDNXNCO2dCQUFHRTthQUFFLElBQUk7Z0JBQzdEOEg7WUFDRixPQUFPLElBQUksQ0FBQ29qQixhQUFhRCxlQUFlO2dCQUN0Q3pkLFlBQVl2RixPQUFPakQsVUFBVSxDQUFDOEMsT0FBTztZQUN2QztRQUNGO0lBQ0Y7SUFDQW5XLEdBQUd1VSxTQUFTLEdBQUc7UUFDYkM7SUFDRjtJQUNBLE9BQU94VTtBQUNUO0FBRW1oQiIsInNvdXJjZXMiOlsid2VicGFjazovL29wZW4tcHJvLW5leHQvLi9ub2RlX21vZHVsZXMvQGZsb2F0aW5nLXVpL3JlYWN0L2Rpc3QvZmxvYXRpbmctdWkucmVhY3QubWpzPzY2Y2QiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgdXNlTGF5b3V0RWZmZWN0LCB1c2VFZmZlY3QsIHVzZVJlZiB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IHN0b3BFdmVudCwgZ2V0RG9jdW1lbnQsIGlzTW91c2VMaWtlUG9pbnRlclR5cGUsIGNvbnRhaW5zLCBhY3RpdmVFbGVtZW50LCBpc1NhZmFyaSwgaXNUeXBlYWJsZUNvbWJvYm94LCBpc1ZpcnR1YWxDbGljaywgaXNWaXJ0dWFsUG9pbnRlckV2ZW50LCBnZXRUYXJnZXQsIGdldFBsYXRmb3JtLCBpc1R5cGVhYmxlRWxlbWVudCwgaXNSZWFjdEV2ZW50LCBpc1Jvb3RFbGVtZW50LCBpc0V2ZW50VGFyZ2V0V2l0aGluLCBpc01hYywgZ2V0VXNlckFnZW50IH0gZnJvbSAnQGZsb2F0aW5nLXVpL3JlYWN0L3V0aWxzJztcbmltcG9ydCB7IGZsb29yIH0gZnJvbSAnQGZsb2F0aW5nLXVpL3V0aWxzJztcbmltcG9ydCB7IHBsYXRmb3JtLCBnZXRPdmVyZmxvd0FuY2VzdG9ycywgdXNlRmxvYXRpbmcgYXMgdXNlRmxvYXRpbmckMSwgb2Zmc2V0LCBkZXRlY3RPdmVyZmxvdyB9IGZyb20gJ0BmbG9hdGluZy11aS9yZWFjdC1kb20nO1xuZXhwb3J0IHsgYXJyb3csIGF1dG9QbGFjZW1lbnQsIGF1dG9VcGRhdGUsIGNvbXB1dGVQb3NpdGlvbiwgZGV0ZWN0T3ZlcmZsb3csIGZsaXAsIGdldE92ZXJmbG93QW5jZXN0b3JzLCBoaWRlLCBpbmxpbmUsIGxpbWl0U2hpZnQsIG9mZnNldCwgcGxhdGZvcm0sIHNoaWZ0LCBzaXplIH0gZnJvbSAnQGZsb2F0aW5nLXVpL3JlYWN0LWRvbSc7XG5pbXBvcnQgeyBpc0VsZW1lbnQsIGlzSFRNTEVsZW1lbnQsIGdldE5vZGVOYW1lLCBnZXRXaW5kb3csIGlzTGFzdFRyYXZlcnNhYmxlTm9kZSwgZ2V0UGFyZW50Tm9kZSwgZ2V0Q29tcHV0ZWRTdHlsZSB9IGZyb20gJ0BmbG9hdGluZy11aS91dGlscy9kb20nO1xuaW1wb3J0IHsgdGFiYmFibGUgfSBmcm9tICd0YWJiYWJsZSc7XG5pbXBvcnQgeyBjcmVhdGVQb3J0YWwsIGZsdXNoU3luYyB9IGZyb20gJ3JlYWN0LWRvbSc7XG5cbi8qKlxuICogTWVyZ2VzIGFuIGFycmF5IG9mIHJlZnMgaW50byBhIHNpbmdsZSBtZW1vaXplZCBjYWxsYmFjayByZWYgb3IgYG51bGxgLlxuICogQHNlZSBodHRwczovL2Zsb2F0aW5nLXVpLmNvbS9kb2NzL3JlYWN0LXV0aWxzI3VzZW1lcmdlcmVmc1xuICovXG5mdW5jdGlvbiB1c2VNZXJnZVJlZnMocmVmcykge1xuICAvLyBiaW9tZS1pZ25vcmUgbGludC9jb3JyZWN0bmVzcy91c2VFeGhhdXN0aXZlRGVwZW5kZW5jaWVzOiBpbnRlbnRpb25hbFxuICByZXR1cm4gUmVhY3QudXNlTWVtbygoKSA9PiB7XG4gICAgaWYgKHJlZnMuZXZlcnkocmVmID0+IHJlZiA9PSBudWxsKSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZSA9PiB7XG4gICAgICByZWZzLmZvckVhY2gocmVmID0+IHtcbiAgICAgICAgaWYgKHR5cGVvZiByZWYgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICByZWYodmFsdWUpO1xuICAgICAgICB9IGVsc2UgaWYgKHJlZiAhPSBudWxsKSB7XG4gICAgICAgICAgcmVmLmN1cnJlbnQgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfTtcbiAgfSwgcmVmcyk7XG59XG5cbi8vIGB0b1N0cmluZygpYCBwcmV2ZW50cyBidW5kbGVycyBmcm9tIHRyeWluZyB0byBgaW1wb3J0IHsgdXNlSW5zZXJ0aW9uRWZmZWN0IH0gZnJvbSAncmVhY3QnYFxuY29uc3QgdXNlSW5zZXJ0aW9uRWZmZWN0ID0gUmVhY3RbLyojX19QVVJFX18qLyd1c2VJbnNlcnRpb25FZmZlY3QnLnRvU3RyaW5nKCldO1xuY29uc3QgdXNlU2FmZUluc2VydGlvbkVmZmVjdCA9IHVzZUluc2VydGlvbkVmZmVjdCB8fCAoZm4gPT4gZm4oKSk7XG5mdW5jdGlvbiB1c2VFZmZlY3RFdmVudChjYWxsYmFjaykge1xuICBjb25zdCByZWYgPSBSZWFjdC51c2VSZWYoKCkgPT4ge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGNhbGwgYW4gZXZlbnQgaGFuZGxlciB3aGlsZSByZW5kZXJpbmcuJyk7XG4gICAgfVxuICB9KTtcbiAgdXNlU2FmZUluc2VydGlvbkVmZmVjdCgoKSA9PiB7XG4gICAgcmVmLmN1cnJlbnQgPSBjYWxsYmFjaztcbiAgfSk7XG4gIHJldHVybiBSZWFjdC51c2VDYWxsYmFjayhmdW5jdGlvbiAoKSB7XG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cbiAgICByZXR1cm4gcmVmLmN1cnJlbnQgPT0gbnVsbCA/IHZvaWQgMCA6IHJlZi5jdXJyZW50KC4uLmFyZ3MpO1xuICB9LCBbXSk7XG59XG5cbmNvbnN0IEFSUk9XX1VQID0gJ0Fycm93VXAnO1xuY29uc3QgQVJST1dfRE9XTiA9ICdBcnJvd0Rvd24nO1xuY29uc3QgQVJST1dfTEVGVCA9ICdBcnJvd0xlZnQnO1xuY29uc3QgQVJST1dfUklHSFQgPSAnQXJyb3dSaWdodCc7XG5mdW5jdGlvbiBpc0RpZmZlcmVudFJvdyhpbmRleCwgY29scywgcHJldlJvdykge1xuICByZXR1cm4gTWF0aC5mbG9vcihpbmRleCAvIGNvbHMpICE9PSBwcmV2Um93O1xufVxuZnVuY3Rpb24gaXNJbmRleE91dE9mQm91bmRzKGxpc3RSZWYsIGluZGV4KSB7XG4gIHJldHVybiBpbmRleCA8IDAgfHwgaW5kZXggPj0gbGlzdFJlZi5jdXJyZW50Lmxlbmd0aDtcbn1cbmZ1bmN0aW9uIGdldE1pbkluZGV4KGxpc3RSZWYsIGRpc2FibGVkSW5kaWNlcykge1xuICByZXR1cm4gZmluZE5vbkRpc2FibGVkSW5kZXgobGlzdFJlZiwge1xuICAgIGRpc2FibGVkSW5kaWNlc1xuICB9KTtcbn1cbmZ1bmN0aW9uIGdldE1heEluZGV4KGxpc3RSZWYsIGRpc2FibGVkSW5kaWNlcykge1xuICByZXR1cm4gZmluZE5vbkRpc2FibGVkSW5kZXgobGlzdFJlZiwge1xuICAgIGRlY3JlbWVudDogdHJ1ZSxcbiAgICBzdGFydGluZ0luZGV4OiBsaXN0UmVmLmN1cnJlbnQubGVuZ3RoLFxuICAgIGRpc2FibGVkSW5kaWNlc1xuICB9KTtcbn1cbmZ1bmN0aW9uIGZpbmROb25EaXNhYmxlZEluZGV4KGxpc3RSZWYsIF90ZW1wKSB7XG4gIGxldCB7XG4gICAgc3RhcnRpbmdJbmRleCA9IC0xLFxuICAgIGRlY3JlbWVudCA9IGZhbHNlLFxuICAgIGRpc2FibGVkSW5kaWNlcyxcbiAgICBhbW91bnQgPSAxXG4gIH0gPSBfdGVtcCA9PT0gdm9pZCAwID8ge30gOiBfdGVtcDtcbiAgY29uc3QgbGlzdCA9IGxpc3RSZWYuY3VycmVudDtcbiAgY29uc3QgaXNEaXNhYmxlZEluZGV4ID0gZGlzYWJsZWRJbmRpY2VzID8gaW5kZXggPT4gZGlzYWJsZWRJbmRpY2VzLmluY2x1ZGVzKGluZGV4KSA6IGluZGV4ID0+IHtcbiAgICBjb25zdCBlbGVtZW50ID0gbGlzdFtpbmRleF07XG4gICAgcmV0dXJuIGVsZW1lbnQgPT0gbnVsbCB8fCBlbGVtZW50Lmhhc0F0dHJpYnV0ZSgnZGlzYWJsZWQnKSB8fCBlbGVtZW50LmdldEF0dHJpYnV0ZSgnYXJpYS1kaXNhYmxlZCcpID09PSAndHJ1ZSc7XG4gIH07XG4gIGxldCBpbmRleCA9IHN0YXJ0aW5nSW5kZXg7XG4gIGRvIHtcbiAgICBpbmRleCArPSBkZWNyZW1lbnQgPyAtYW1vdW50IDogYW1vdW50O1xuICB9IHdoaWxlIChpbmRleCA+PSAwICYmIGluZGV4IDw9IGxpc3QubGVuZ3RoIC0gMSAmJiBpc0Rpc2FibGVkSW5kZXgoaW5kZXgpKTtcbiAgcmV0dXJuIGluZGV4O1xufVxuZnVuY3Rpb24gZ2V0R3JpZE5hdmlnYXRlZEluZGV4KGVsZW1lbnRzUmVmLCBfcmVmKSB7XG4gIGxldCB7XG4gICAgZXZlbnQsXG4gICAgb3JpZW50YXRpb24sXG4gICAgbG9vcCxcbiAgICBjb2xzLFxuICAgIGRpc2FibGVkSW5kaWNlcyxcbiAgICBtaW5JbmRleCxcbiAgICBtYXhJbmRleCxcbiAgICBwcmV2SW5kZXgsXG4gICAgc3RvcEV2ZW50OiBzdG9wID0gZmFsc2VcbiAgfSA9IF9yZWY7XG4gIGxldCBuZXh0SW5kZXggPSBwcmV2SW5kZXg7XG4gIGlmIChldmVudC5rZXkgPT09IEFSUk9XX1VQKSB7XG4gICAgc3RvcCAmJiBzdG9wRXZlbnQoZXZlbnQpO1xuICAgIGlmIChwcmV2SW5kZXggPT09IC0xKSB7XG4gICAgICBuZXh0SW5kZXggPSBtYXhJbmRleDtcbiAgICB9IGVsc2Uge1xuICAgICAgbmV4dEluZGV4ID0gZmluZE5vbkRpc2FibGVkSW5kZXgoZWxlbWVudHNSZWYsIHtcbiAgICAgICAgc3RhcnRpbmdJbmRleDogbmV4dEluZGV4LFxuICAgICAgICBhbW91bnQ6IGNvbHMsXG4gICAgICAgIGRlY3JlbWVudDogdHJ1ZSxcbiAgICAgICAgZGlzYWJsZWRJbmRpY2VzXG4gICAgICB9KTtcbiAgICAgIGlmIChsb29wICYmIChwcmV2SW5kZXggLSBjb2xzIDwgbWluSW5kZXggfHwgbmV4dEluZGV4IDwgMCkpIHtcbiAgICAgICAgY29uc3QgY29sID0gcHJldkluZGV4ICUgY29scztcbiAgICAgICAgY29uc3QgbWF4Q29sID0gbWF4SW5kZXggJSBjb2xzO1xuICAgICAgICBjb25zdCBvZmZzZXQgPSBtYXhJbmRleCAtIChtYXhDb2wgLSBjb2wpO1xuICAgICAgICBpZiAobWF4Q29sID09PSBjb2wpIHtcbiAgICAgICAgICBuZXh0SW5kZXggPSBtYXhJbmRleDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBuZXh0SW5kZXggPSBtYXhDb2wgPiBjb2wgPyBvZmZzZXQgOiBvZmZzZXQgLSBjb2xzO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChpc0luZGV4T3V0T2ZCb3VuZHMoZWxlbWVudHNSZWYsIG5leHRJbmRleCkpIHtcbiAgICAgIG5leHRJbmRleCA9IHByZXZJbmRleDtcbiAgICB9XG4gIH1cbiAgaWYgKGV2ZW50LmtleSA9PT0gQVJST1dfRE9XTikge1xuICAgIHN0b3AgJiYgc3RvcEV2ZW50KGV2ZW50KTtcbiAgICBpZiAocHJldkluZGV4ID09PSAtMSkge1xuICAgICAgbmV4dEluZGV4ID0gbWluSW5kZXg7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5leHRJbmRleCA9IGZpbmROb25EaXNhYmxlZEluZGV4KGVsZW1lbnRzUmVmLCB7XG4gICAgICAgIHN0YXJ0aW5nSW5kZXg6IHByZXZJbmRleCxcbiAgICAgICAgYW1vdW50OiBjb2xzLFxuICAgICAgICBkaXNhYmxlZEluZGljZXNcbiAgICAgIH0pO1xuICAgICAgaWYgKGxvb3AgJiYgcHJldkluZGV4ICsgY29scyA+IG1heEluZGV4KSB7XG4gICAgICAgIG5leHRJbmRleCA9IGZpbmROb25EaXNhYmxlZEluZGV4KGVsZW1lbnRzUmVmLCB7XG4gICAgICAgICAgc3RhcnRpbmdJbmRleDogcHJldkluZGV4ICUgY29scyAtIGNvbHMsXG4gICAgICAgICAgYW1vdW50OiBjb2xzLFxuICAgICAgICAgIGRpc2FibGVkSW5kaWNlc1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGlzSW5kZXhPdXRPZkJvdW5kcyhlbGVtZW50c1JlZiwgbmV4dEluZGV4KSkge1xuICAgICAgbmV4dEluZGV4ID0gcHJldkluZGV4O1xuICAgIH1cbiAgfVxuXG4gIC8vIFJlbWFpbnMgb24gdGhlIHNhbWUgcm93L2NvbHVtbi5cbiAgaWYgKG9yaWVudGF0aW9uID09PSAnYm90aCcpIHtcbiAgICBjb25zdCBwcmV2Um93ID0gZmxvb3IocHJldkluZGV4IC8gY29scyk7XG4gICAgaWYgKGV2ZW50LmtleSA9PT0gQVJST1dfUklHSFQpIHtcbiAgICAgIHN0b3AgJiYgc3RvcEV2ZW50KGV2ZW50KTtcbiAgICAgIGlmIChwcmV2SW5kZXggJSBjb2xzICE9PSBjb2xzIC0gMSkge1xuICAgICAgICBuZXh0SW5kZXggPSBmaW5kTm9uRGlzYWJsZWRJbmRleChlbGVtZW50c1JlZiwge1xuICAgICAgICAgIHN0YXJ0aW5nSW5kZXg6IHByZXZJbmRleCxcbiAgICAgICAgICBkaXNhYmxlZEluZGljZXNcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChsb29wICYmIGlzRGlmZmVyZW50Um93KG5leHRJbmRleCwgY29scywgcHJldlJvdykpIHtcbiAgICAgICAgICBuZXh0SW5kZXggPSBmaW5kTm9uRGlzYWJsZWRJbmRleChlbGVtZW50c1JlZiwge1xuICAgICAgICAgICAgc3RhcnRpbmdJbmRleDogcHJldkluZGV4IC0gcHJldkluZGV4ICUgY29scyAtIDEsXG4gICAgICAgICAgICBkaXNhYmxlZEluZGljZXNcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChsb29wKSB7XG4gICAgICAgIG5leHRJbmRleCA9IGZpbmROb25EaXNhYmxlZEluZGV4KGVsZW1lbnRzUmVmLCB7XG4gICAgICAgICAgc3RhcnRpbmdJbmRleDogcHJldkluZGV4IC0gcHJldkluZGV4ICUgY29scyAtIDEsXG4gICAgICAgICAgZGlzYWJsZWRJbmRpY2VzXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYgKGlzRGlmZmVyZW50Um93KG5leHRJbmRleCwgY29scywgcHJldlJvdykpIHtcbiAgICAgICAgbmV4dEluZGV4ID0gcHJldkluZGV4O1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoZXZlbnQua2V5ID09PSBBUlJPV19MRUZUKSB7XG4gICAgICBzdG9wICYmIHN0b3BFdmVudChldmVudCk7XG4gICAgICBpZiAocHJldkluZGV4ICUgY29scyAhPT0gMCkge1xuICAgICAgICBuZXh0SW5kZXggPSBmaW5kTm9uRGlzYWJsZWRJbmRleChlbGVtZW50c1JlZiwge1xuICAgICAgICAgIHN0YXJ0aW5nSW5kZXg6IHByZXZJbmRleCxcbiAgICAgICAgICBkaXNhYmxlZEluZGljZXMsXG4gICAgICAgICAgZGVjcmVtZW50OiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAobG9vcCAmJiBpc0RpZmZlcmVudFJvdyhuZXh0SW5kZXgsIGNvbHMsIHByZXZSb3cpKSB7XG4gICAgICAgICAgbmV4dEluZGV4ID0gZmluZE5vbkRpc2FibGVkSW5kZXgoZWxlbWVudHNSZWYsIHtcbiAgICAgICAgICAgIHN0YXJ0aW5nSW5kZXg6IHByZXZJbmRleCArIChjb2xzIC0gcHJldkluZGV4ICUgY29scyksXG4gICAgICAgICAgICBkZWNyZW1lbnQ6IHRydWUsXG4gICAgICAgICAgICBkaXNhYmxlZEluZGljZXNcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChsb29wKSB7XG4gICAgICAgIG5leHRJbmRleCA9IGZpbmROb25EaXNhYmxlZEluZGV4KGVsZW1lbnRzUmVmLCB7XG4gICAgICAgICAgc3RhcnRpbmdJbmRleDogcHJldkluZGV4ICsgKGNvbHMgLSBwcmV2SW5kZXggJSBjb2xzKSxcbiAgICAgICAgICBkZWNyZW1lbnQ6IHRydWUsXG4gICAgICAgICAgZGlzYWJsZWRJbmRpY2VzXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYgKGlzRGlmZmVyZW50Um93KG5leHRJbmRleCwgY29scywgcHJldlJvdykpIHtcbiAgICAgICAgbmV4dEluZGV4ID0gcHJldkluZGV4O1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBsYXN0Um93ID0gZmxvb3IobWF4SW5kZXggLyBjb2xzKSA9PT0gcHJldlJvdztcbiAgICBpZiAoaXNJbmRleE91dE9mQm91bmRzKGVsZW1lbnRzUmVmLCBuZXh0SW5kZXgpKSB7XG4gICAgICBpZiAobG9vcCAmJiBsYXN0Um93KSB7XG4gICAgICAgIG5leHRJbmRleCA9IGV2ZW50LmtleSA9PT0gQVJST1dfTEVGVCA/IG1heEluZGV4IDogZmluZE5vbkRpc2FibGVkSW5kZXgoZWxlbWVudHNSZWYsIHtcbiAgICAgICAgICBzdGFydGluZ0luZGV4OiBwcmV2SW5kZXggLSBwcmV2SW5kZXggJSBjb2xzIC0gMSxcbiAgICAgICAgICBkaXNhYmxlZEluZGljZXNcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuZXh0SW5kZXggPSBwcmV2SW5kZXg7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBuZXh0SW5kZXg7XG59XG5cbi8qKiBGb3IgZWFjaCBjZWxsIGluZGV4LCBnZXRzIHRoZSBpdGVtIGluZGV4IHRoYXQgb2NjdXBpZXMgdGhhdCBjZWxsICovXG5mdW5jdGlvbiBidWlsZENlbGxNYXAoc2l6ZXMsIGNvbHMsIGRlbnNlKSB7XG4gIGNvbnN0IGNlbGxNYXAgPSBbXTtcbiAgbGV0IHN0YXJ0SW5kZXggPSAwO1xuICBzaXplcy5mb3JFYWNoKChfcmVmMiwgaW5kZXgpID0+IHtcbiAgICBsZXQge1xuICAgICAgd2lkdGgsXG4gICAgICBoZWlnaHRcbiAgICB9ID0gX3JlZjI7XG4gICAgaWYgKHdpZHRoID4gY29scykge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJbRmxvYXRpbmcgVUldOiBJbnZhbGlkIGdyaWQgLSBpdGVtIHdpZHRoIGF0IGluZGV4IFwiICsgaW5kZXggKyBcIiBpcyBncmVhdGVyIHRoYW4gZ3JpZCBjb2x1bW5zXCIpO1xuICAgICAgfVxuICAgIH1cbiAgICBsZXQgaXRlbVBsYWNlZCA9IGZhbHNlO1xuICAgIGlmIChkZW5zZSkge1xuICAgICAgc3RhcnRJbmRleCA9IDA7XG4gICAgfVxuICAgIHdoaWxlICghaXRlbVBsYWNlZCkge1xuICAgICAgY29uc3QgdGFyZ2V0Q2VsbHMgPSBbXTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgd2lkdGg7IGkrKykge1xuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGhlaWdodDsgaisrKSB7XG4gICAgICAgICAgdGFyZ2V0Q2VsbHMucHVzaChzdGFydEluZGV4ICsgaSArIGogKiBjb2xzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHN0YXJ0SW5kZXggJSBjb2xzICsgd2lkdGggPD0gY29scyAmJiB0YXJnZXRDZWxscy5ldmVyeShjZWxsID0+IGNlbGxNYXBbY2VsbF0gPT0gbnVsbCkpIHtcbiAgICAgICAgdGFyZ2V0Q2VsbHMuZm9yRWFjaChjZWxsID0+IHtcbiAgICAgICAgICBjZWxsTWFwW2NlbGxdID0gaW5kZXg7XG4gICAgICAgIH0pO1xuICAgICAgICBpdGVtUGxhY2VkID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0YXJ0SW5kZXgrKztcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuXG4gIC8vIGNvbnZlcnQgaW50byBhIG5vbi1zcGFyc2UgYXJyYXlcbiAgcmV0dXJuIFsuLi5jZWxsTWFwXTtcbn1cblxuLyoqIEdldHMgY2VsbCBpbmRleCBvZiBhbiBpdGVtJ3MgY29ybmVyIG9yIC0xIHdoZW4gaW5kZXggaXMgLTEuICovXG5mdW5jdGlvbiBnZXRDZWxsSW5kZXhPZkNvcm5lcihpbmRleCwgc2l6ZXMsIGNlbGxNYXAsIGNvbHMsIGNvcm5lcikge1xuICBpZiAoaW5kZXggPT09IC0xKSByZXR1cm4gLTE7XG4gIGNvbnN0IGZpcnN0Q2VsbEluZGV4ID0gY2VsbE1hcC5pbmRleE9mKGluZGV4KTtcbiAgc3dpdGNoIChjb3JuZXIpIHtcbiAgICBjYXNlICd0bCc6XG4gICAgICByZXR1cm4gZmlyc3RDZWxsSW5kZXg7XG4gICAgY2FzZSAndHInOlxuICAgICAgcmV0dXJuIGZpcnN0Q2VsbEluZGV4ICsgc2l6ZXNbaW5kZXhdLndpZHRoIC0gMTtcbiAgICBjYXNlICdibCc6XG4gICAgICByZXR1cm4gZmlyc3RDZWxsSW5kZXggKyAoc2l6ZXNbaW5kZXhdLmhlaWdodCAtIDEpICogY29scztcbiAgICBjYXNlICdicic6XG4gICAgICByZXR1cm4gY2VsbE1hcC5sYXN0SW5kZXhPZihpbmRleCk7XG4gIH1cbn1cblxuLyoqIEdldHMgYWxsIGNlbGwgaW5kaWNlcyB0aGF0IGNvcnJlc3BvbmQgdG8gdGhlIHNwZWNpZmllZCBpbmRpY2VzICovXG5mdW5jdGlvbiBnZXRDZWxsSW5kaWNlcyhpbmRpY2VzLCBjZWxsTWFwKSB7XG4gIHJldHVybiBjZWxsTWFwLmZsYXRNYXAoKGluZGV4LCBjZWxsSW5kZXgpID0+IGluZGljZXMuaW5jbHVkZXMoaW5kZXgpID8gW2NlbGxJbmRleF0gOiBbXSk7XG59XG5cbmxldCByYWZJZCA9IDA7XG5mdW5jdGlvbiBlbnF1ZXVlRm9jdXMoZWwsIG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfVxuICBjb25zdCB7XG4gICAgcHJldmVudFNjcm9sbCA9IGZhbHNlLFxuICAgIGNhbmNlbFByZXZpb3VzID0gdHJ1ZSxcbiAgICBzeW5jID0gZmFsc2VcbiAgfSA9IG9wdGlvbnM7XG4gIGNhbmNlbFByZXZpb3VzICYmIGNhbmNlbEFuaW1hdGlvbkZyYW1lKHJhZklkKTtcbiAgY29uc3QgZXhlYyA9ICgpID0+IGVsID09IG51bGwgPyB2b2lkIDAgOiBlbC5mb2N1cyh7XG4gICAgcHJldmVudFNjcm9sbFxuICB9KTtcbiAgaWYgKHN5bmMpIHtcbiAgICBleGVjKCk7XG4gIH0gZWxzZSB7XG4gICAgcmFmSWQgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZXhlYyk7XG4gIH1cbn1cblxudmFyIGluZGV4ID0gdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyA/IHVzZUxheW91dEVmZmVjdCA6IHVzZUVmZmVjdDtcblxuZnVuY3Rpb24gc29ydEJ5RG9jdW1lbnRQb3NpdGlvbihhLCBiKSB7XG4gIGNvbnN0IHBvc2l0aW9uID0gYS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbihiKTtcbiAgaWYgKHBvc2l0aW9uICYgTm9kZS5ET0NVTUVOVF9QT1NJVElPTl9GT0xMT1dJTkcgfHwgcG9zaXRpb24gJiBOb2RlLkRPQ1VNRU5UX1BPU0lUSU9OX0NPTlRBSU5FRF9CWSkge1xuICAgIHJldHVybiAtMTtcbiAgfVxuICBpZiAocG9zaXRpb24gJiBOb2RlLkRPQ1VNRU5UX1BPU0lUSU9OX1BSRUNFRElORyB8fCBwb3NpdGlvbiAmIE5vZGUuRE9DVU1FTlRfUE9TSVRJT05fQ09OVEFJTlMpIHtcbiAgICByZXR1cm4gMTtcbiAgfVxuICByZXR1cm4gMDtcbn1cbmZ1bmN0aW9uIGFyZU1hcHNFcXVhbChtYXAxLCBtYXAyKSB7XG4gIGlmIChtYXAxLnNpemUgIT09IG1hcDIuc2l6ZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBtYXAxLmVudHJpZXMoKSkge1xuICAgIGlmICh2YWx1ZSAhPT0gbWFwMi5nZXQoa2V5KSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cbmNvbnN0IEZsb2F0aW5nTGlzdENvbnRleHQgPSAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlQ29udGV4dCh7XG4gIHJlZ2lzdGVyOiAoKSA9PiB7fSxcbiAgdW5yZWdpc3RlcjogKCkgPT4ge30sXG4gIG1hcDogLyojX19QVVJFX18qL25ldyBNYXAoKSxcbiAgZWxlbWVudHNSZWY6IHtcbiAgICBjdXJyZW50OiBbXVxuICB9XG59KTtcbi8qKlxuICogUHJvdmlkZXMgY29udGV4dCBmb3IgYSBsaXN0IG9mIGl0ZW1zIHdpdGhpbiB0aGUgZmxvYXRpbmcgZWxlbWVudC5cbiAqIEBzZWUgaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy9GbG9hdGluZ0xpc3RcbiAqL1xuZnVuY3Rpb24gRmxvYXRpbmdMaXN0KF9yZWYpIHtcbiAgbGV0IHtcbiAgICBjaGlsZHJlbixcbiAgICBlbGVtZW50c1JlZixcbiAgICBsYWJlbHNSZWZcbiAgfSA9IF9yZWY7XG4gIGNvbnN0IFttYXAsIHNldE1hcF0gPSBSZWFjdC51c2VTdGF0ZSgoKSA9PiBuZXcgTWFwKCkpO1xuICBjb25zdCByZWdpc3RlciA9IFJlYWN0LnVzZUNhbGxiYWNrKG5vZGUgPT4ge1xuICAgIHNldE1hcChwcmV2TWFwID0+IG5ldyBNYXAocHJldk1hcCkuc2V0KG5vZGUsIG51bGwpKTtcbiAgfSwgW10pO1xuICBjb25zdCB1bnJlZ2lzdGVyID0gUmVhY3QudXNlQ2FsbGJhY2sobm9kZSA9PiB7XG4gICAgc2V0TWFwKHByZXZNYXAgPT4ge1xuICAgICAgY29uc3QgbWFwID0gbmV3IE1hcChwcmV2TWFwKTtcbiAgICAgIG1hcC5kZWxldGUobm9kZSk7XG4gICAgICByZXR1cm4gbWFwO1xuICAgIH0pO1xuICB9LCBbXSk7XG4gIGluZGV4KCgpID0+IHtcbiAgICBjb25zdCBuZXdNYXAgPSBuZXcgTWFwKG1hcCk7XG4gICAgY29uc3Qgbm9kZXMgPSBBcnJheS5mcm9tKG5ld01hcC5rZXlzKCkpLnNvcnQoc29ydEJ5RG9jdW1lbnRQb3NpdGlvbik7XG4gICAgbm9kZXMuZm9yRWFjaCgobm9kZSwgaW5kZXgpID0+IHtcbiAgICAgIG5ld01hcC5zZXQobm9kZSwgaW5kZXgpO1xuICAgIH0pO1xuICAgIGlmICghYXJlTWFwc0VxdWFsKG1hcCwgbmV3TWFwKSkge1xuICAgICAgc2V0TWFwKG5ld01hcCk7XG4gICAgfVxuICB9LCBbbWFwXSk7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChGbG9hdGluZ0xpc3RDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgdmFsdWU6IFJlYWN0LnVzZU1lbW8oKCkgPT4gKHtcbiAgICAgIHJlZ2lzdGVyLFxuICAgICAgdW5yZWdpc3RlcixcbiAgICAgIG1hcCxcbiAgICAgIGVsZW1lbnRzUmVmLFxuICAgICAgbGFiZWxzUmVmXG4gICAgfSksIFtyZWdpc3RlciwgdW5yZWdpc3RlciwgbWFwLCBlbGVtZW50c1JlZiwgbGFiZWxzUmVmXSlcbiAgfSwgY2hpbGRyZW4pO1xufVxuLyoqXG4gKiBVc2VkIHRvIHJlZ2lzdGVyIGEgbGlzdCBpdGVtIGFuZCBpdHMgaW5kZXggKERPTSBwb3NpdGlvbikgaW4gdGhlXG4gKiBgRmxvYXRpbmdMaXN0YC5cbiAqIEBzZWUgaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy9GbG9hdGluZ0xpc3QjdXNlbGlzdGl0ZW1cbiAqL1xuZnVuY3Rpb24gdXNlTGlzdEl0ZW0oX3RlbXApIHtcbiAgbGV0IHtcbiAgICBsYWJlbFxuICB9ID0gX3RlbXAgPT09IHZvaWQgMCA/IHt9IDogX3RlbXA7XG4gIGNvbnN0IFtpbmRleCQxLCBzZXRJbmRleF0gPSBSZWFjdC51c2VTdGF0ZShudWxsKTtcbiAgY29uc3QgY29tcG9uZW50UmVmID0gUmVhY3QudXNlUmVmKG51bGwpO1xuICBjb25zdCB7XG4gICAgcmVnaXN0ZXIsXG4gICAgdW5yZWdpc3RlcixcbiAgICBtYXAsXG4gICAgZWxlbWVudHNSZWYsXG4gICAgbGFiZWxzUmVmXG4gIH0gPSBSZWFjdC51c2VDb250ZXh0KEZsb2F0aW5nTGlzdENvbnRleHQpO1xuICBjb25zdCByZWYgPSBSZWFjdC51c2VDYWxsYmFjayhub2RlID0+IHtcbiAgICBjb21wb25lbnRSZWYuY3VycmVudCA9IG5vZGU7XG4gICAgaWYgKGluZGV4JDEgIT09IG51bGwpIHtcbiAgICAgIGVsZW1lbnRzUmVmLmN1cnJlbnRbaW5kZXgkMV0gPSBub2RlO1xuICAgICAgaWYgKGxhYmVsc1JlZikge1xuICAgICAgICB2YXIgX25vZGUkdGV4dENvbnRlbnQ7XG4gICAgICAgIGNvbnN0IGlzTGFiZWxEZWZpbmVkID0gbGFiZWwgIT09IHVuZGVmaW5lZDtcbiAgICAgICAgbGFiZWxzUmVmLmN1cnJlbnRbaW5kZXgkMV0gPSBpc0xhYmVsRGVmaW5lZCA/IGxhYmVsIDogKF9ub2RlJHRleHRDb250ZW50ID0gbm9kZSA9PSBudWxsID8gdm9pZCAwIDogbm9kZS50ZXh0Q29udGVudCkgIT0gbnVsbCA/IF9ub2RlJHRleHRDb250ZW50IDogbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gIH0sIFtpbmRleCQxLCBlbGVtZW50c1JlZiwgbGFiZWxzUmVmLCBsYWJlbF0pO1xuICBpbmRleCgoKSA9PiB7XG4gICAgY29uc3Qgbm9kZSA9IGNvbXBvbmVudFJlZi5jdXJyZW50O1xuICAgIGlmIChub2RlKSB7XG4gICAgICByZWdpc3Rlcihub2RlKTtcbiAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIHVucmVnaXN0ZXIobm9kZSk7XG4gICAgICB9O1xuICAgIH1cbiAgfSwgW3JlZ2lzdGVyLCB1bnJlZ2lzdGVyXSk7XG4gIGluZGV4KCgpID0+IHtcbiAgICBjb25zdCBpbmRleCA9IGNvbXBvbmVudFJlZi5jdXJyZW50ID8gbWFwLmdldChjb21wb25lbnRSZWYuY3VycmVudCkgOiBudWxsO1xuICAgIGlmIChpbmRleCAhPSBudWxsKSB7XG4gICAgICBzZXRJbmRleChpbmRleCk7XG4gICAgfVxuICB9LCBbbWFwXSk7XG4gIHJldHVybiBSZWFjdC51c2VNZW1vKCgpID0+ICh7XG4gICAgcmVmLFxuICAgIGluZGV4OiBpbmRleCQxID09IG51bGwgPyAtMSA6IGluZGV4JDFcbiAgfSksIFtpbmRleCQxLCByZWZdKTtcbn1cblxuZnVuY3Rpb24gcmVuZGVySnN4KHJlbmRlciwgY29tcHV0ZWRQcm9wcykge1xuICBpZiAodHlwZW9mIHJlbmRlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiByZW5kZXIoY29tcHV0ZWRQcm9wcyk7XG4gIH1cbiAgaWYgKHJlbmRlcikge1xuICAgIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY2xvbmVFbGVtZW50KHJlbmRlciwgY29tcHV0ZWRQcm9wcyk7XG4gIH1cbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIGNvbXB1dGVkUHJvcHMpO1xufVxuY29uc3QgQ29tcG9zaXRlQ29udGV4dCA9IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVDb250ZXh0KHtcbiAgYWN0aXZlSW5kZXg6IDAsXG4gIG9uTmF2aWdhdGU6ICgpID0+IHt9XG59KTtcbmNvbnN0IGhvcml6b250YWxLZXlzID0gW0FSUk9XX0xFRlQsIEFSUk9XX1JJR0hUXTtcbmNvbnN0IHZlcnRpY2FsS2V5cyA9IFtBUlJPV19VUCwgQVJST1dfRE9XTl07XG5jb25zdCBhbGxLZXlzID0gWy4uLmhvcml6b250YWxLZXlzLCAuLi52ZXJ0aWNhbEtleXNdO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBzaW5nbGUgdGFiIHN0b3Agd2hvc2UgaXRlbXMgYXJlIG5hdmlnYXRlZCBieSBhcnJvdyBrZXlzLCB3aGljaFxuICogcHJvdmlkZXMgbGlzdCBuYXZpZ2F0aW9uIG91dHNpZGUgb2YgZmxvYXRpbmcgZWxlbWVudCBjb250ZXh0cy5cbiAqXG4gKiBUaGlzIGlzIHVzZWZ1bCB0byBlbmFibGUgbmF2aWdhdGlvbiBvZiBhIGxpc3Qgb2YgaXRlbXMgdGhhdCBhcmVu4oCZdCBwYXJ0IG9mIGFcbiAqIGZsb2F0aW5nIGVsZW1lbnQuIEEgbWVudWJhciBpcyBhbiBleGFtcGxlIG9mIGEgY29tcG9zaXRlLCB3aXRoIGVhY2ggcmVmZXJlbmNlXG4gKiBlbGVtZW50IGJlaW5nIGFuIGl0ZW0uXG4gKiBAc2VlIGh0dHBzOi8vZmxvYXRpbmctdWkuY29tL2RvY3MvQ29tcG9zaXRlXG4gKi9cbmNvbnN0IENvbXBvc2l0ZSA9IC8qI19fUFVSRV9fKi9SZWFjdC5mb3J3YXJkUmVmKGZ1bmN0aW9uIENvbXBvc2l0ZShfcmVmLCBmb3J3YXJkZWRSZWYpIHtcbiAgbGV0IHtcbiAgICByZW5kZXIsXG4gICAgb3JpZW50YXRpb24gPSAnYm90aCcsXG4gICAgbG9vcCA9IHRydWUsXG4gICAgY29scyA9IDEsXG4gICAgZGlzYWJsZWRJbmRpY2VzID0gW10sXG4gICAgYWN0aXZlSW5kZXg6IGV4dGVybmFsQWN0aXZlSW5kZXgsXG4gICAgb25OYXZpZ2F0ZTogZXh0ZXJuYWxTZXRBY3RpdmVJbmRleCxcbiAgICBpdGVtU2l6ZXMsXG4gICAgZGVuc2UgPSBmYWxzZSxcbiAgICAuLi5wcm9wc1xuICB9ID0gX3JlZjtcbiAgY29uc3QgW2ludGVybmFsQWN0aXZlSW5kZXgsIGludGVybmFsU2V0QWN0aXZlSW5kZXhdID0gUmVhY3QudXNlU3RhdGUoMCk7XG4gIGNvbnN0IGFjdGl2ZUluZGV4ID0gZXh0ZXJuYWxBY3RpdmVJbmRleCAhPSBudWxsID8gZXh0ZXJuYWxBY3RpdmVJbmRleCA6IGludGVybmFsQWN0aXZlSW5kZXg7XG4gIGNvbnN0IG9uTmF2aWdhdGUgPSB1c2VFZmZlY3RFdmVudChleHRlcm5hbFNldEFjdGl2ZUluZGV4ICE9IG51bGwgPyBleHRlcm5hbFNldEFjdGl2ZUluZGV4IDogaW50ZXJuYWxTZXRBY3RpdmVJbmRleCk7XG4gIGNvbnN0IGVsZW1lbnRzUmVmID0gUmVhY3QudXNlUmVmKFtdKTtcbiAgY29uc3QgcmVuZGVyRWxlbWVudFByb3BzID0gcmVuZGVyICYmIHR5cGVvZiByZW5kZXIgIT09ICdmdW5jdGlvbicgPyByZW5kZXIucHJvcHMgOiB7fTtcbiAgY29uc3QgY29udGV4dFZhbHVlID0gUmVhY3QudXNlTWVtbygoKSA9PiAoe1xuICAgIGFjdGl2ZUluZGV4LFxuICAgIG9uTmF2aWdhdGVcbiAgfSksIFthY3RpdmVJbmRleCwgb25OYXZpZ2F0ZV0pO1xuICBjb25zdCBpc0dyaWQgPSBjb2xzID4gMTtcbiAgZnVuY3Rpb24gaGFuZGxlS2V5RG93bihldmVudCkge1xuICAgIGlmICghYWxsS2V5cy5pbmNsdWRlcyhldmVudC5rZXkpKSByZXR1cm47XG4gICAgbGV0IG5leHRJbmRleCA9IGFjdGl2ZUluZGV4O1xuICAgIGlmIChpc0dyaWQpIHtcbiAgICAgIGNvbnN0IHNpemVzID0gaXRlbVNpemVzIHx8IEFycmF5LmZyb20oe1xuICAgICAgICBsZW5ndGg6IGVsZW1lbnRzUmVmLmN1cnJlbnQubGVuZ3RoXG4gICAgICB9LCAoKSA9PiAoe1xuICAgICAgICB3aWR0aDogMSxcbiAgICAgICAgaGVpZ2h0OiAxXG4gICAgICB9KSk7XG4gICAgICAvLyBUbyBjYWxjdWxhdGUgbW92ZW1lbnRzIG9uIHRoZSBncmlkLCB3ZSB1c2UgaHlwb3RoZXRpY2FsIGNlbGwgaW5kaWNlc1xuICAgICAgLy8gYXMgaWYgZXZlcnkgaXRlbSB3YXMgMXgxLCB0aGVuIGNvbnZlcnQgYmFjayB0byByZWFsIGluZGljZXMuXG4gICAgICBjb25zdCBjZWxsTWFwID0gYnVpbGRDZWxsTWFwKHNpemVzLCBjb2xzLCBkZW5zZSk7XG4gICAgICBjb25zdCBtaW5HcmlkSW5kZXggPSBjZWxsTWFwLmZpbmRJbmRleChpbmRleCA9PiBpbmRleCAhPSBudWxsICYmICFkaXNhYmxlZEluZGljZXMuaW5jbHVkZXMoaW5kZXgpKTtcbiAgICAgIC8vIGxhc3QgZW5hYmxlZCBpbmRleFxuICAgICAgY29uc3QgbWF4R3JpZEluZGV4ID0gY2VsbE1hcC5yZWR1Y2UoKGZvdW5kSW5kZXgsIGluZGV4LCBjZWxsSW5kZXgpID0+IGluZGV4ICE9IG51bGwgJiYgIShkaXNhYmxlZEluZGljZXMgIT0gbnVsbCAmJiBkaXNhYmxlZEluZGljZXMuaW5jbHVkZXMoaW5kZXgpKSA/IGNlbGxJbmRleCA6IGZvdW5kSW5kZXgsIC0xKTtcbiAgICAgIG5leHRJbmRleCA9IGNlbGxNYXBbZ2V0R3JpZE5hdmlnYXRlZEluZGV4KHtcbiAgICAgICAgY3VycmVudDogY2VsbE1hcC5tYXAoaXRlbUluZGV4ID0+IGl0ZW1JbmRleCA/IGVsZW1lbnRzUmVmLmN1cnJlbnRbaXRlbUluZGV4XSA6IG51bGwpXG4gICAgICB9LCB7XG4gICAgICAgIGV2ZW50LFxuICAgICAgICBvcmllbnRhdGlvbixcbiAgICAgICAgbG9vcCxcbiAgICAgICAgY29scyxcbiAgICAgICAgLy8gdHJlYXQgdW5kZWZpbmVkIChlbXB0eSBncmlkIHNwYWNlcykgYXMgZGlzYWJsZWQgaW5kaWNlcyBzbyB3ZVxuICAgICAgICAvLyBkb24ndCBlbmQgdXAgaW4gdGhlbVxuICAgICAgICBkaXNhYmxlZEluZGljZXM6IGdldENlbGxJbmRpY2VzKFsuLi5kaXNhYmxlZEluZGljZXMsIHVuZGVmaW5lZF0sIGNlbGxNYXApLFxuICAgICAgICBtaW5JbmRleDogbWluR3JpZEluZGV4LFxuICAgICAgICBtYXhJbmRleDogbWF4R3JpZEluZGV4LFxuICAgICAgICBwcmV2SW5kZXg6IGdldENlbGxJbmRleE9mQ29ybmVyKGFjdGl2ZUluZGV4LCBzaXplcywgY2VsbE1hcCwgY29scyxcbiAgICAgICAgLy8gdXNlIGEgY29ybmVyIG1hdGNoaW5nIHRoZSBlZGdlIGNsb3Nlc3QgdG8gdGhlIGRpcmVjdGlvbiB3ZSdyZVxuICAgICAgICAvLyBtb3ZpbmcgaW4gc28gd2UgZG9uJ3QgZW5kIHVwIGluIHRoZSBzYW1lIGl0ZW0uIFByZWZlclxuICAgICAgICAvLyB0b3AvbGVmdCBvdmVyIGJvdHRvbS9yaWdodC5cbiAgICAgICAgZXZlbnQua2V5ID09PSBBUlJPV19ET1dOID8gJ2JsJyA6IGV2ZW50LmtleSA9PT0gQVJST1dfUklHSFQgPyAndHInIDogJ3RsJylcbiAgICAgIH0pXTsgLy8gbmF2aWdhdGVkIGNlbGwgd2lsbCBuZXZlciBiZSBudWxsaXNoXG4gICAgfVxuICAgIGNvbnN0IG1pbkluZGV4ID0gZ2V0TWluSW5kZXgoZWxlbWVudHNSZWYsIGRpc2FibGVkSW5kaWNlcyk7XG4gICAgY29uc3QgbWF4SW5kZXggPSBnZXRNYXhJbmRleChlbGVtZW50c1JlZiwgZGlzYWJsZWRJbmRpY2VzKTtcbiAgICBjb25zdCB0b0VuZEtleXMgPSB7XG4gICAgICBob3Jpem9udGFsOiBbQVJST1dfUklHSFRdLFxuICAgICAgdmVydGljYWw6IFtBUlJPV19ET1dOXSxcbiAgICAgIGJvdGg6IFtBUlJPV19SSUdIVCwgQVJST1dfRE9XTl1cbiAgICB9W29yaWVudGF0aW9uXTtcbiAgICBjb25zdCB0b1N0YXJ0S2V5cyA9IHtcbiAgICAgIGhvcml6b250YWw6IFtBUlJPV19MRUZUXSxcbiAgICAgIHZlcnRpY2FsOiBbQVJST1dfVVBdLFxuICAgICAgYm90aDogW0FSUk9XX0xFRlQsIEFSUk9XX1VQXVxuICAgIH1bb3JpZW50YXRpb25dO1xuICAgIGNvbnN0IHByZXZlbnRlZEtleXMgPSBpc0dyaWQgPyBhbGxLZXlzIDoge1xuICAgICAgaG9yaXpvbnRhbDogaG9yaXpvbnRhbEtleXMsXG4gICAgICB2ZXJ0aWNhbDogdmVydGljYWxLZXlzLFxuICAgICAgYm90aDogYWxsS2V5c1xuICAgIH1bb3JpZW50YXRpb25dO1xuICAgIGlmIChuZXh0SW5kZXggPT09IGFjdGl2ZUluZGV4ICYmIFsuLi50b0VuZEtleXMsIC4uLnRvU3RhcnRLZXlzXS5pbmNsdWRlcyhldmVudC5rZXkpKSB7XG4gICAgICBpZiAobG9vcCAmJiBuZXh0SW5kZXggPT09IG1heEluZGV4ICYmIHRvRW5kS2V5cy5pbmNsdWRlcyhldmVudC5rZXkpKSB7XG4gICAgICAgIG5leHRJbmRleCA9IG1pbkluZGV4O1xuICAgICAgfSBlbHNlIGlmIChsb29wICYmIG5leHRJbmRleCA9PT0gbWluSW5kZXggJiYgdG9TdGFydEtleXMuaW5jbHVkZXMoZXZlbnQua2V5KSkge1xuICAgICAgICBuZXh0SW5kZXggPSBtYXhJbmRleDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5leHRJbmRleCA9IGZpbmROb25EaXNhYmxlZEluZGV4KGVsZW1lbnRzUmVmLCB7XG4gICAgICAgICAgc3RhcnRpbmdJbmRleDogbmV4dEluZGV4LFxuICAgICAgICAgIGRlY3JlbWVudDogdG9TdGFydEtleXMuaW5jbHVkZXMoZXZlbnQua2V5KSxcbiAgICAgICAgICBkaXNhYmxlZEluZGljZXNcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChuZXh0SW5kZXggIT09IGFjdGl2ZUluZGV4ICYmICFpc0luZGV4T3V0T2ZCb3VuZHMoZWxlbWVudHNSZWYsIG5leHRJbmRleCkpIHtcbiAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgaWYgKHByZXZlbnRlZEtleXMuaW5jbHVkZXMoZXZlbnQua2V5KSkge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgfVxuICAgICAgb25OYXZpZ2F0ZShuZXh0SW5kZXgpO1xuXG4gICAgICAvLyBXYWl0IGZvciBGb2N1c01hbmFnZXIgYHJldHVybkZvY3VzYCB0byBleGVjdXRlLlxuICAgICAgcXVldWVNaWNyb3Rhc2soKCkgPT4ge1xuICAgICAgICBlbnF1ZXVlRm9jdXMoZWxlbWVudHNSZWYuY3VycmVudFtuZXh0SW5kZXhdKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBjb25zdCBjb21wdXRlZFByb3BzID0ge1xuICAgIC4uLnByb3BzLFxuICAgIC4uLnJlbmRlckVsZW1lbnRQcm9wcyxcbiAgICByZWY6IGZvcndhcmRlZFJlZixcbiAgICAnYXJpYS1vcmllbnRhdGlvbic6IG9yaWVudGF0aW9uID09PSAnYm90aCcgPyB1bmRlZmluZWQgOiBvcmllbnRhdGlvbixcbiAgICBvbktleURvd24oZSkge1xuICAgICAgcHJvcHMub25LZXlEb3duID09IG51bGwgfHwgcHJvcHMub25LZXlEb3duKGUpO1xuICAgICAgcmVuZGVyRWxlbWVudFByb3BzLm9uS2V5RG93biA9PSBudWxsIHx8IHJlbmRlckVsZW1lbnRQcm9wcy5vbktleURvd24oZSk7XG4gICAgICBoYW5kbGVLZXlEb3duKGUpO1xuICAgIH1cbiAgfTtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KENvbXBvc2l0ZUNvbnRleHQuUHJvdmlkZXIsIHtcbiAgICB2YWx1ZTogY29udGV4dFZhbHVlXG4gIH0sIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KEZsb2F0aW5nTGlzdCwge1xuICAgIGVsZW1lbnRzUmVmOiBlbGVtZW50c1JlZlxuICB9LCByZW5kZXJKc3gocmVuZGVyLCBjb21wdXRlZFByb3BzKSkpO1xufSk7XG4vKipcbiAqIEBzZWUgaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy9Db21wb3NpdGVcbiAqL1xuY29uc3QgQ29tcG9zaXRlSXRlbSA9IC8qI19fUFVSRV9fKi9SZWFjdC5mb3J3YXJkUmVmKGZ1bmN0aW9uIENvbXBvc2l0ZUl0ZW0oX3JlZjIsIGZvcndhcmRlZFJlZikge1xuICBsZXQge1xuICAgIHJlbmRlcixcbiAgICAuLi5wcm9wc1xuICB9ID0gX3JlZjI7XG4gIGNvbnN0IHJlbmRlckVsZW1lbnRQcm9wcyA9IHJlbmRlciAmJiB0eXBlb2YgcmVuZGVyICE9PSAnZnVuY3Rpb24nID8gcmVuZGVyLnByb3BzIDoge307XG4gIGNvbnN0IHtcbiAgICBhY3RpdmVJbmRleCxcbiAgICBvbk5hdmlnYXRlXG4gIH0gPSBSZWFjdC51c2VDb250ZXh0KENvbXBvc2l0ZUNvbnRleHQpO1xuICBjb25zdCB7XG4gICAgcmVmLFxuICAgIGluZGV4XG4gIH0gPSB1c2VMaXN0SXRlbSgpO1xuICBjb25zdCBtZXJnZWRSZWYgPSB1c2VNZXJnZVJlZnMoW3JlZiwgZm9yd2FyZGVkUmVmLCByZW5kZXJFbGVtZW50UHJvcHMucmVmXSk7XG4gIGNvbnN0IGlzQWN0aXZlID0gYWN0aXZlSW5kZXggPT09IGluZGV4O1xuICBjb25zdCBjb21wdXRlZFByb3BzID0ge1xuICAgIC4uLnByb3BzLFxuICAgIC4uLnJlbmRlckVsZW1lbnRQcm9wcyxcbiAgICByZWY6IG1lcmdlZFJlZixcbiAgICB0YWJJbmRleDogaXNBY3RpdmUgPyAwIDogLTEsXG4gICAgJ2RhdGEtYWN0aXZlJzogaXNBY3RpdmUgPyAnJyA6IHVuZGVmaW5lZCxcbiAgICBvbkZvY3VzKGUpIHtcbiAgICAgIHByb3BzLm9uRm9jdXMgPT0gbnVsbCB8fCBwcm9wcy5vbkZvY3VzKGUpO1xuICAgICAgcmVuZGVyRWxlbWVudFByb3BzLm9uRm9jdXMgPT0gbnVsbCB8fCByZW5kZXJFbGVtZW50UHJvcHMub25Gb2N1cyhlKTtcbiAgICAgIG9uTmF2aWdhdGUoaW5kZXgpO1xuICAgIH1cbiAgfTtcbiAgcmV0dXJuIHJlbmRlckpzeChyZW5kZXIsIGNvbXB1dGVkUHJvcHMpO1xufSk7XG5cbmZ1bmN0aW9uIF9leHRlbmRzKCkge1xuICBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gPyBPYmplY3QuYXNzaWduLmJpbmQoKSA6IGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgIGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHtcbiAgICAgICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0YXJnZXQ7XG4gIH07XG4gIHJldHVybiBfZXh0ZW5kcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5sZXQgc2VydmVySGFuZG9mZkNvbXBsZXRlID0gZmFsc2U7XG5sZXQgY291bnQgPSAwO1xuY29uc3QgZ2VuSWQgPSAoKSA9PiBcImZsb2F0aW5nLXVpLVwiICsgY291bnQrKztcbmZ1bmN0aW9uIHVzZUZsb2F0aW5nSWQoKSB7XG4gIGNvbnN0IFtpZCwgc2V0SWRdID0gUmVhY3QudXNlU3RhdGUoKCkgPT4gc2VydmVySGFuZG9mZkNvbXBsZXRlID8gZ2VuSWQoKSA6IHVuZGVmaW5lZCk7XG5cbiAgLy8gYmlvbWUtaWdub3JlIGxpbnQvY29ycmVjdG5lc3MvdXNlRXhoYXVzdGl2ZURlcGVuZGVuY2llczogaW50ZW50aW9uYWxcbiAgaW5kZXgoKCkgPT4ge1xuICAgIGlmIChpZCA9PSBudWxsKSB7XG4gICAgICBzZXRJZChnZW5JZCgpKTtcbiAgICB9XG4gIH0sIFtdKTtcbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoIXNlcnZlckhhbmRvZmZDb21wbGV0ZSkge1xuICAgICAgc2VydmVySGFuZG9mZkNvbXBsZXRlID0gdHJ1ZTtcbiAgICB9XG4gIH0sIFtdKTtcbiAgcmV0dXJuIGlkO1xufVxuXG4vLyBgdG9TdHJpbmcoKWAgcHJldmVudHMgYnVuZGxlcnMgZnJvbSB0cnlpbmcgdG8gYGltcG9ydCB7IHVzZUlkIH0gZnJvbSAncmVhY3QnYFxuY29uc3QgdXNlUmVhY3RJZCA9IFJlYWN0Wy8qI19fUFVSRV9fKi8ndXNlSWQnLnRvU3RyaW5nKCldO1xuXG4vKipcbiAqIFVzZXMgUmVhY3QgMTgncyBidWlsdC1pbiBgdXNlSWQoKWAgd2hlbiBhdmFpbGFibGUsIG9yIGZhbGxzIGJhY2sgdG8gYVxuICogc2xpZ2h0bHkgbGVzcyBwZXJmb3JtYW50IChyZXF1aXJpbmcgYSBkb3VibGUgcmVuZGVyKSBpbXBsZW1lbnRhdGlvbiBmb3JcbiAqIGVhcmxpZXIgUmVhY3QgdmVyc2lvbnMuXG4gKiBAc2VlIGh0dHBzOi8vZmxvYXRpbmctdWkuY29tL2RvY3MvcmVhY3QtdXRpbHMjdXNlaWRcbiAqL1xuY29uc3QgdXNlSWQgPSB1c2VSZWFjdElkIHx8IHVzZUZsb2F0aW5nSWQ7XG5cbi8qKlxuICogUmVuZGVycyBhIHBvaW50aW5nIGFycm93IHRyaWFuZ2xlLlxuICogQHNlZSBodHRwczovL2Zsb2F0aW5nLXVpLmNvbS9kb2NzL0Zsb2F0aW5nQXJyb3dcbiAqL1xuY29uc3QgRmxvYXRpbmdBcnJvdyA9IC8qI19fUFVSRV9fKi9SZWFjdC5mb3J3YXJkUmVmKGZ1bmN0aW9uIEZsb2F0aW5nQXJyb3coX3JlZiwgcmVmKSB7XG4gIGxldCB7XG4gICAgY29udGV4dDoge1xuICAgICAgcGxhY2VtZW50LFxuICAgICAgZWxlbWVudHM6IHtcbiAgICAgICAgZmxvYXRpbmdcbiAgICAgIH0sXG4gICAgICBtaWRkbGV3YXJlRGF0YToge1xuICAgICAgICBhcnJvd1xuICAgICAgfVxuICAgIH0sXG4gICAgd2lkdGggPSAxNCxcbiAgICBoZWlnaHQgPSA3LFxuICAgIHRpcFJhZGl1cyA9IDAsXG4gICAgc3Ryb2tlV2lkdGggPSAwLFxuICAgIHN0YXRpY09mZnNldCxcbiAgICBzdHJva2UsXG4gICAgZCxcbiAgICBzdHlsZToge1xuICAgICAgdHJhbnNmb3JtLFxuICAgICAgLi4ucmVzdFN0eWxlXG4gICAgfSA9IHt9LFxuICAgIC4uLnJlc3RcbiAgfSA9IF9yZWY7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICBpZiAoIXJlZikge1xuICAgICAgY29uc29sZS53YXJuKCdGbG9hdGluZyBVSTogVGhlIGByZWZgIHByb3AgaXMgcmVxdWlyZWQgZm9yIHRoZSBgRmxvYXRpbmdBcnJvd2AnLCAnY29tcG9uZW50LicpO1xuICAgIH1cbiAgfVxuICBjb25zdCBjbGlwUGF0aElkID0gdXNlSWQoKTtcbiAgaWYgKCFmbG9hdGluZykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLy8gU3Ryb2tlcyBtdXN0IGJlIGRvdWJsZSB0aGUgYm9yZGVyIHdpZHRoLCB0aGlzIGVuc3VyZXMgdGhlIHN0cm9rZSdzIHdpZHRoXG4gIC8vIHdvcmtzIGFzIHlvdSdkIGV4cGVjdC5cbiAgc3Ryb2tlV2lkdGggKj0gMjtcbiAgY29uc3QgaGFsZlN0cm9rZVdpZHRoID0gc3Ryb2tlV2lkdGggLyAyO1xuICBjb25zdCBzdmdYID0gd2lkdGggLyAyICogKHRpcFJhZGl1cyAvIC04ICsgMSk7XG4gIGNvbnN0IHN2Z1kgPSBoZWlnaHQgLyAyICogdGlwUmFkaXVzIC8gNDtcbiAgY29uc3QgW3NpZGUsIGFsaWdubWVudF0gPSBwbGFjZW1lbnQuc3BsaXQoJy0nKTtcbiAgY29uc3QgaXNSVEwgPSBwbGF0Zm9ybS5pc1JUTChmbG9hdGluZyk7XG4gIGNvbnN0IGlzQ3VzdG9tU2hhcGUgPSAhIWQ7XG4gIGNvbnN0IGlzVmVydGljYWxTaWRlID0gc2lkZSA9PT0gJ3RvcCcgfHwgc2lkZSA9PT0gJ2JvdHRvbSc7XG4gIGNvbnN0IHlPZmZzZXRQcm9wID0gc3RhdGljT2Zmc2V0ICYmIGFsaWdubWVudCA9PT0gJ2VuZCcgPyAnYm90dG9tJyA6ICd0b3AnO1xuICBsZXQgeE9mZnNldFByb3AgPSBzdGF0aWNPZmZzZXQgJiYgYWxpZ25tZW50ID09PSAnZW5kJyA/ICdyaWdodCcgOiAnbGVmdCc7XG4gIGlmIChzdGF0aWNPZmZzZXQgJiYgaXNSVEwpIHtcbiAgICB4T2Zmc2V0UHJvcCA9IGFsaWdubWVudCA9PT0gJ2VuZCcgPyAnbGVmdCcgOiAncmlnaHQnO1xuICB9XG4gIGNvbnN0IGFycm93WCA9IChhcnJvdyA9PSBudWxsID8gdm9pZCAwIDogYXJyb3cueCkgIT0gbnVsbCA/IHN0YXRpY09mZnNldCB8fCBhcnJvdy54IDogJyc7XG4gIGNvbnN0IGFycm93WSA9IChhcnJvdyA9PSBudWxsID8gdm9pZCAwIDogYXJyb3cueSkgIT0gbnVsbCA/IHN0YXRpY09mZnNldCB8fCBhcnJvdy55IDogJyc7XG4gIGNvbnN0IGRWYWx1ZSA9IGQgfHxcbiAgLy8gYmlvbWUtaWdub3JlIGxpbnQvc3R5bGUvdXNlVGVtcGxhdGU6IHJlYWRhYmlsaXR5XG4gICdNMCwwJyArIChcIiBIXCIgKyB3aWR0aCkgKyAoXCIgTFwiICsgKHdpZHRoIC0gc3ZnWCkgKyBcIixcIiArIChoZWlnaHQgLSBzdmdZKSkgKyAoXCIgUVwiICsgd2lkdGggLyAyICsgXCIsXCIgKyBoZWlnaHQgKyBcIiBcIiArIHN2Z1ggKyBcIixcIiArIChoZWlnaHQgLSBzdmdZKSkgKyAnIFonO1xuICBjb25zdCByb3RhdGlvbiA9IHtcbiAgICB0b3A6IGlzQ3VzdG9tU2hhcGUgPyAncm90YXRlKDE4MGRlZyknIDogJycsXG4gICAgbGVmdDogaXNDdXN0b21TaGFwZSA/ICdyb3RhdGUoOTBkZWcpJyA6ICdyb3RhdGUoLTkwZGVnKScsXG4gICAgYm90dG9tOiBpc0N1c3RvbVNoYXBlID8gJycgOiAncm90YXRlKDE4MGRlZyknLFxuICAgIHJpZ2h0OiBpc0N1c3RvbVNoYXBlID8gJ3JvdGF0ZSgtOTBkZWcpJyA6ICdyb3RhdGUoOTBkZWcpJ1xuICB9W3NpZGVdO1xuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzdmdcIiwgX2V4dGVuZHMoe30sIHJlc3QsIHtcbiAgICBcImFyaWEtaGlkZGVuXCI6IHRydWUsXG4gICAgcmVmOiByZWYsXG4gICAgd2lkdGg6IGlzQ3VzdG9tU2hhcGUgPyB3aWR0aCA6IHdpZHRoICsgc3Ryb2tlV2lkdGgsXG4gICAgaGVpZ2h0OiB3aWR0aCxcbiAgICB2aWV3Qm94OiBcIjAgMCBcIiArIHdpZHRoICsgXCIgXCIgKyAoaGVpZ2h0ID4gd2lkdGggPyBoZWlnaHQgOiB3aWR0aCksXG4gICAgc3R5bGU6IHtcbiAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgICAgcG9pbnRlckV2ZW50czogJ25vbmUnLFxuICAgICAgW3hPZmZzZXRQcm9wXTogYXJyb3dYLFxuICAgICAgW3lPZmZzZXRQcm9wXTogYXJyb3dZLFxuICAgICAgW3NpZGVdOiBpc1ZlcnRpY2FsU2lkZSB8fCBpc0N1c3RvbVNoYXBlID8gJzEwMCUnIDogXCJjYWxjKDEwMCUgLSBcIiArIHN0cm9rZVdpZHRoIC8gMiArIFwicHgpXCIsXG4gICAgICB0cmFuc2Zvcm06IFwiXCIgKyByb3RhdGlvbiArICh0cmFuc2Zvcm0gIT0gbnVsbCA/IHRyYW5zZm9ybSA6ICcnKSxcbiAgICAgIC4uLnJlc3RTdHlsZVxuICAgIH1cbiAgfSksIHN0cm9rZVdpZHRoID4gMCAmJiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcInBhdGhcIiwge1xuICAgIGNsaXBQYXRoOiBcInVybCgjXCIgKyBjbGlwUGF0aElkICsgXCIpXCIsXG4gICAgZmlsbDogXCJub25lXCIsXG4gICAgc3Ryb2tlOiBzdHJva2VcbiAgICAvLyBBY2NvdW50IGZvciB0aGUgc3Ryb2tlIG9uIHRoZSBmaWxsIHBhdGggcmVuZGVyZWQgYmVsb3cuXG4gICAgLFxuICAgIHN0cm9rZVdpZHRoOiBzdHJva2VXaWR0aCArIChkID8gMCA6IDEpLFxuICAgIGQ6IGRWYWx1ZVxuICB9KSwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJwYXRoXCIsIHtcbiAgICBzdHJva2U6IHN0cm9rZVdpZHRoICYmICFkID8gcmVzdC5maWxsIDogJ25vbmUnLFxuICAgIGQ6IGRWYWx1ZVxuICB9KSwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJjbGlwUGF0aFwiLCB7XG4gICAgaWQ6IGNsaXBQYXRoSWRcbiAgfSwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJyZWN0XCIsIHtcbiAgICB4OiAtaGFsZlN0cm9rZVdpZHRoLFxuICAgIHk6IGhhbGZTdHJva2VXaWR0aCAqIChpc0N1c3RvbVNoYXBlID8gLTEgOiAxKSxcbiAgICB3aWR0aDogd2lkdGggKyBzdHJva2VXaWR0aCxcbiAgICBoZWlnaHQ6IHdpZHRoXG4gIH0pKSk7XG59KTtcblxuZnVuY3Rpb24gY3JlYXRlUHViU3ViKCkge1xuICBjb25zdCBtYXAgPSBuZXcgTWFwKCk7XG4gIHJldHVybiB7XG4gICAgZW1pdChldmVudCwgZGF0YSkge1xuICAgICAgdmFyIF9tYXAkZ2V0O1xuICAgICAgKF9tYXAkZ2V0ID0gbWFwLmdldChldmVudCkpID09IG51bGwgfHwgX21hcCRnZXQuZm9yRWFjaChoYW5kbGVyID0+IGhhbmRsZXIoZGF0YSkpO1xuICAgIH0sXG4gICAgb24oZXZlbnQsIGxpc3RlbmVyKSB7XG4gICAgICBtYXAuc2V0KGV2ZW50LCBbLi4uKG1hcC5nZXQoZXZlbnQpIHx8IFtdKSwgbGlzdGVuZXJdKTtcbiAgICB9LFxuICAgIG9mZihldmVudCwgbGlzdGVuZXIpIHtcbiAgICAgIHZhciBfbWFwJGdldDI7XG4gICAgICBtYXAuc2V0KGV2ZW50LCAoKF9tYXAkZ2V0MiA9IG1hcC5nZXQoZXZlbnQpKSA9PSBudWxsID8gdm9pZCAwIDogX21hcCRnZXQyLmZpbHRlcihsID0+IGwgIT09IGxpc3RlbmVyKSkgfHwgW10pO1xuICAgIH1cbiAgfTtcbn1cblxuY29uc3QgRmxvYXRpbmdOb2RlQ29udGV4dCA9IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVDb250ZXh0KG51bGwpO1xuY29uc3QgRmxvYXRpbmdUcmVlQ29udGV4dCA9IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVDb250ZXh0KG51bGwpO1xuXG4vKipcbiAqIFJldHVybnMgdGhlIHBhcmVudCBub2RlIGlkIGZvciBuZXN0ZWQgZmxvYXRpbmcgZWxlbWVudHMsIGlmIGF2YWlsYWJsZS5cbiAqIFJldHVybnMgYG51bGxgIGZvciB0b3AtbGV2ZWwgZmxvYXRpbmcgZWxlbWVudHMuXG4gKi9cbmNvbnN0IHVzZUZsb2F0aW5nUGFyZW50Tm9kZUlkID0gKCkgPT4ge1xuICB2YXIgX1JlYWN0JHVzZUNvbnRleHQ7XG4gIHJldHVybiAoKF9SZWFjdCR1c2VDb250ZXh0ID0gUmVhY3QudXNlQ29udGV4dChGbG9hdGluZ05vZGVDb250ZXh0KSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9SZWFjdCR1c2VDb250ZXh0LmlkKSB8fCBudWxsO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBuZWFyZXN0IGZsb2F0aW5nIHRyZWUgY29udGV4dCwgaWYgYXZhaWxhYmxlLlxuICovXG5jb25zdCB1c2VGbG9hdGluZ1RyZWUgPSAoKSA9PiBSZWFjdC51c2VDb250ZXh0KEZsb2F0aW5nVHJlZUNvbnRleHQpO1xuXG4vKipcbiAqIFJlZ2lzdGVycyBhIG5vZGUgaW50byB0aGUgYEZsb2F0aW5nVHJlZWAsIHJldHVybmluZyBpdHMgaWQuXG4gKiBAc2VlIGh0dHBzOi8vZmxvYXRpbmctdWkuY29tL2RvY3MvRmxvYXRpbmdUcmVlXG4gKi9cbmZ1bmN0aW9uIHVzZUZsb2F0aW5nTm9kZUlkKGN1c3RvbVBhcmVudElkKSB7XG4gIGNvbnN0IGlkID0gdXNlSWQoKTtcbiAgY29uc3QgdHJlZSA9IHVzZUZsb2F0aW5nVHJlZSgpO1xuICBjb25zdCByZWFjdFBhcmVudElkID0gdXNlRmxvYXRpbmdQYXJlbnROb2RlSWQoKTtcbiAgY29uc3QgcGFyZW50SWQgPSBjdXN0b21QYXJlbnRJZCB8fCByZWFjdFBhcmVudElkO1xuICBpbmRleCgoKSA9PiB7XG4gICAgY29uc3Qgbm9kZSA9IHtcbiAgICAgIGlkLFxuICAgICAgcGFyZW50SWRcbiAgICB9O1xuICAgIHRyZWUgPT0gbnVsbCB8fCB0cmVlLmFkZE5vZGUobm9kZSk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHRyZWUgPT0gbnVsbCB8fCB0cmVlLnJlbW92ZU5vZGUobm9kZSk7XG4gICAgfTtcbiAgfSwgW3RyZWUsIGlkLCBwYXJlbnRJZF0pO1xuICByZXR1cm4gaWQ7XG59XG5cbi8qKlxuICogUHJvdmlkZXMgcGFyZW50IG5vZGUgY29udGV4dCBmb3IgbmVzdGVkIGZsb2F0aW5nIGVsZW1lbnRzLlxuICogQHNlZSBodHRwczovL2Zsb2F0aW5nLXVpLmNvbS9kb2NzL0Zsb2F0aW5nVHJlZVxuICovXG5mdW5jdGlvbiBGbG9hdGluZ05vZGUoX3JlZikge1xuICBsZXQge1xuICAgIGNoaWxkcmVuLFxuICAgIGlkXG4gIH0gPSBfcmVmO1xuICBjb25zdCBwYXJlbnRJZCA9IHVzZUZsb2F0aW5nUGFyZW50Tm9kZUlkKCk7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChGbG9hdGluZ05vZGVDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgdmFsdWU6IFJlYWN0LnVzZU1lbW8oKCkgPT4gKHtcbiAgICAgIGlkLFxuICAgICAgcGFyZW50SWRcbiAgICB9KSwgW2lkLCBwYXJlbnRJZF0pXG4gIH0sIGNoaWxkcmVuKTtcbn1cblxuLyoqXG4gKiBQcm92aWRlcyBjb250ZXh0IGZvciBuZXN0ZWQgZmxvYXRpbmcgZWxlbWVudHMgd2hlbiB0aGV5IGFyZSBub3QgY2hpbGRyZW4gb2ZcbiAqIGVhY2ggb3RoZXIgb24gdGhlIERPTS5cbiAqIFRoaXMgaXMgbm90IG5lY2Vzc2FyeSBpbiBhbGwgY2FzZXMsIGV4Y2VwdCB3aGVuIHRoZXJlIG11c3QgYmUgZXhwbGljaXQgY29tbXVuaWNhdGlvbiBiZXR3ZWVuIHBhcmVudCBhbmQgY2hpbGQgZmxvYXRpbmcgZWxlbWVudHMuIEl0IGlzIG5lY2Vzc2FyeSBmb3I6XG4gKiAtIFRoZSBgYnViYmxlc2Agb3B0aW9uIGluIHRoZSBgdXNlRGlzbWlzcygpYCBIb29rXG4gKiAtIE5lc3RlZCB2aXJ0dWFsIGxpc3QgbmF2aWdhdGlvblxuICogLSBOZXN0ZWQgZmxvYXRpbmcgZWxlbWVudHMgdGhhdCBlYWNoIG9wZW4gb24gaG92ZXJcbiAqIC0gQ3VzdG9tIGNvbW11bmljYXRpb24gYmV0d2VlbiBwYXJlbnQgYW5kIGNoaWxkIGZsb2F0aW5nIGVsZW1lbnRzXG4gKiBAc2VlIGh0dHBzOi8vZmxvYXRpbmctdWkuY29tL2RvY3MvRmxvYXRpbmdUcmVlXG4gKi9cbmZ1bmN0aW9uIEZsb2F0aW5nVHJlZShfcmVmMikge1xuICBsZXQge1xuICAgIGNoaWxkcmVuXG4gIH0gPSBfcmVmMjtcbiAgY29uc3Qgbm9kZXNSZWYgPSBSZWFjdC51c2VSZWYoW10pO1xuICBjb25zdCBhZGROb2RlID0gUmVhY3QudXNlQ2FsbGJhY2sobm9kZSA9PiB7XG4gICAgbm9kZXNSZWYuY3VycmVudCA9IFsuLi5ub2Rlc1JlZi5jdXJyZW50LCBub2RlXTtcbiAgfSwgW10pO1xuICBjb25zdCByZW1vdmVOb2RlID0gUmVhY3QudXNlQ2FsbGJhY2sobm9kZSA9PiB7XG4gICAgbm9kZXNSZWYuY3VycmVudCA9IG5vZGVzUmVmLmN1cnJlbnQuZmlsdGVyKG4gPT4gbiAhPT0gbm9kZSk7XG4gIH0sIFtdKTtcbiAgY29uc3QgZXZlbnRzID0gUmVhY3QudXNlU3RhdGUoKCkgPT4gY3JlYXRlUHViU3ViKCkpWzBdO1xuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoRmxvYXRpbmdUcmVlQ29udGV4dC5Qcm92aWRlciwge1xuICAgIHZhbHVlOiBSZWFjdC51c2VNZW1vKCgpID0+ICh7XG4gICAgICBub2Rlc1JlZixcbiAgICAgIGFkZE5vZGUsXG4gICAgICByZW1vdmVOb2RlLFxuICAgICAgZXZlbnRzXG4gICAgfSksIFthZGROb2RlLCByZW1vdmVOb2RlLCBldmVudHNdKVxuICB9LCBjaGlsZHJlbik7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUF0dHJpYnV0ZShuYW1lKSB7XG4gIHJldHVybiBcImRhdGEtZmxvYXRpbmctdWktXCIgKyBuYW1lO1xufVxuXG5mdW5jdGlvbiB1c2VMYXRlc3RSZWYodmFsdWUpIHtcbiAgY29uc3QgcmVmID0gdXNlUmVmKHZhbHVlKTtcbiAgaW5kZXgoKCkgPT4ge1xuICAgIHJlZi5jdXJyZW50ID0gdmFsdWU7XG4gIH0pO1xuICByZXR1cm4gcmVmO1xufVxuXG5jb25zdCBzYWZlUG9seWdvbklkZW50aWZpZXIgPSAvKiNfX1BVUkVfXyovY3JlYXRlQXR0cmlidXRlKCdzYWZlLXBvbHlnb24nKTtcbmZ1bmN0aW9uIGdldERlbGF5KHZhbHVlLCBwcm9wLCBwb2ludGVyVHlwZSkge1xuICBpZiAocG9pbnRlclR5cGUgJiYgIWlzTW91c2VMaWtlUG9pbnRlclR5cGUocG9pbnRlclR5cGUpKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgcmV0dXJuIHZhbHVlID09IG51bGwgPyB2b2lkIDAgOiB2YWx1ZVtwcm9wXTtcbn1cbi8qKlxuICogT3BlbnMgdGhlIGZsb2F0aW5nIGVsZW1lbnQgd2hpbGUgaG92ZXJpbmcgb3ZlciB0aGUgcmVmZXJlbmNlIGVsZW1lbnQsIGxpa2VcbiAqIENTUyBgOmhvdmVyYC5cbiAqIEBzZWUgaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy91c2VIb3ZlclxuICovXG5mdW5jdGlvbiB1c2VIb3Zlcihjb250ZXh0LCBwcm9wcykge1xuICBpZiAocHJvcHMgPT09IHZvaWQgMCkge1xuICAgIHByb3BzID0ge307XG4gIH1cbiAgY29uc3Qge1xuICAgIG9wZW4sXG4gICAgb25PcGVuQ2hhbmdlLFxuICAgIGRhdGFSZWYsXG4gICAgZXZlbnRzLFxuICAgIGVsZW1lbnRzOiB7XG4gICAgICBkb21SZWZlcmVuY2UsXG4gICAgICBmbG9hdGluZ1xuICAgIH0sXG4gICAgcmVmc1xuICB9ID0gY29udGV4dDtcbiAgY29uc3Qge1xuICAgIGVuYWJsZWQgPSB0cnVlLFxuICAgIGRlbGF5ID0gMCxcbiAgICBoYW5kbGVDbG9zZSA9IG51bGwsXG4gICAgbW91c2VPbmx5ID0gZmFsc2UsXG4gICAgcmVzdE1zID0gMCxcbiAgICBtb3ZlID0gdHJ1ZVxuICB9ID0gcHJvcHM7XG4gIGNvbnN0IHRyZWUgPSB1c2VGbG9hdGluZ1RyZWUoKTtcbiAgY29uc3QgcGFyZW50SWQgPSB1c2VGbG9hdGluZ1BhcmVudE5vZGVJZCgpO1xuICBjb25zdCBoYW5kbGVDbG9zZVJlZiA9IHVzZUxhdGVzdFJlZihoYW5kbGVDbG9zZSk7XG4gIGNvbnN0IGRlbGF5UmVmID0gdXNlTGF0ZXN0UmVmKGRlbGF5KTtcbiAgY29uc3QgcG9pbnRlclR5cGVSZWYgPSBSZWFjdC51c2VSZWYoKTtcbiAgY29uc3QgdGltZW91dFJlZiA9IFJlYWN0LnVzZVJlZigpO1xuICBjb25zdCBoYW5kbGVyUmVmID0gUmVhY3QudXNlUmVmKCk7XG4gIGNvbnN0IHJlc3RUaW1lb3V0UmVmID0gUmVhY3QudXNlUmVmKCk7XG4gIGNvbnN0IGJsb2NrTW91c2VNb3ZlUmVmID0gUmVhY3QudXNlUmVmKHRydWUpO1xuICBjb25zdCBwZXJmb3JtZWRQb2ludGVyRXZlbnRzTXV0YXRpb25SZWYgPSBSZWFjdC51c2VSZWYoZmFsc2UpO1xuICBjb25zdCB1bmJpbmRNb3VzZU1vdmVSZWYgPSBSZWFjdC51c2VSZWYoKCkgPT4ge30pO1xuICBjb25zdCBpc0hvdmVyT3BlbiA9IFJlYWN0LnVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICB2YXIgX2RhdGFSZWYkY3VycmVudCRvcGVuO1xuICAgIGNvbnN0IHR5cGUgPSAoX2RhdGFSZWYkY3VycmVudCRvcGVuID0gZGF0YVJlZi5jdXJyZW50Lm9wZW5FdmVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9kYXRhUmVmJGN1cnJlbnQkb3Blbi50eXBlO1xuICAgIHJldHVybiAodHlwZSA9PSBudWxsID8gdm9pZCAwIDogdHlwZS5pbmNsdWRlcygnbW91c2UnKSkgJiYgdHlwZSAhPT0gJ21vdXNlZG93bic7XG4gIH0sIFtkYXRhUmVmXSk7XG5cbiAgLy8gV2hlbiBjbG9zaW5nIGJlZm9yZSBvcGVuaW5nLCBjbGVhciB0aGUgZGVsYXkgdGltZW91dHMgdG8gY2FuY2VsIGl0XG4gIC8vIGZyb20gc2hvd2luZy5cbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoIWVuYWJsZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZnVuY3Rpb24gb25PcGVuQ2hhbmdlKF9yZWYpIHtcbiAgICAgIGxldCB7XG4gICAgICAgIG9wZW5cbiAgICAgIH0gPSBfcmVmO1xuICAgICAgaWYgKCFvcGVuKSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0UmVmLmN1cnJlbnQpO1xuICAgICAgICBjbGVhclRpbWVvdXQocmVzdFRpbWVvdXRSZWYuY3VycmVudCk7XG4gICAgICAgIGJsb2NrTW91c2VNb3ZlUmVmLmN1cnJlbnQgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICBldmVudHMub24oJ29wZW5jaGFuZ2UnLCBvbk9wZW5DaGFuZ2UpO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBldmVudHMub2ZmKCdvcGVuY2hhbmdlJywgb25PcGVuQ2hhbmdlKTtcbiAgICB9O1xuICB9LCBbZW5hYmxlZCwgZXZlbnRzXSk7XG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKCFlbmFibGVkIHx8ICFoYW5kbGVDbG9zZVJlZi5jdXJyZW50IHx8ICFvcGVuKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGZ1bmN0aW9uIG9uTGVhdmUoZXZlbnQpIHtcbiAgICAgIGlmIChpc0hvdmVyT3BlbigpKSB7XG4gICAgICAgIG9uT3BlbkNoYW5nZShmYWxzZSwgZXZlbnQsICdob3ZlcicpO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBodG1sID0gZ2V0RG9jdW1lbnQoZmxvYXRpbmcpLmRvY3VtZW50RWxlbWVudDtcbiAgICBodG1sLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbGVhdmUnLCBvbkxlYXZlKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgaHRtbC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZWxlYXZlJywgb25MZWF2ZSk7XG4gICAgfTtcbiAgfSwgW2Zsb2F0aW5nLCBvcGVuLCBvbk9wZW5DaGFuZ2UsIGVuYWJsZWQsIGhhbmRsZUNsb3NlUmVmLCBpc0hvdmVyT3Blbl0pO1xuICBjb25zdCBjbG9zZVdpdGhEZWxheSA9IFJlYWN0LnVzZUNhbGxiYWNrKGZ1bmN0aW9uIChldmVudCwgcnVuRWxzZUJyYW5jaCwgcmVhc29uKSB7XG4gICAgaWYgKHJ1bkVsc2VCcmFuY2ggPT09IHZvaWQgMCkge1xuICAgICAgcnVuRWxzZUJyYW5jaCA9IHRydWU7XG4gICAgfVxuICAgIGlmIChyZWFzb24gPT09IHZvaWQgMCkge1xuICAgICAgcmVhc29uID0gJ2hvdmVyJztcbiAgICB9XG4gICAgY29uc3QgY2xvc2VEZWxheSA9IGdldERlbGF5KGRlbGF5UmVmLmN1cnJlbnQsICdjbG9zZScsIHBvaW50ZXJUeXBlUmVmLmN1cnJlbnQpO1xuICAgIGlmIChjbG9zZURlbGF5ICYmICFoYW5kbGVyUmVmLmN1cnJlbnQpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0UmVmLmN1cnJlbnQpO1xuICAgICAgdGltZW91dFJlZi5jdXJyZW50ID0gc2V0VGltZW91dCgoKSA9PiBvbk9wZW5DaGFuZ2UoZmFsc2UsIGV2ZW50LCByZWFzb24pLCBjbG9zZURlbGF5KTtcbiAgICB9IGVsc2UgaWYgKHJ1bkVsc2VCcmFuY2gpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0UmVmLmN1cnJlbnQpO1xuICAgICAgb25PcGVuQ2hhbmdlKGZhbHNlLCBldmVudCwgcmVhc29uKTtcbiAgICB9XG4gIH0sIFtkZWxheVJlZiwgb25PcGVuQ2hhbmdlXSk7XG4gIGNvbnN0IGNsZWFudXBNb3VzZU1vdmVIYW5kbGVyID0gUmVhY3QudXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgIHVuYmluZE1vdXNlTW92ZVJlZi5jdXJyZW50KCk7XG4gICAgaGFuZGxlclJlZi5jdXJyZW50ID0gdW5kZWZpbmVkO1xuICB9LCBbXSk7XG4gIGNvbnN0IGNsZWFyUG9pbnRlckV2ZW50cyA9IFJlYWN0LnVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICBpZiAocGVyZm9ybWVkUG9pbnRlckV2ZW50c011dGF0aW9uUmVmLmN1cnJlbnQpIHtcbiAgICAgIGNvbnN0IGJvZHkgPSBnZXREb2N1bWVudChyZWZzLmZsb2F0aW5nLmN1cnJlbnQpLmJvZHk7XG4gICAgICBib2R5LnN0eWxlLnBvaW50ZXJFdmVudHMgPSAnJztcbiAgICAgIGJvZHkucmVtb3ZlQXR0cmlidXRlKHNhZmVQb2x5Z29uSWRlbnRpZmllcik7XG4gICAgICBwZXJmb3JtZWRQb2ludGVyRXZlbnRzTXV0YXRpb25SZWYuY3VycmVudCA9IGZhbHNlO1xuICAgIH1cbiAgfSwgW3JlZnNdKTtcblxuICAvLyBSZWdpc3RlcmluZyB0aGUgbW91c2UgZXZlbnRzIG9uIHRoZSByZWZlcmVuY2UgZGlyZWN0bHkgdG8gYnlwYXNzIFJlYWN0J3NcbiAgLy8gZGVsZWdhdGlvbiBzeXN0ZW0uIElmIHRoZSBjdXJzb3Igd2FzIG9uIGEgZGlzYWJsZWQgZWxlbWVudCBhbmQgdGhlbiBlbnRlcmVkXG4gIC8vIHRoZSByZWZlcmVuY2UgKG5vIGdhcCksIGBtb3VzZWVudGVyYCBkb2Vzbid0IGZpcmUgaW4gdGhlIGRlbGVnYXRpb24gc3lzdGVtLlxuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmICghZW5hYmxlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBmdW5jdGlvbiBpc0NsaWNrTGlrZU9wZW5FdmVudCgpIHtcbiAgICAgIHJldHVybiBkYXRhUmVmLmN1cnJlbnQub3BlbkV2ZW50ID8gWydjbGljaycsICdtb3VzZWRvd24nXS5pbmNsdWRlcyhkYXRhUmVmLmN1cnJlbnQub3BlbkV2ZW50LnR5cGUpIDogZmFsc2U7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG9uTW91c2VFbnRlcihldmVudCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRSZWYuY3VycmVudCk7XG4gICAgICBibG9ja01vdXNlTW92ZVJlZi5jdXJyZW50ID0gZmFsc2U7XG4gICAgICBpZiAobW91c2VPbmx5ICYmICFpc01vdXNlTGlrZVBvaW50ZXJUeXBlKHBvaW50ZXJUeXBlUmVmLmN1cnJlbnQpIHx8IHJlc3RNcyA+IDAgJiYgZ2V0RGVsYXkoZGVsYXlSZWYuY3VycmVudCwgJ29wZW4nKSA9PT0gMCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBvcGVuRGVsYXkgPSBnZXREZWxheShkZWxheVJlZi5jdXJyZW50LCAnb3BlbicsIHBvaW50ZXJUeXBlUmVmLmN1cnJlbnQpO1xuICAgICAgaWYgKG9wZW5EZWxheSkge1xuICAgICAgICB0aW1lb3V0UmVmLmN1cnJlbnQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICBvbk9wZW5DaGFuZ2UodHJ1ZSwgZXZlbnQsICdob3ZlcicpO1xuICAgICAgICB9LCBvcGVuRGVsYXkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb25PcGVuQ2hhbmdlKHRydWUsIGV2ZW50LCAnaG92ZXInKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gb25Nb3VzZUxlYXZlKGV2ZW50KSB7XG4gICAgICBpZiAoaXNDbGlja0xpa2VPcGVuRXZlbnQoKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB1bmJpbmRNb3VzZU1vdmVSZWYuY3VycmVudCgpO1xuICAgICAgY29uc3QgZG9jID0gZ2V0RG9jdW1lbnQoZmxvYXRpbmcpO1xuICAgICAgY2xlYXJUaW1lb3V0KHJlc3RUaW1lb3V0UmVmLmN1cnJlbnQpO1xuICAgICAgaWYgKGhhbmRsZUNsb3NlUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgLy8gUHJldmVudCBjbGVhcmluZyBgb25TY3JvbGxNb3VzZUxlYXZlYCB0aW1lb3V0LlxuICAgICAgICBpZiAoIW9wZW4pIHtcbiAgICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dFJlZi5jdXJyZW50KTtcbiAgICAgICAgfVxuICAgICAgICBoYW5kbGVyUmVmLmN1cnJlbnQgPSBoYW5kbGVDbG9zZVJlZi5jdXJyZW50KHtcbiAgICAgICAgICAuLi5jb250ZXh0LFxuICAgICAgICAgIHRyZWUsXG4gICAgICAgICAgeDogZXZlbnQuY2xpZW50WCxcbiAgICAgICAgICB5OiBldmVudC5jbGllbnRZLFxuICAgICAgICAgIG9uQ2xvc2UoKSB7XG4gICAgICAgICAgICBjbGVhclBvaW50ZXJFdmVudHMoKTtcbiAgICAgICAgICAgIGNsZWFudXBNb3VzZU1vdmVIYW5kbGVyKCk7XG4gICAgICAgICAgICBjbG9zZVdpdGhEZWxheShldmVudCwgdHJ1ZSwgJ3NhZmUtcG9seWdvbicpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGhhbmRsZXIgPSBoYW5kbGVyUmVmLmN1cnJlbnQ7XG4gICAgICAgIGRvYy5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBoYW5kbGVyKTtcbiAgICAgICAgdW5iaW5kTW91c2VNb3ZlUmVmLmN1cnJlbnQgPSAoKSA9PiB7XG4gICAgICAgICAgZG9jLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIGhhbmRsZXIpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIEFsbG93IGludGVyYWN0aXZpdHkgd2l0aG91dCBgc2FmZVBvbHlnb25gIG9uIHRvdWNoIGRldmljZXMuIFdpdGggYVxuICAgICAgLy8gcG9pbnRlciwgYSBzaG9ydCBjbG9zZSBkZWxheSBpcyBhbiBhbHRlcm5hdGl2ZSwgc28gaXQgc2hvdWxkIHdvcmtcbiAgICAgIC8vIGNvbnNpc3RlbnRseS5cbiAgICAgIGNvbnN0IHNob3VsZENsb3NlID0gcG9pbnRlclR5cGVSZWYuY3VycmVudCA9PT0gJ3RvdWNoJyA/ICFjb250YWlucyhmbG9hdGluZywgZXZlbnQucmVsYXRlZFRhcmdldCkgOiB0cnVlO1xuICAgICAgaWYgKHNob3VsZENsb3NlKSB7XG4gICAgICAgIGNsb3NlV2l0aERlbGF5KGV2ZW50KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBFbnN1cmUgdGhlIGZsb2F0aW5nIGVsZW1lbnQgY2xvc2VzIGFmdGVyIHNjcm9sbGluZyBldmVuIGlmIHRoZSBwb2ludGVyXG4gICAgLy8gZGlkIG5vdCBtb3ZlLlxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mbG9hdGluZy11aS9mbG9hdGluZy11aS9kaXNjdXNzaW9ucy8xNjkyXG4gICAgZnVuY3Rpb24gb25TY3JvbGxNb3VzZUxlYXZlKGV2ZW50KSB7XG4gICAgICBpZiAoaXNDbGlja0xpa2VPcGVuRXZlbnQoKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBoYW5kbGVDbG9zZVJlZi5jdXJyZW50ID09IG51bGwgfHwgaGFuZGxlQ2xvc2VSZWYuY3VycmVudCh7XG4gICAgICAgIC4uLmNvbnRleHQsXG4gICAgICAgIHRyZWUsXG4gICAgICAgIHg6IGV2ZW50LmNsaWVudFgsXG4gICAgICAgIHk6IGV2ZW50LmNsaWVudFksXG4gICAgICAgIG9uQ2xvc2UoKSB7XG4gICAgICAgICAgY2xlYXJQb2ludGVyRXZlbnRzKCk7XG4gICAgICAgICAgY2xlYW51cE1vdXNlTW92ZUhhbmRsZXIoKTtcbiAgICAgICAgICBjbG9zZVdpdGhEZWxheShldmVudCk7XG4gICAgICAgIH1cbiAgICAgIH0pKGV2ZW50KTtcbiAgICB9XG4gICAgaWYgKGlzRWxlbWVudChkb21SZWZlcmVuY2UpKSB7XG4gICAgICBjb25zdCByZWYgPSBkb21SZWZlcmVuY2U7XG4gICAgICBvcGVuICYmIHJlZi5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWxlYXZlJywgb25TY3JvbGxNb3VzZUxlYXZlKTtcbiAgICAgIGZsb2F0aW5nID09IG51bGwgfHwgZmxvYXRpbmcuYWRkRXZlbnRMaXN0ZW5lcignbW91c2VsZWF2ZScsIG9uU2Nyb2xsTW91c2VMZWF2ZSk7XG4gICAgICBtb3ZlICYmIHJlZi5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBvbk1vdXNlRW50ZXIsIHtcbiAgICAgICAgb25jZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgICByZWYuYWRkRXZlbnRMaXN0ZW5lcignbW91c2VlbnRlcicsIG9uTW91c2VFbnRlcik7XG4gICAgICByZWYuYWRkRXZlbnRMaXN0ZW5lcignbW91c2VsZWF2ZScsIG9uTW91c2VMZWF2ZSk7XG4gICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICBvcGVuICYmIHJlZi5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZWxlYXZlJywgb25TY3JvbGxNb3VzZUxlYXZlKTtcbiAgICAgICAgZmxvYXRpbmcgPT0gbnVsbCB8fCBmbG9hdGluZy5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZWxlYXZlJywgb25TY3JvbGxNb3VzZUxlYXZlKTtcbiAgICAgICAgbW92ZSAmJiByZWYucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgb25Nb3VzZUVudGVyKTtcbiAgICAgICAgcmVmLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlZW50ZXInLCBvbk1vdXNlRW50ZXIpO1xuICAgICAgICByZWYucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2VsZWF2ZScsIG9uTW91c2VMZWF2ZSk7XG4gICAgICB9O1xuICAgIH1cbiAgfSwgW2RvbVJlZmVyZW5jZSwgZmxvYXRpbmcsIGVuYWJsZWQsIGNvbnRleHQsIG1vdXNlT25seSwgcmVzdE1zLCBtb3ZlLCBjbG9zZVdpdGhEZWxheSwgY2xlYW51cE1vdXNlTW92ZUhhbmRsZXIsIGNsZWFyUG9pbnRlckV2ZW50cywgb25PcGVuQ2hhbmdlLCBvcGVuLCB0cmVlLCBkZWxheVJlZiwgaGFuZGxlQ2xvc2VSZWYsIGRhdGFSZWZdKTtcblxuICAvLyBCbG9jayBwb2ludGVyLWV2ZW50cyBvZiBldmVyeSBlbGVtZW50IG90aGVyIHRoYW4gdGhlIHJlZmVyZW5jZSBhbmQgZmxvYXRpbmdcbiAgLy8gd2hpbGUgdGhlIGZsb2F0aW5nIGVsZW1lbnQgaXMgb3BlbiBhbmQgaGFzIGEgYGhhbmRsZUNsb3NlYCBoYW5kbGVyLiBBbHNvXG4gIC8vIGhhbmRsZXMgbmVzdGVkIGZsb2F0aW5nIGVsZW1lbnRzLlxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmxvYXRpbmctdWkvZmxvYXRpbmctdWkvaXNzdWVzLzE3MjJcbiAgaW5kZXgoKCkgPT4ge1xuICAgIHZhciBfaGFuZGxlQ2xvc2VSZWYkY3VycmU7XG4gICAgaWYgKCFlbmFibGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChvcGVuICYmIChfaGFuZGxlQ2xvc2VSZWYkY3VycmUgPSBoYW5kbGVDbG9zZVJlZi5jdXJyZW50KSAhPSBudWxsICYmIF9oYW5kbGVDbG9zZVJlZiRjdXJyZS5fX29wdGlvbnMuYmxvY2tQb2ludGVyRXZlbnRzICYmIGlzSG92ZXJPcGVuKCkpIHtcbiAgICAgIGNvbnN0IGJvZHkgPSBnZXREb2N1bWVudChmbG9hdGluZykuYm9keTtcbiAgICAgIGJvZHkuc2V0QXR0cmlidXRlKHNhZmVQb2x5Z29uSWRlbnRpZmllciwgJycpO1xuICAgICAgYm9keS5zdHlsZS5wb2ludGVyRXZlbnRzID0gJ25vbmUnO1xuICAgICAgcGVyZm9ybWVkUG9pbnRlckV2ZW50c011dGF0aW9uUmVmLmN1cnJlbnQgPSB0cnVlO1xuICAgICAgaWYgKGlzRWxlbWVudChkb21SZWZlcmVuY2UpICYmIGZsb2F0aW5nKSB7XG4gICAgICAgIHZhciBfdHJlZSRub2Rlc1JlZiRjdXJyZW47XG4gICAgICAgIGNvbnN0IHJlZiA9IGRvbVJlZmVyZW5jZTtcbiAgICAgICAgY29uc3QgcGFyZW50RmxvYXRpbmcgPSB0cmVlID09IG51bGwgfHwgKF90cmVlJG5vZGVzUmVmJGN1cnJlbiA9IHRyZWUubm9kZXNSZWYuY3VycmVudC5maW5kKG5vZGUgPT4gbm9kZS5pZCA9PT0gcGFyZW50SWQpKSA9PSBudWxsIHx8IChfdHJlZSRub2Rlc1JlZiRjdXJyZW4gPSBfdHJlZSRub2Rlc1JlZiRjdXJyZW4uY29udGV4dCkgPT0gbnVsbCA/IHZvaWQgMCA6IF90cmVlJG5vZGVzUmVmJGN1cnJlbi5lbGVtZW50cy5mbG9hdGluZztcbiAgICAgICAgaWYgKHBhcmVudEZsb2F0aW5nKSB7XG4gICAgICAgICAgcGFyZW50RmxvYXRpbmcuc3R5bGUucG9pbnRlckV2ZW50cyA9ICcnO1xuICAgICAgICB9XG4gICAgICAgIHJlZi5zdHlsZS5wb2ludGVyRXZlbnRzID0gJ2F1dG8nO1xuICAgICAgICBmbG9hdGluZy5zdHlsZS5wb2ludGVyRXZlbnRzID0gJ2F1dG8nO1xuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgIHJlZi5zdHlsZS5wb2ludGVyRXZlbnRzID0gJyc7XG4gICAgICAgICAgZmxvYXRpbmcuc3R5bGUucG9pbnRlckV2ZW50cyA9ICcnO1xuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cbiAgfSwgW2VuYWJsZWQsIG9wZW4sIHBhcmVudElkLCBmbG9hdGluZywgZG9tUmVmZXJlbmNlLCB0cmVlLCBoYW5kbGVDbG9zZVJlZiwgaXNIb3Zlck9wZW5dKTtcbiAgaW5kZXgoKCkgPT4ge1xuICAgIGlmICghb3Blbikge1xuICAgICAgcG9pbnRlclR5cGVSZWYuY3VycmVudCA9IHVuZGVmaW5lZDtcbiAgICAgIGNsZWFudXBNb3VzZU1vdmVIYW5kbGVyKCk7XG4gICAgICBjbGVhclBvaW50ZXJFdmVudHMoKTtcbiAgICB9XG4gIH0sIFtvcGVuLCBjbGVhbnVwTW91c2VNb3ZlSGFuZGxlciwgY2xlYXJQb2ludGVyRXZlbnRzXSk7XG5cbiAgLy8gYmlvbWUtaWdub3JlIGxpbnQvY29ycmVjdG5lc3MvdXNlRXhoYXVzdGl2ZURlcGVuZGVuY2llczogaW50ZW50aW9uYWxcbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgY2xlYW51cE1vdXNlTW92ZUhhbmRsZXIoKTtcbiAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0UmVmLmN1cnJlbnQpO1xuICAgICAgY2xlYXJUaW1lb3V0KHJlc3RUaW1lb3V0UmVmLmN1cnJlbnQpO1xuICAgICAgY2xlYXJQb2ludGVyRXZlbnRzKCk7XG4gICAgfTtcbiAgfSwgW2VuYWJsZWQsIGRvbVJlZmVyZW5jZSwgY2xlYW51cE1vdXNlTW92ZUhhbmRsZXIsIGNsZWFyUG9pbnRlckV2ZW50c10pO1xuICByZXR1cm4gUmVhY3QudXNlTWVtbygoKSA9PiB7XG4gICAgaWYgKCFlbmFibGVkKSB7XG4gICAgICByZXR1cm4ge307XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNldFBvaW50ZXJSZWYoZXZlbnQpIHtcbiAgICAgIHBvaW50ZXJUeXBlUmVmLmN1cnJlbnQgPSBldmVudC5wb2ludGVyVHlwZTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHJlZmVyZW5jZToge1xuICAgICAgICBvblBvaW50ZXJEb3duOiBzZXRQb2ludGVyUmVmLFxuICAgICAgICBvblBvaW50ZXJFbnRlcjogc2V0UG9pbnRlclJlZixcbiAgICAgICAgb25Nb3VzZU1vdmUoZXZlbnQpIHtcbiAgICAgICAgICBpZiAob3BlbiB8fCByZXN0TXMgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgY2xlYXJUaW1lb3V0KHJlc3RUaW1lb3V0UmVmLmN1cnJlbnQpO1xuICAgICAgICAgIHJlc3RUaW1lb3V0UmVmLmN1cnJlbnQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIGlmICghYmxvY2tNb3VzZU1vdmVSZWYuY3VycmVudCkge1xuICAgICAgICAgICAgICBvbk9wZW5DaGFuZ2UodHJ1ZSwgZXZlbnQubmF0aXZlRXZlbnQsICdob3ZlcicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sIHJlc3RNcyk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBmbG9hdGluZzoge1xuICAgICAgICBvbk1vdXNlRW50ZXIoKSB7XG4gICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRSZWYuY3VycmVudCk7XG4gICAgICAgIH0sXG4gICAgICAgIG9uTW91c2VMZWF2ZShldmVudCkge1xuICAgICAgICAgIGNsb3NlV2l0aERlbGF5KGV2ZW50Lm5hdGl2ZUV2ZW50LCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICB9LCBbZW5hYmxlZCwgcmVzdE1zLCBvcGVuLCBvbk9wZW5DaGFuZ2UsIGNsb3NlV2l0aERlbGF5XSk7XG59XG5cbmNvbnN0IEZsb2F0aW5nRGVsYXlHcm91cENvbnRleHQgPSAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlQ29udGV4dCh7XG4gIGRlbGF5OiAwLFxuICBpbml0aWFsRGVsYXk6IDAsXG4gIHRpbWVvdXRNczogMCxcbiAgY3VycmVudElkOiBudWxsLFxuICBzZXRDdXJyZW50SWQ6ICgpID0+IHt9LFxuICBzZXRTdGF0ZTogKCkgPT4ge30sXG4gIGlzSW5zdGFudFBoYXNlOiBmYWxzZVxufSk7XG5jb25zdCB1c2VEZWxheUdyb3VwQ29udGV4dCA9ICgpID0+IFJlYWN0LnVzZUNvbnRleHQoRmxvYXRpbmdEZWxheUdyb3VwQ29udGV4dCk7XG4vKipcbiAqIFByb3ZpZGVzIGNvbnRleHQgZm9yIGEgZ3JvdXAgb2YgZmxvYXRpbmcgZWxlbWVudHMgdGhhdCBzaG91bGQgc2hhcmUgYVxuICogYGRlbGF5YC5cbiAqIEBzZWUgaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy9GbG9hdGluZ0RlbGF5R3JvdXBcbiAqL1xuY29uc3QgRmxvYXRpbmdEZWxheUdyb3VwID0gX3JlZiA9PiB7XG4gIGxldCB7XG4gICAgY2hpbGRyZW4sXG4gICAgZGVsYXksXG4gICAgdGltZW91dE1zID0gMFxuICB9ID0gX3JlZjtcbiAgY29uc3QgW3N0YXRlLCBzZXRTdGF0ZV0gPSBSZWFjdC51c2VSZWR1Y2VyKChwcmV2LCBuZXh0KSA9PiAoe1xuICAgIC4uLnByZXYsXG4gICAgLi4ubmV4dFxuICB9KSwge1xuICAgIGRlbGF5LFxuICAgIHRpbWVvdXRNcyxcbiAgICBpbml0aWFsRGVsYXk6IGRlbGF5LFxuICAgIGN1cnJlbnRJZDogbnVsbCxcbiAgICBpc0luc3RhbnRQaGFzZTogZmFsc2VcbiAgfSk7XG4gIGNvbnN0IGluaXRpYWxDdXJyZW50SWRSZWYgPSBSZWFjdC51c2VSZWYobnVsbCk7XG4gIGNvbnN0IHNldEN1cnJlbnRJZCA9IFJlYWN0LnVzZUNhbGxiYWNrKGN1cnJlbnRJZCA9PiB7XG4gICAgc2V0U3RhdGUoe1xuICAgICAgY3VycmVudElkXG4gICAgfSk7XG4gIH0sIFtdKTtcbiAgaW5kZXgoKCkgPT4ge1xuICAgIGlmIChzdGF0ZS5jdXJyZW50SWQpIHtcbiAgICAgIGlmIChpbml0aWFsQ3VycmVudElkUmVmLmN1cnJlbnQgPT09IG51bGwpIHtcbiAgICAgICAgaW5pdGlhbEN1cnJlbnRJZFJlZi5jdXJyZW50ID0gc3RhdGUuY3VycmVudElkO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2V0U3RhdGUoe1xuICAgICAgICAgIGlzSW5zdGFudFBoYXNlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzZXRTdGF0ZSh7XG4gICAgICAgIGlzSW5zdGFudFBoYXNlOiBmYWxzZVxuICAgICAgfSk7XG4gICAgICBpbml0aWFsQ3VycmVudElkUmVmLmN1cnJlbnQgPSBudWxsO1xuICAgIH1cbiAgfSwgW3N0YXRlLmN1cnJlbnRJZF0pO1xuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoRmxvYXRpbmdEZWxheUdyb3VwQ29udGV4dC5Qcm92aWRlciwge1xuICAgIHZhbHVlOiBSZWFjdC51c2VNZW1vKCgpID0+ICh7XG4gICAgICAuLi5zdGF0ZSxcbiAgICAgIHNldFN0YXRlLFxuICAgICAgc2V0Q3VycmVudElkXG4gICAgfSksIFtzdGF0ZSwgc2V0Q3VycmVudElkXSlcbiAgfSwgY2hpbGRyZW4pO1xufTtcbi8qKlxuICogRW5hYmxlcyBncm91cGluZyB3aGVuIGNhbGxlZCBpbnNpZGUgYSBjb21wb25lbnQgdGhhdCdzIGEgY2hpbGQgb2YgYVxuICogYEZsb2F0aW5nRGVsYXlHcm91cGAuXG4gKiBAc2VlIGh0dHBzOi8vZmxvYXRpbmctdWkuY29tL2RvY3MvRmxvYXRpbmdEZWxheUdyb3VwXG4gKi9cbmNvbnN0IHVzZURlbGF5R3JvdXAgPSAoX3JlZjIsIF9yZWYzKSA9PiB7XG4gIGxldCB7XG4gICAgb3BlbixcbiAgICBvbk9wZW5DaGFuZ2VcbiAgfSA9IF9yZWYyO1xuICBsZXQge1xuICAgIGlkXG4gIH0gPSBfcmVmMztcbiAgY29uc3Qge1xuICAgIGN1cnJlbnRJZCxcbiAgICBzZXRDdXJyZW50SWQsXG4gICAgaW5pdGlhbERlbGF5LFxuICAgIHNldFN0YXRlLFxuICAgIHRpbWVvdXRNc1xuICB9ID0gdXNlRGVsYXlHcm91cENvbnRleHQoKTtcbiAgaW5kZXgoKCkgPT4ge1xuICAgIGlmIChjdXJyZW50SWQpIHtcbiAgICAgIHNldFN0YXRlKHtcbiAgICAgICAgZGVsYXk6IHtcbiAgICAgICAgICBvcGVuOiAxLFxuICAgICAgICAgIGNsb3NlOiBnZXREZWxheShpbml0aWFsRGVsYXksICdjbG9zZScpXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgaWYgKGN1cnJlbnRJZCAhPT0gaWQpIHtcbiAgICAgICAgb25PcGVuQ2hhbmdlKGZhbHNlKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIFtpZCwgb25PcGVuQ2hhbmdlLCBzZXRTdGF0ZSwgY3VycmVudElkLCBpbml0aWFsRGVsYXldKTtcbiAgaW5kZXgoKCkgPT4ge1xuICAgIGZ1bmN0aW9uIHVuc2V0KCkge1xuICAgICAgb25PcGVuQ2hhbmdlKGZhbHNlKTtcbiAgICAgIHNldFN0YXRlKHtcbiAgICAgICAgZGVsYXk6IGluaXRpYWxEZWxheSxcbiAgICAgICAgY3VycmVudElkOiBudWxsXG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKCFvcGVuICYmIGN1cnJlbnRJZCA9PT0gaWQpIHtcbiAgICAgIGlmICh0aW1lb3V0TXMpIHtcbiAgICAgICAgY29uc3QgdGltZW91dCA9IHdpbmRvdy5zZXRUaW1lb3V0KHVuc2V0LCB0aW1lb3V0TXMpO1xuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHVuc2V0KCk7XG4gICAgfVxuICB9LCBbb3Blbiwgc2V0U3RhdGUsIGN1cnJlbnRJZCwgaWQsIG9uT3BlbkNoYW5nZSwgaW5pdGlhbERlbGF5LCB0aW1lb3V0TXNdKTtcbiAgaW5kZXgoKCkgPT4ge1xuICAgIGlmIChvcGVuKSB7XG4gICAgICBzZXRDdXJyZW50SWQoaWQpO1xuICAgIH1cbiAgfSwgW29wZW4sIHNldEN1cnJlbnRJZCwgaWRdKTtcbn07XG5cbmZ1bmN0aW9uIGdldEFuY2VzdG9ycyhub2RlcywgaWQpIHtcbiAgdmFyIF9ub2RlcyRmaW5kO1xuICBsZXQgYWxsQW5jZXN0b3JzID0gW107XG4gIGxldCBjdXJyZW50UGFyZW50SWQgPSAoX25vZGVzJGZpbmQgPSBub2Rlcy5maW5kKG5vZGUgPT4gbm9kZS5pZCA9PT0gaWQpKSA9PSBudWxsID8gdm9pZCAwIDogX25vZGVzJGZpbmQucGFyZW50SWQ7XG4gIHdoaWxlIChjdXJyZW50UGFyZW50SWQpIHtcbiAgICBjb25zdCBjdXJyZW50Tm9kZSA9IG5vZGVzLmZpbmQobm9kZSA9PiBub2RlLmlkID09PSBjdXJyZW50UGFyZW50SWQpO1xuICAgIGN1cnJlbnRQYXJlbnRJZCA9IGN1cnJlbnROb2RlID09IG51bGwgPyB2b2lkIDAgOiBjdXJyZW50Tm9kZS5wYXJlbnRJZDtcbiAgICBpZiAoY3VycmVudE5vZGUpIHtcbiAgICAgIGFsbEFuY2VzdG9ycyA9IGFsbEFuY2VzdG9ycy5jb25jYXQoY3VycmVudE5vZGUpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gYWxsQW5jZXN0b3JzO1xufVxuXG5mdW5jdGlvbiBnZXRDaGlsZHJlbihub2RlcywgaWQpIHtcbiAgbGV0IGFsbENoaWxkcmVuID0gbm9kZXMuZmlsdGVyKG5vZGUgPT4ge1xuICAgIHZhciBfbm9kZSRjb250ZXh0O1xuICAgIHJldHVybiBub2RlLnBhcmVudElkID09PSBpZCAmJiAoKF9ub2RlJGNvbnRleHQgPSBub2RlLmNvbnRleHQpID09IG51bGwgPyB2b2lkIDAgOiBfbm9kZSRjb250ZXh0Lm9wZW4pO1xuICB9KTtcbiAgbGV0IGN1cnJlbnRDaGlsZHJlbiA9IGFsbENoaWxkcmVuO1xuICB3aGlsZSAoY3VycmVudENoaWxkcmVuLmxlbmd0aCkge1xuICAgIGN1cnJlbnRDaGlsZHJlbiA9IG5vZGVzLmZpbHRlcihub2RlID0+IHtcbiAgICAgIHZhciBfY3VycmVudENoaWxkcmVuO1xuICAgICAgcmV0dXJuIChfY3VycmVudENoaWxkcmVuID0gY3VycmVudENoaWxkcmVuKSA9PSBudWxsID8gdm9pZCAwIDogX2N1cnJlbnRDaGlsZHJlbi5zb21lKG4gPT4ge1xuICAgICAgICB2YXIgX25vZGUkY29udGV4dDI7XG4gICAgICAgIHJldHVybiBub2RlLnBhcmVudElkID09PSBuLmlkICYmICgoX25vZGUkY29udGV4dDIgPSBub2RlLmNvbnRleHQpID09IG51bGwgPyB2b2lkIDAgOiBfbm9kZSRjb250ZXh0Mi5vcGVuKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIGFsbENoaWxkcmVuID0gYWxsQ2hpbGRyZW4uY29uY2F0KGN1cnJlbnRDaGlsZHJlbik7XG4gIH1cbiAgcmV0dXJuIGFsbENoaWxkcmVuO1xufVxuZnVuY3Rpb24gZ2V0RGVlcGVzdE5vZGUobm9kZXMsIGlkKSB7XG4gIGxldCBkZWVwZXN0Tm9kZUlkO1xuICBsZXQgbWF4RGVwdGggPSAtMTtcbiAgZnVuY3Rpb24gZmluZERlZXBlc3Qobm9kZUlkLCBkZXB0aCkge1xuICAgIGlmIChkZXB0aCA+IG1heERlcHRoKSB7XG4gICAgICBkZWVwZXN0Tm9kZUlkID0gbm9kZUlkO1xuICAgICAgbWF4RGVwdGggPSBkZXB0aDtcbiAgICB9XG4gICAgY29uc3QgY2hpbGRyZW4gPSBnZXRDaGlsZHJlbihub2Rlcywgbm9kZUlkKTtcbiAgICBjaGlsZHJlbi5mb3JFYWNoKGNoaWxkID0+IHtcbiAgICAgIGZpbmREZWVwZXN0KGNoaWxkLmlkLCBkZXB0aCArIDEpO1xuICAgIH0pO1xuICB9XG4gIGZpbmREZWVwZXN0KGlkLCAwKTtcbiAgcmV0dXJuIG5vZGVzLmZpbmQobm9kZSA9PiBub2RlLmlkID09PSBkZWVwZXN0Tm9kZUlkKTtcbn1cblxuLy8gTW9kaWZpZWQgdG8gYWRkIGNvbmRpdGlvbmFsIGBhcmlhLWhpZGRlbmAgc3VwcG9ydDpcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS90aGVLYXNoZXkvYXJpYS1oaWRkZW4vYmxvYi85MjIwYzhmNGE0ZmQzNWY2M2JlZTU1MTBhOWY0MWEzNzI2NDM4MmQ0L3NyYy9pbmRleC50c1xubGV0IGNvdW50ZXJNYXAgPSAvKiNfX1BVUkVfXyovbmV3IFdlYWtNYXAoKTtcbmxldCB1bmNvbnRyb2xsZWRFbGVtZW50c1NldCA9IC8qI19fUFVSRV9fKi9uZXcgV2Vha1NldCgpO1xubGV0IG1hcmtlck1hcCA9IHt9O1xubGV0IGxvY2tDb3VudCA9IDA7XG5jb25zdCBzdXBwb3J0c0luZXJ0ID0gKCkgPT4gdHlwZW9mIEhUTUxFbGVtZW50ICE9PSAndW5kZWZpbmVkJyAmJiAnaW5lcnQnIGluIEhUTUxFbGVtZW50LnByb3RvdHlwZTtcbmNvbnN0IHVud3JhcEhvc3QgPSBub2RlID0+IG5vZGUgJiYgKG5vZGUuaG9zdCB8fCB1bndyYXBIb3N0KG5vZGUucGFyZW50Tm9kZSkpO1xuY29uc3QgY29ycmVjdEVsZW1lbnRzID0gKHBhcmVudCwgdGFyZ2V0cykgPT4gdGFyZ2V0cy5tYXAodGFyZ2V0ID0+IHtcbiAgaWYgKHBhcmVudC5jb250YWlucyh0YXJnZXQpKSB7XG4gICAgcmV0dXJuIHRhcmdldDtcbiAgfVxuICBjb25zdCBjb3JyZWN0ZWRUYXJnZXQgPSB1bndyYXBIb3N0KHRhcmdldCk7XG4gIGlmIChwYXJlbnQuY29udGFpbnMoY29ycmVjdGVkVGFyZ2V0KSkge1xuICAgIHJldHVybiBjb3JyZWN0ZWRUYXJnZXQ7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59KS5maWx0ZXIoeCA9PiB4ICE9IG51bGwpO1xuZnVuY3Rpb24gYXBwbHlBdHRyaWJ1dGVUb090aGVycyh1bmNvcnJlY3RlZEF2b2lkRWxlbWVudHMsIGJvZHksIGFyaWFIaWRkZW4sIGluZXJ0KSB7XG4gIGNvbnN0IG1hcmtlck5hbWUgPSAnZGF0YS1mbG9hdGluZy11aS1pbmVydCc7XG4gIGNvbnN0IGNvbnRyb2xBdHRyaWJ1dGUgPSBpbmVydCA/ICdpbmVydCcgOiBhcmlhSGlkZGVuID8gJ2FyaWEtaGlkZGVuJyA6IG51bGw7XG4gIGNvbnN0IGF2b2lkRWxlbWVudHMgPSBjb3JyZWN0RWxlbWVudHMoYm9keSwgdW5jb3JyZWN0ZWRBdm9pZEVsZW1lbnRzKTtcbiAgY29uc3QgZWxlbWVudHNUb0tlZXAgPSBuZXcgU2V0KCk7XG4gIGNvbnN0IGVsZW1lbnRzVG9TdG9wID0gbmV3IFNldChhdm9pZEVsZW1lbnRzKTtcbiAgY29uc3QgaGlkZGVuRWxlbWVudHMgPSBbXTtcbiAgaWYgKCFtYXJrZXJNYXBbbWFya2VyTmFtZV0pIHtcbiAgICBtYXJrZXJNYXBbbWFya2VyTmFtZV0gPSBuZXcgV2Vha01hcCgpO1xuICB9XG4gIGNvbnN0IG1hcmtlckNvdW50ZXIgPSBtYXJrZXJNYXBbbWFya2VyTmFtZV07XG4gIGF2b2lkRWxlbWVudHMuZm9yRWFjaChrZWVwKTtcbiAgZGVlcChib2R5KTtcbiAgZWxlbWVudHNUb0tlZXAuY2xlYXIoKTtcbiAgZnVuY3Rpb24ga2VlcChlbCkge1xuICAgIGlmICghZWwgfHwgZWxlbWVudHNUb0tlZXAuaGFzKGVsKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBlbGVtZW50c1RvS2VlcC5hZGQoZWwpO1xuICAgIGVsLnBhcmVudE5vZGUgJiYga2VlcChlbC5wYXJlbnROb2RlKTtcbiAgfVxuICBmdW5jdGlvbiBkZWVwKHBhcmVudCkge1xuICAgIGlmICghcGFyZW50IHx8IGVsZW1lbnRzVG9TdG9wLmhhcyhwYXJlbnQpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIEFycmF5LnByb3RvdHlwZS5mb3JFYWNoLmNhbGwocGFyZW50LmNoaWxkcmVuLCBub2RlID0+IHtcbiAgICAgIGlmIChlbGVtZW50c1RvS2VlcC5oYXMobm9kZSkpIHtcbiAgICAgICAgZGVlcChub2RlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IGF0dHIgPSBjb250cm9sQXR0cmlidXRlID8gbm9kZS5nZXRBdHRyaWJ1dGUoY29udHJvbEF0dHJpYnV0ZSkgOiBudWxsO1xuICAgICAgICBjb25zdCBhbHJlYWR5SGlkZGVuID0gYXR0ciAhPT0gbnVsbCAmJiBhdHRyICE9PSAnZmFsc2UnO1xuICAgICAgICBjb25zdCBjb3VudGVyVmFsdWUgPSAoY291bnRlck1hcC5nZXQobm9kZSkgfHwgMCkgKyAxO1xuICAgICAgICBjb25zdCBtYXJrZXJWYWx1ZSA9IChtYXJrZXJDb3VudGVyLmdldChub2RlKSB8fCAwKSArIDE7XG4gICAgICAgIGNvdW50ZXJNYXAuc2V0KG5vZGUsIGNvdW50ZXJWYWx1ZSk7XG4gICAgICAgIG1hcmtlckNvdW50ZXIuc2V0KG5vZGUsIG1hcmtlclZhbHVlKTtcbiAgICAgICAgaGlkZGVuRWxlbWVudHMucHVzaChub2RlKTtcbiAgICAgICAgaWYgKGNvdW50ZXJWYWx1ZSA9PT0gMSAmJiBhbHJlYWR5SGlkZGVuKSB7XG4gICAgICAgICAgdW5jb250cm9sbGVkRWxlbWVudHNTZXQuYWRkKG5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtYXJrZXJWYWx1ZSA9PT0gMSkge1xuICAgICAgICAgIG5vZGUuc2V0QXR0cmlidXRlKG1hcmtlck5hbWUsICcnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWFscmVhZHlIaWRkZW4gJiYgY29udHJvbEF0dHJpYnV0ZSkge1xuICAgICAgICAgIG5vZGUuc2V0QXR0cmlidXRlKGNvbnRyb2xBdHRyaWJ1dGUsICd0cnVlJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBsb2NrQ291bnQrKztcbiAgcmV0dXJuICgpID0+IHtcbiAgICBoaWRkZW5FbGVtZW50cy5mb3JFYWNoKGVsZW1lbnQgPT4ge1xuICAgICAgY29uc3QgY291bnRlclZhbHVlID0gKGNvdW50ZXJNYXAuZ2V0KGVsZW1lbnQpIHx8IDApIC0gMTtcbiAgICAgIGNvbnN0IG1hcmtlclZhbHVlID0gKG1hcmtlckNvdW50ZXIuZ2V0KGVsZW1lbnQpIHx8IDApIC0gMTtcbiAgICAgIGNvdW50ZXJNYXAuc2V0KGVsZW1lbnQsIGNvdW50ZXJWYWx1ZSk7XG4gICAgICBtYXJrZXJDb3VudGVyLnNldChlbGVtZW50LCBtYXJrZXJWYWx1ZSk7XG4gICAgICBpZiAoIWNvdW50ZXJWYWx1ZSkge1xuICAgICAgICBpZiAoIXVuY29udHJvbGxlZEVsZW1lbnRzU2V0LmhhcyhlbGVtZW50KSAmJiBjb250cm9sQXR0cmlidXRlKSB7XG4gICAgICAgICAgZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoY29udHJvbEF0dHJpYnV0ZSk7XG4gICAgICAgIH1cbiAgICAgICAgdW5jb250cm9sbGVkRWxlbWVudHNTZXQuZGVsZXRlKGVsZW1lbnQpO1xuICAgICAgfVxuICAgICAgaWYgKCFtYXJrZXJWYWx1ZSkge1xuICAgICAgICBlbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShtYXJrZXJOYW1lKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBsb2NrQ291bnQtLTtcbiAgICBpZiAoIWxvY2tDb3VudCkge1xuICAgICAgY291bnRlck1hcCA9IG5ldyBXZWFrTWFwKCk7XG4gICAgICBjb3VudGVyTWFwID0gbmV3IFdlYWtNYXAoKTtcbiAgICAgIHVuY29udHJvbGxlZEVsZW1lbnRzU2V0ID0gbmV3IFdlYWtTZXQoKTtcbiAgICAgIG1hcmtlck1hcCA9IHt9O1xuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIG1hcmtPdGhlcnMoYXZvaWRFbGVtZW50cywgYXJpYUhpZGRlbiwgaW5lcnQpIHtcbiAgaWYgKGFyaWFIaWRkZW4gPT09IHZvaWQgMCkge1xuICAgIGFyaWFIaWRkZW4gPSBmYWxzZTtcbiAgfVxuICBpZiAoaW5lcnQgPT09IHZvaWQgMCkge1xuICAgIGluZXJ0ID0gZmFsc2U7XG4gIH1cbiAgY29uc3QgYm9keSA9IGdldERvY3VtZW50KGF2b2lkRWxlbWVudHNbMF0pLmJvZHk7XG4gIHJldHVybiBhcHBseUF0dHJpYnV0ZVRvT3RoZXJzKGF2b2lkRWxlbWVudHMuY29uY2F0KEFycmF5LmZyb20oYm9keS5xdWVyeVNlbGVjdG9yQWxsKCdbYXJpYS1saXZlXScpKSksIGJvZHksIGFyaWFIaWRkZW4sIGluZXJ0KTtcbn1cblxuY29uc3QgZ2V0VGFiYmFibGVPcHRpb25zID0gKCkgPT4gKHtcbiAgZ2V0U2hhZG93Um9vdDogdHJ1ZSxcbiAgZGlzcGxheUNoZWNrOlxuICAvLyBKU0RPTSBkb2VzIG5vdCBzdXBwb3J0IHRoZSBgdGFiYmFibGVgIGxpYnJhcnkuIFRvIHNvbHZlIHRoaXMgd2UgY2FuXG4gIC8vIGNoZWNrIGlmIGBSZXNpemVPYnNlcnZlcmAgaXMgYSByZWFsIGZ1bmN0aW9uIChub3QgcG9seWZpbGxlZCksIHdoaWNoXG4gIC8vIGRldGVybWluZXMgaWYgdGhlIGN1cnJlbnQgZW52aXJvbm1lbnQgaXMgSlNET00tbGlrZS5cbiAgdHlwZW9mIFJlc2l6ZU9ic2VydmVyID09PSAnZnVuY3Rpb24nICYmIFJlc2l6ZU9ic2VydmVyLnRvU3RyaW5nKCkuaW5jbHVkZXMoJ1tuYXRpdmUgY29kZV0nKSA/ICdmdWxsJyA6ICdub25lJ1xufSk7XG5mdW5jdGlvbiBnZXRUYWJiYWJsZUluKGNvbnRhaW5lciwgZGlyZWN0aW9uKSB7XG4gIGNvbnN0IGFsbFRhYmJhYmxlID0gdGFiYmFibGUoY29udGFpbmVyLCBnZXRUYWJiYWJsZU9wdGlvbnMoKSk7XG4gIGlmIChkaXJlY3Rpb24gPT09ICdwcmV2Jykge1xuICAgIGFsbFRhYmJhYmxlLnJldmVyc2UoKTtcbiAgfVxuICBjb25zdCBhY3RpdmVJbmRleCA9IGFsbFRhYmJhYmxlLmluZGV4T2YoYWN0aXZlRWxlbWVudChnZXREb2N1bWVudChjb250YWluZXIpKSk7XG4gIGNvbnN0IG5leHRUYWJiYWJsZUVsZW1lbnRzID0gYWxsVGFiYmFibGUuc2xpY2UoYWN0aXZlSW5kZXggKyAxKTtcbiAgcmV0dXJuIG5leHRUYWJiYWJsZUVsZW1lbnRzWzBdO1xufVxuZnVuY3Rpb24gZ2V0TmV4dFRhYmJhYmxlKCkge1xuICByZXR1cm4gZ2V0VGFiYmFibGVJbihkb2N1bWVudC5ib2R5LCAnbmV4dCcpO1xufVxuZnVuY3Rpb24gZ2V0UHJldmlvdXNUYWJiYWJsZSgpIHtcbiAgcmV0dXJuIGdldFRhYmJhYmxlSW4oZG9jdW1lbnQuYm9keSwgJ3ByZXYnKTtcbn1cbmZ1bmN0aW9uIGlzT3V0c2lkZUV2ZW50KGV2ZW50LCBjb250YWluZXIpIHtcbiAgY29uc3QgY29udGFpbmVyRWxlbWVudCA9IGNvbnRhaW5lciB8fCBldmVudC5jdXJyZW50VGFyZ2V0O1xuICBjb25zdCByZWxhdGVkVGFyZ2V0ID0gZXZlbnQucmVsYXRlZFRhcmdldDtcbiAgcmV0dXJuICFyZWxhdGVkVGFyZ2V0IHx8ICFjb250YWlucyhjb250YWluZXJFbGVtZW50LCByZWxhdGVkVGFyZ2V0KTtcbn1cbmZ1bmN0aW9uIGRpc2FibGVGb2N1c0luc2lkZShjb250YWluZXIpIHtcbiAgY29uc3QgdGFiYmFibGVFbGVtZW50cyA9IHRhYmJhYmxlKGNvbnRhaW5lciwgZ2V0VGFiYmFibGVPcHRpb25zKCkpO1xuICB0YWJiYWJsZUVsZW1lbnRzLmZvckVhY2goZWxlbWVudCA9PiB7XG4gICAgZWxlbWVudC5kYXRhc2V0LnRhYmluZGV4ID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ3RhYmluZGV4JykgfHwgJyc7XG4gICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3RhYmluZGV4JywgJy0xJyk7XG4gIH0pO1xufVxuZnVuY3Rpb24gZW5hYmxlRm9jdXNJbnNpZGUoY29udGFpbmVyKSB7XG4gIGNvbnN0IGVsZW1lbnRzID0gY29udGFpbmVyLnF1ZXJ5U2VsZWN0b3JBbGwoJ1tkYXRhLXRhYmluZGV4XScpO1xuICBlbGVtZW50cy5mb3JFYWNoKGVsZW1lbnQgPT4ge1xuICAgIGNvbnN0IHRhYmluZGV4ID0gZWxlbWVudC5kYXRhc2V0LnRhYmluZGV4O1xuICAgIC8vIGJpb21lLWlnbm9yZSBsaW50L3BlcmZvcm1hbmNlL25vRGVsZXRlOiBwdXJpdHlcbiAgICBkZWxldGUgZWxlbWVudC5kYXRhc2V0LnRhYmluZGV4O1xuICAgIGlmICh0YWJpbmRleCkge1xuICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3RhYmluZGV4JywgdGFiaW5kZXgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbGVtZW50LnJlbW92ZUF0dHJpYnV0ZSgndGFiaW5kZXgnKTtcbiAgICB9XG4gIH0pO1xufVxuXG4vLyBTZWUgRGllZ28gSGF6J3MgU2FuZGJveCBmb3IgbWFraW5nIHRoaXMgbG9naWMgd29yayB3ZWxsIG9uIFNhZmFyaS9pT1M6XG4vLyBodHRwczovL2NvZGVzYW5kYm94LmlvL3MvdGFiYmFibGUtcG9ydGFsLWY0dG5nP2ZpbGU9L3NyYy9Gb2N1c1RyYXAudHN4XG5cbmNvbnN0IEhJRERFTl9TVFlMRVMgPSB7XG4gIGJvcmRlcjogMCxcbiAgY2xpcDogJ3JlY3QoMCAwIDAgMCknLFxuICBoZWlnaHQ6ICcxcHgnLFxuICBtYXJnaW46ICctMXB4JyxcbiAgb3ZlcmZsb3c6ICdoaWRkZW4nLFxuICBwYWRkaW5nOiAwLFxuICBwb3NpdGlvbjogJ2ZpeGVkJyxcbiAgd2hpdGVTcGFjZTogJ25vd3JhcCcsXG4gIHdpZHRoOiAnMXB4JyxcbiAgdG9wOiAwLFxuICBsZWZ0OiAwXG59O1xubGV0IHRpbWVvdXRJZDtcbmZ1bmN0aW9uIHNldEFjdGl2ZUVsZW1lbnRPblRhYihldmVudCkge1xuICBpZiAoZXZlbnQua2V5ID09PSAnVGFiJykge1xuICAgIGV2ZW50LnRhcmdldDtcbiAgICBjbGVhclRpbWVvdXQodGltZW91dElkKTtcbiAgfVxufVxuY29uc3QgRm9jdXNHdWFyZCA9IC8qI19fUFVSRV9fKi9SZWFjdC5mb3J3YXJkUmVmKGZ1bmN0aW9uIEZvY3VzR3VhcmQocHJvcHMsIHJlZikge1xuICBjb25zdCBbcm9sZSwgc2V0Um9sZV0gPSBSZWFjdC51c2VTdGF0ZSgpO1xuICBpbmRleCgoKSA9PiB7XG4gICAgaWYgKGlzU2FmYXJpKCkpIHtcbiAgICAgIC8vIFVubGlrZSBvdGhlciBzY3JlZW4gcmVhZGVycyBzdWNoIGFzIE5WREEgYW5kIEpBV1MsIHRoZSB2aXJ0dWFsIGN1cnNvclxuICAgICAgLy8gb24gVm9pY2VPdmVyIGRvZXMgdHJpZ2dlciB0aGUgb25Gb2N1cyBldmVudCwgc28gd2UgY2FuIHVzZSB0aGUgZm9jdXNcbiAgICAgIC8vIHRyYXAgZWxlbWVudC4gT24gU2FmYXJpLCBvbmx5IGJ1dHRvbnMgdHJpZ2dlciB0aGUgb25Gb2N1cyBldmVudC5cbiAgICAgIC8vIE5COiBcImdyb3VwXCIgcm9sZSBpbiB0aGUgU2FuZGJveCBubyBsb25nZXIgYXBwZWFycyB0byB3b3JrLCBtdXN0IGJlIGFcbiAgICAgIC8vIGJ1dHRvbiByb2xlLlxuICAgICAgc2V0Um9sZSgnYnV0dG9uJyk7XG4gICAgfVxuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCBzZXRBY3RpdmVFbGVtZW50T25UYWIpO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdrZXlkb3duJywgc2V0QWN0aXZlRWxlbWVudE9uVGFiKTtcbiAgICB9O1xuICB9LCBbXSk7XG4gIGNvbnN0IHJlc3RQcm9wcyA9IHtcbiAgICByZWYsXG4gICAgdGFiSW5kZXg6IDAsXG4gICAgLy8gUm9sZSBpcyBvbmx5IGZvciBWb2ljZU92ZXJcbiAgICByb2xlLFxuICAgICdhcmlhLWhpZGRlbic6IHJvbGUgPyB1bmRlZmluZWQgOiB0cnVlLFxuICAgIFtjcmVhdGVBdHRyaWJ1dGUoJ2ZvY3VzLWd1YXJkJyldOiAnJyxcbiAgICBzdHlsZTogSElEREVOX1NUWUxFU1xuICB9O1xuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIF9leHRlbmRzKHt9LCBwcm9wcywgcmVzdFByb3BzKSk7XG59KTtcblxuY29uc3QgUG9ydGFsQ29udGV4dCA9IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVDb250ZXh0KG51bGwpO1xuY29uc3QgYXR0ciA9IC8qI19fUFVSRV9fKi9jcmVhdGVBdHRyaWJ1dGUoJ3BvcnRhbCcpO1xuXG4vKipcbiAqIEBzZWUgaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy9GbG9hdGluZ1BvcnRhbCN1c2VmbG9hdGluZ3BvcnRhbG5vZGVcbiAqL1xuZnVuY3Rpb24gdXNlRmxvYXRpbmdQb3J0YWxOb2RlKF90ZW1wKSB7XG4gIGxldCB7XG4gICAgaWQsXG4gICAgcm9vdFxuICB9ID0gX3RlbXAgPT09IHZvaWQgMCA/IHt9IDogX3RlbXA7XG4gIGNvbnN0IFtwb3J0YWxOb2RlLCBzZXRQb3J0YWxOb2RlXSA9IFJlYWN0LnVzZVN0YXRlKG51bGwpO1xuICBjb25zdCB1bmlxdWVJZCA9IHVzZUlkKCk7XG4gIGNvbnN0IHBvcnRhbENvbnRleHQgPSB1c2VQb3J0YWxDb250ZXh0KCk7XG4gIGNvbnN0IHBvcnRhbE5vZGVSZWYgPSBSZWFjdC51c2VSZWYobnVsbCk7XG4gIGluZGV4KCgpID0+IHtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgcG9ydGFsTm9kZSA9PSBudWxsIHx8IHBvcnRhbE5vZGUucmVtb3ZlKCk7XG4gICAgICAvLyBBbGxvdyB0aGUgc3Vic2VxdWVudCBsYXlvdXQgZWZmZWN0cyB0byBjcmVhdGUgYSBuZXcgbm9kZSBvbiB1cGRhdGVzLlxuICAgICAgLy8gVGhlIHBvcnRhbCBub2RlIHdpbGwgc3RpbGwgYmUgY2xlYW5lZCB1cCBvbiB1bm1vdW50LlxuICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2Zsb2F0aW5nLXVpL2Zsb2F0aW5nLXVpL2lzc3Vlcy8yNDU0XG4gICAgICBxdWV1ZU1pY3JvdGFzaygoKSA9PiB7XG4gICAgICAgIHBvcnRhbE5vZGVSZWYuY3VycmVudCA9IG51bGw7XG4gICAgICB9KTtcbiAgICB9O1xuICB9LCBbcG9ydGFsTm9kZV0pO1xuICBpbmRleCgoKSA9PiB7XG4gICAgaWYgKHBvcnRhbE5vZGVSZWYuY3VycmVudCkgcmV0dXJuO1xuICAgIGNvbnN0IGV4aXN0aW5nSWRSb290ID0gaWQgPyBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChpZCkgOiBudWxsO1xuICAgIGlmICghZXhpc3RpbmdJZFJvb3QpIHJldHVybjtcbiAgICBjb25zdCBzdWJSb290ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgc3ViUm9vdC5pZCA9IHVuaXF1ZUlkO1xuICAgIHN1YlJvb3Quc2V0QXR0cmlidXRlKGF0dHIsICcnKTtcbiAgICBleGlzdGluZ0lkUm9vdC5hcHBlbmRDaGlsZChzdWJSb290KTtcbiAgICBwb3J0YWxOb2RlUmVmLmN1cnJlbnQgPSBzdWJSb290O1xuICAgIHNldFBvcnRhbE5vZGUoc3ViUm9vdCk7XG4gIH0sIFtpZCwgdW5pcXVlSWRdKTtcbiAgaW5kZXgoKCkgPT4ge1xuICAgIGlmIChwb3J0YWxOb2RlUmVmLmN1cnJlbnQpIHJldHVybjtcbiAgICBsZXQgY29udGFpbmVyID0gcm9vdCB8fCAocG9ydGFsQ29udGV4dCA9PSBudWxsID8gdm9pZCAwIDogcG9ydGFsQ29udGV4dC5wb3J0YWxOb2RlKTtcbiAgICBpZiAoY29udGFpbmVyICYmICFpc0VsZW1lbnQoY29udGFpbmVyKSkgY29udGFpbmVyID0gY29udGFpbmVyLmN1cnJlbnQ7XG4gICAgY29udGFpbmVyID0gY29udGFpbmVyIHx8IGRvY3VtZW50LmJvZHk7XG4gICAgbGV0IGlkV3JhcHBlciA9IG51bGw7XG4gICAgaWYgKGlkKSB7XG4gICAgICBpZFdyYXBwZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgIGlkV3JhcHBlci5pZCA9IGlkO1xuICAgICAgY29udGFpbmVyLmFwcGVuZENoaWxkKGlkV3JhcHBlcik7XG4gICAgfVxuICAgIGNvbnN0IHN1YlJvb3QgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBzdWJSb290LmlkID0gdW5pcXVlSWQ7XG4gICAgc3ViUm9vdC5zZXRBdHRyaWJ1dGUoYXR0ciwgJycpO1xuICAgIGNvbnRhaW5lciA9IGlkV3JhcHBlciB8fCBjb250YWluZXI7XG4gICAgY29udGFpbmVyLmFwcGVuZENoaWxkKHN1YlJvb3QpO1xuICAgIHBvcnRhbE5vZGVSZWYuY3VycmVudCA9IHN1YlJvb3Q7XG4gICAgc2V0UG9ydGFsTm9kZShzdWJSb290KTtcbiAgfSwgW2lkLCByb290LCB1bmlxdWVJZCwgcG9ydGFsQ29udGV4dF0pO1xuICByZXR1cm4gcG9ydGFsTm9kZTtcbn1cbi8qKlxuICogUG9ydGFscyB0aGUgZmxvYXRpbmcgZWxlbWVudCBpbnRvIGEgZ2l2ZW4gY29udGFpbmVyIGVsZW1lbnQg4oCUIGJ5IGRlZmF1bHQsXG4gKiBvdXRzaWRlIG9mIHRoZSBhcHAgcm9vdCBhbmQgaW50byB0aGUgYm9keS5cbiAqIFRoaXMgaXMgbmVjZXNzYXJ5IHRvIGVuc3VyZSB0aGUgZmxvYXRpbmcgZWxlbWVudCBjYW4gYXBwZWFyIG91dHNpZGUgYW55XG4gKiBwb3RlbnRpYWwgcGFyZW50IGNvbnRhaW5lcnMgdGhhdCBjYXVzZSBjbGlwcGluZyAoc3VjaCBhcyBgb3ZlcmZsb3c6IGhpZGRlbmApLFxuICogd2hpbGUgcmV0YWluaW5nIGl0cyBsb2NhdGlvbiBpbiB0aGUgUmVhY3QgdHJlZS5cbiAqIEBzZWUgaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy9GbG9hdGluZ1BvcnRhbFxuICovXG5mdW5jdGlvbiBGbG9hdGluZ1BvcnRhbChfcmVmKSB7XG4gIGxldCB7XG4gICAgY2hpbGRyZW4sXG4gICAgaWQsXG4gICAgcm9vdCA9IG51bGwsXG4gICAgcHJlc2VydmVUYWJPcmRlciA9IHRydWVcbiAgfSA9IF9yZWY7XG4gIGNvbnN0IHBvcnRhbE5vZGUgPSB1c2VGbG9hdGluZ1BvcnRhbE5vZGUoe1xuICAgIGlkLFxuICAgIHJvb3RcbiAgfSk7XG4gIGNvbnN0IFtmb2N1c01hbmFnZXJTdGF0ZSwgc2V0Rm9jdXNNYW5hZ2VyU3RhdGVdID0gUmVhY3QudXNlU3RhdGUobnVsbCk7XG4gIGNvbnN0IGJlZm9yZU91dHNpZGVSZWYgPSBSZWFjdC51c2VSZWYobnVsbCk7XG4gIGNvbnN0IGFmdGVyT3V0c2lkZVJlZiA9IFJlYWN0LnVzZVJlZihudWxsKTtcbiAgY29uc3QgYmVmb3JlSW5zaWRlUmVmID0gUmVhY3QudXNlUmVmKG51bGwpO1xuICBjb25zdCBhZnRlckluc2lkZVJlZiA9IFJlYWN0LnVzZVJlZihudWxsKTtcbiAgY29uc3Qgc2hvdWxkUmVuZGVyR3VhcmRzID1cbiAgLy8gVGhlIEZvY3VzTWFuYWdlciBhbmQgdGhlcmVmb3JlIGZsb2F0aW5nIGVsZW1lbnQgYXJlIGN1cnJlbnRseSBvcGVuL1xuICAvLyByZW5kZXJlZC5cbiAgISFmb2N1c01hbmFnZXJTdGF0ZSAmJlxuICAvLyBHdWFyZHMgYXJlIG9ubHkgZm9yIG5vbi1tb2RhbCBmb2N1cyBtYW5hZ2VtZW50LlxuICAhZm9jdXNNYW5hZ2VyU3RhdGUubW9kYWwgJiZcbiAgLy8gRG9uJ3QgcmVuZGVyIGlmIHVubW91bnQgaXMgdHJhbnNpdGlvbmluZy5cbiAgZm9jdXNNYW5hZ2VyU3RhdGUub3BlbiAmJiBwcmVzZXJ2ZVRhYk9yZGVyICYmICEhKHJvb3QgfHwgcG9ydGFsTm9kZSk7XG5cbiAgLy8gaHR0cHM6Ly9jb2Rlc2FuZGJveC5pby9zL3RhYmJhYmxlLXBvcnRhbC1mNHRuZz9maWxlPS9zcmMvVGFiYmFibGVQb3J0YWwudHN4XG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKCFwb3J0YWxOb2RlIHx8ICFwcmVzZXJ2ZVRhYk9yZGVyIHx8IGZvY3VzTWFuYWdlclN0YXRlICE9IG51bGwgJiYgZm9jdXNNYW5hZ2VyU3RhdGUubW9kYWwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBNYWtlIHN1cmUgZWxlbWVudHMgaW5zaWRlIHRoZSBwb3J0YWwgZWxlbWVudCBhcmUgdGFiYmFibGUgb25seSB3aGVuIHRoZVxuICAgIC8vIHBvcnRhbCBoYXMgYWxyZWFkeSBiZWVuIGZvY3VzZWQsIGVpdGhlciBieSB0YWJiaW5nIGludG8gYSBmb2N1cyB0cmFwXG4gICAgLy8gZWxlbWVudCBvdXRzaWRlIG9yIHVzaW5nIHRoZSBtb3VzZS5cbiAgICBmdW5jdGlvbiBvbkZvY3VzKGV2ZW50KSB7XG4gICAgICBpZiAocG9ydGFsTm9kZSAmJiBpc091dHNpZGVFdmVudChldmVudCkpIHtcbiAgICAgICAgY29uc3QgZm9jdXNpbmcgPSBldmVudC50eXBlID09PSAnZm9jdXNpbic7XG4gICAgICAgIGNvbnN0IG1hbmFnZUZvY3VzID0gZm9jdXNpbmcgPyBlbmFibGVGb2N1c0luc2lkZSA6IGRpc2FibGVGb2N1c0luc2lkZTtcbiAgICAgICAgbWFuYWdlRm9jdXMocG9ydGFsTm9kZSk7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIExpc3RlbiB0byB0aGUgZXZlbnQgb24gdGhlIGNhcHR1cmUgcGhhc2Ugc28gdGhleSBydW4gYmVmb3JlIHRoZSBmb2N1c1xuICAgIC8vIHRyYXAgZWxlbWVudHMgb25Gb2N1cyBwcm9wIGlzIGNhbGxlZC5cbiAgICBwb3J0YWxOb2RlLmFkZEV2ZW50TGlzdGVuZXIoJ2ZvY3VzaW4nLCBvbkZvY3VzLCB0cnVlKTtcbiAgICBwb3J0YWxOb2RlLmFkZEV2ZW50TGlzdGVuZXIoJ2ZvY3Vzb3V0Jywgb25Gb2N1cywgdHJ1ZSk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHBvcnRhbE5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcignZm9jdXNpbicsIG9uRm9jdXMsIHRydWUpO1xuICAgICAgcG9ydGFsTm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKCdmb2N1c291dCcsIG9uRm9jdXMsIHRydWUpO1xuICAgIH07XG4gIH0sIFtwb3J0YWxOb2RlLCBwcmVzZXJ2ZVRhYk9yZGVyLCBmb2N1c01hbmFnZXJTdGF0ZSA9PSBudWxsID8gdm9pZCAwIDogZm9jdXNNYW5hZ2VyU3RhdGUubW9kYWxdKTtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFBvcnRhbENvbnRleHQuUHJvdmlkZXIsIHtcbiAgICB2YWx1ZTogUmVhY3QudXNlTWVtbygoKSA9PiAoe1xuICAgICAgcHJlc2VydmVUYWJPcmRlcixcbiAgICAgIGJlZm9yZU91dHNpZGVSZWYsXG4gICAgICBhZnRlck91dHNpZGVSZWYsXG4gICAgICBiZWZvcmVJbnNpZGVSZWYsXG4gICAgICBhZnRlckluc2lkZVJlZixcbiAgICAgIHBvcnRhbE5vZGUsXG4gICAgICBzZXRGb2N1c01hbmFnZXJTdGF0ZVxuICAgIH0pLCBbcHJlc2VydmVUYWJPcmRlciwgcG9ydGFsTm9kZV0pXG4gIH0sIHNob3VsZFJlbmRlckd1YXJkcyAmJiBwb3J0YWxOb2RlICYmIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KEZvY3VzR3VhcmQsIHtcbiAgICBcImRhdGEtdHlwZVwiOiBcIm91dHNpZGVcIixcbiAgICByZWY6IGJlZm9yZU91dHNpZGVSZWYsXG4gICAgb25Gb2N1czogZXZlbnQgPT4ge1xuICAgICAgaWYgKGlzT3V0c2lkZUV2ZW50KGV2ZW50LCBwb3J0YWxOb2RlKSkge1xuICAgICAgICB2YXIgX2JlZm9yZUluc2lkZVJlZiRjdXJyO1xuICAgICAgICAoX2JlZm9yZUluc2lkZVJlZiRjdXJyID0gYmVmb3JlSW5zaWRlUmVmLmN1cnJlbnQpID09IG51bGwgfHwgX2JlZm9yZUluc2lkZVJlZiRjdXJyLmZvY3VzKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBwcmV2VGFiYmFibGUgPSBnZXRQcmV2aW91c1RhYmJhYmxlKCkgfHwgKGZvY3VzTWFuYWdlclN0YXRlID09IG51bGwgPyB2b2lkIDAgOiBmb2N1c01hbmFnZXJTdGF0ZS5yZWZzLmRvbVJlZmVyZW5jZS5jdXJyZW50KTtcbiAgICAgICAgcHJldlRhYmJhYmxlID09IG51bGwgfHwgcHJldlRhYmJhYmxlLmZvY3VzKCk7XG4gICAgICB9XG4gICAgfVxuICB9KSwgc2hvdWxkUmVuZGVyR3VhcmRzICYmIHBvcnRhbE5vZGUgJiYgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIHtcbiAgICBcImFyaWEtb3duc1wiOiBwb3J0YWxOb2RlLmlkLFxuICAgIHN0eWxlOiBISURERU5fU1RZTEVTXG4gIH0pLCBwb3J0YWxOb2RlICYmIC8qI19fUFVSRV9fKi9jcmVhdGVQb3J0YWwoY2hpbGRyZW4sIHBvcnRhbE5vZGUpLCBzaG91bGRSZW5kZXJHdWFyZHMgJiYgcG9ydGFsTm9kZSAmJiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChGb2N1c0d1YXJkLCB7XG4gICAgXCJkYXRhLXR5cGVcIjogXCJvdXRzaWRlXCIsXG4gICAgcmVmOiBhZnRlck91dHNpZGVSZWYsXG4gICAgb25Gb2N1czogZXZlbnQgPT4ge1xuICAgICAgaWYgKGlzT3V0c2lkZUV2ZW50KGV2ZW50LCBwb3J0YWxOb2RlKSkge1xuICAgICAgICB2YXIgX2FmdGVySW5zaWRlUmVmJGN1cnJlO1xuICAgICAgICAoX2FmdGVySW5zaWRlUmVmJGN1cnJlID0gYWZ0ZXJJbnNpZGVSZWYuY3VycmVudCkgPT0gbnVsbCB8fCBfYWZ0ZXJJbnNpZGVSZWYkY3VycmUuZm9jdXMoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IG5leHRUYWJiYWJsZSA9IGdldE5leHRUYWJiYWJsZSgpIHx8IChmb2N1c01hbmFnZXJTdGF0ZSA9PSBudWxsID8gdm9pZCAwIDogZm9jdXNNYW5hZ2VyU3RhdGUucmVmcy5kb21SZWZlcmVuY2UuY3VycmVudCk7XG4gICAgICAgIG5leHRUYWJiYWJsZSA9PSBudWxsIHx8IG5leHRUYWJiYWJsZS5mb2N1cygpO1xuICAgICAgICAoZm9jdXNNYW5hZ2VyU3RhdGUgPT0gbnVsbCA/IHZvaWQgMCA6IGZvY3VzTWFuYWdlclN0YXRlLmNsb3NlT25Gb2N1c091dCkgJiYgKGZvY3VzTWFuYWdlclN0YXRlID09IG51bGwgPyB2b2lkIDAgOiBmb2N1c01hbmFnZXJTdGF0ZS5vbk9wZW5DaGFuZ2UoZmFsc2UsIGV2ZW50Lm5hdGl2ZUV2ZW50KSk7XG4gICAgICB9XG4gICAgfVxuICB9KSk7XG59XG5jb25zdCB1c2VQb3J0YWxDb250ZXh0ID0gKCkgPT4gUmVhY3QudXNlQ29udGV4dChQb3J0YWxDb250ZXh0KTtcblxuY29uc3QgTElTVF9MSU1JVCA9IDIwO1xubGV0IHByZXZpb3VzbHlGb2N1c2VkRWxlbWVudHMgPSBbXTtcbmZ1bmN0aW9uIGFkZFByZXZpb3VzbHlGb2N1c2VkRWxlbWVudChlbGVtZW50KSB7XG4gIHByZXZpb3VzbHlGb2N1c2VkRWxlbWVudHMgPSBwcmV2aW91c2x5Rm9jdXNlZEVsZW1lbnRzLmZpbHRlcihlbCA9PiBlbC5pc0Nvbm5lY3RlZCk7XG4gIGlmIChlbGVtZW50ICYmIGdldE5vZGVOYW1lKGVsZW1lbnQpICE9PSAnYm9keScpIHtcbiAgICBwcmV2aW91c2x5Rm9jdXNlZEVsZW1lbnRzLnB1c2goZWxlbWVudCk7XG4gICAgaWYgKHByZXZpb3VzbHlGb2N1c2VkRWxlbWVudHMubGVuZ3RoID4gTElTVF9MSU1JVCkge1xuICAgICAgcHJldmlvdXNseUZvY3VzZWRFbGVtZW50cyA9IHByZXZpb3VzbHlGb2N1c2VkRWxlbWVudHMuc2xpY2UoLUxJU1RfTElNSVQpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gZ2V0UHJldmlvdXNseUZvY3VzZWRFbGVtZW50KCkge1xuICByZXR1cm4gcHJldmlvdXNseUZvY3VzZWRFbGVtZW50cy5zbGljZSgpLnJldmVyc2UoKS5maW5kKGVsID0+IGVsLmlzQ29ubmVjdGVkKTtcbn1cbmNvbnN0IFZpc3VhbGx5SGlkZGVuRGlzbWlzcyA9IC8qI19fUFVSRV9fKi9SZWFjdC5mb3J3YXJkUmVmKGZ1bmN0aW9uIFZpc3VhbGx5SGlkZGVuRGlzbWlzcyhwcm9wcywgcmVmKSB7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcImJ1dHRvblwiLCBfZXh0ZW5kcyh7fSwgcHJvcHMsIHtcbiAgICB0eXBlOiBcImJ1dHRvblwiLFxuICAgIHJlZjogcmVmLFxuICAgIHRhYkluZGV4OiAtMSxcbiAgICBzdHlsZTogSElEREVOX1NUWUxFU1xuICB9KSk7XG59KTtcbi8qKlxuICogUHJvdmlkZXMgZm9jdXMgbWFuYWdlbWVudCBmb3IgdGhlIGZsb2F0aW5nIGVsZW1lbnQuXG4gKiBAc2VlIGh0dHBzOi8vZmxvYXRpbmctdWkuY29tL2RvY3MvRmxvYXRpbmdGb2N1c01hbmFnZXJcbiAqL1xuZnVuY3Rpb24gRmxvYXRpbmdGb2N1c01hbmFnZXIocHJvcHMpIHtcbiAgY29uc3Qge1xuICAgIGNvbnRleHQsXG4gICAgY2hpbGRyZW4sXG4gICAgZGlzYWJsZWQgPSBmYWxzZSxcbiAgICBvcmRlciA9IFsnY29udGVudCddLFxuICAgIGd1YXJkczogX2d1YXJkcyA9IHRydWUsXG4gICAgaW5pdGlhbEZvY3VzID0gMCxcbiAgICByZXR1cm5Gb2N1cyA9IHRydWUsXG4gICAgbW9kYWwgPSB0cnVlLFxuICAgIHZpc3VhbGx5SGlkZGVuRGlzbWlzcyA9IGZhbHNlLFxuICAgIGNsb3NlT25Gb2N1c091dCA9IHRydWVcbiAgfSA9IHByb3BzO1xuICBjb25zdCB7XG4gICAgb3BlbixcbiAgICByZWZzLFxuICAgIG5vZGVJZCxcbiAgICBvbk9wZW5DaGFuZ2UsXG4gICAgZXZlbnRzLFxuICAgIGRhdGFSZWYsXG4gICAgZWxlbWVudHM6IHtcbiAgICAgIGRvbVJlZmVyZW5jZSxcbiAgICAgIGZsb2F0aW5nXG4gICAgfVxuICB9ID0gY29udGV4dDtcbiAgY29uc3QgaWdub3JlSW5pdGlhbEZvY3VzID0gdHlwZW9mIGluaXRpYWxGb2N1cyA9PT0gJ251bWJlcicgJiYgaW5pdGlhbEZvY3VzIDwgMDtcbiAgLy8gSWYgdGhlIHJlZmVyZW5jZSBpcyBhIGNvbWJvYm94IGFuZCBpcyB0eXBlYWJsZSAoZS5nLiBpbnB1dC90ZXh0YXJlYSksXG4gIC8vIHRoZXJlIGFyZSBkaWZmZXJlbnQgZm9jdXMgc2VtYW50aWNzLiBUaGUgZ3VhcmRzIHNob3VsZCBub3QgYmUgcmVuZGVyZWQsIGJ1dFxuICAvLyBhcmlhLWhpZGRlbiBzaG91bGQgYmUgYXBwbGllZCB0byBhbGwgbm9kZXMgc3RpbGwuIEZ1cnRoZXIsIHRoZSB2aXN1YWxseVxuICAvLyBoaWRkZW4gZGlzbWlzcyBidXR0b24gc2hvdWxkIG9ubHkgYXBwZWFyIGF0IHRoZSBlbmQgb2YgdGhlIGxpc3QsIG5vdCB0aGVcbiAgLy8gc3RhcnQuXG4gIGNvbnN0IGlzVW50cmFwcGVkVHlwZWFibGVDb21ib2JveCA9IGlzVHlwZWFibGVDb21ib2JveChkb21SZWZlcmVuY2UpICYmIGlnbm9yZUluaXRpYWxGb2N1cztcblxuICAvLyBGb3JjZSB0aGUgZ3VhcmRzIHRvIGJlIHJlbmRlcmVkIGlmIHRoZSBgaW5lcnRgIGF0dHJpYnV0ZSBpcyBub3Qgc3VwcG9ydGVkLlxuICBjb25zdCBndWFyZHMgPSBzdXBwb3J0c0luZXJ0KCkgPyBfZ3VhcmRzIDogdHJ1ZTtcbiAgY29uc3Qgb3JkZXJSZWYgPSB1c2VMYXRlc3RSZWYob3JkZXIpO1xuICBjb25zdCBpbml0aWFsRm9jdXNSZWYgPSB1c2VMYXRlc3RSZWYoaW5pdGlhbEZvY3VzKTtcbiAgY29uc3QgcmV0dXJuRm9jdXNSZWYgPSB1c2VMYXRlc3RSZWYocmV0dXJuRm9jdXMpO1xuICBjb25zdCB0cmVlID0gdXNlRmxvYXRpbmdUcmVlKCk7XG4gIGNvbnN0IHBvcnRhbENvbnRleHQgPSB1c2VQb3J0YWxDb250ZXh0KCk7XG4gIGNvbnN0IHN0YXJ0RGlzbWlzc0J1dHRvblJlZiA9IFJlYWN0LnVzZVJlZihudWxsKTtcbiAgY29uc3QgZW5kRGlzbWlzc0J1dHRvblJlZiA9IFJlYWN0LnVzZVJlZihudWxsKTtcbiAgY29uc3QgcHJldmVudFJldHVybkZvY3VzUmVmID0gUmVhY3QudXNlUmVmKGZhbHNlKTtcbiAgY29uc3QgaXNQb2ludGVyRG93blJlZiA9IFJlYWN0LnVzZVJlZihmYWxzZSk7XG4gIGNvbnN0IGlzSW5zaWRlUG9ydGFsID0gcG9ydGFsQ29udGV4dCAhPSBudWxsO1xuICBjb25zdCBnZXRUYWJiYWJsZUNvbnRlbnQgPSBSZWFjdC51c2VDYWxsYmFjayhmdW5jdGlvbiAoY29udGFpbmVyKSB7XG4gICAgaWYgKGNvbnRhaW5lciA9PT0gdm9pZCAwKSB7XG4gICAgICBjb250YWluZXIgPSBmbG9hdGluZztcbiAgICB9XG4gICAgcmV0dXJuIGNvbnRhaW5lciA/IHRhYmJhYmxlKGNvbnRhaW5lciwgZ2V0VGFiYmFibGVPcHRpb25zKCkpIDogW107XG4gIH0sIFtmbG9hdGluZ10pO1xuICBjb25zdCBnZXRUYWJiYWJsZUVsZW1lbnRzID0gUmVhY3QudXNlQ2FsbGJhY2soY29udGFpbmVyID0+IHtcbiAgICBjb25zdCBjb250ZW50ID0gZ2V0VGFiYmFibGVDb250ZW50KGNvbnRhaW5lcik7XG4gICAgcmV0dXJuIG9yZGVyUmVmLmN1cnJlbnQubWFwKHR5cGUgPT4ge1xuICAgICAgaWYgKGRvbVJlZmVyZW5jZSAmJiB0eXBlID09PSAncmVmZXJlbmNlJykge1xuICAgICAgICByZXR1cm4gZG9tUmVmZXJlbmNlO1xuICAgICAgfVxuICAgICAgaWYgKGZsb2F0aW5nICYmIHR5cGUgPT09ICdmbG9hdGluZycpIHtcbiAgICAgICAgcmV0dXJuIGZsb2F0aW5nO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNvbnRlbnQ7XG4gICAgfSkuZmlsdGVyKEJvb2xlYW4pLmZsYXQoKTtcbiAgfSwgW2RvbVJlZmVyZW5jZSwgZmxvYXRpbmcsIG9yZGVyUmVmLCBnZXRUYWJiYWJsZUNvbnRlbnRdKTtcbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoZGlzYWJsZWQgfHwgIW1vZGFsKSByZXR1cm47XG4gICAgZnVuY3Rpb24gb25LZXlEb3duKGV2ZW50KSB7XG4gICAgICBpZiAoZXZlbnQua2V5ID09PSAnVGFiJykge1xuICAgICAgICAvLyBUaGUgZm9jdXMgZ3VhcmRzIGhhdmUgbm90aGluZyB0byBmb2N1cywgc28gd2UgbmVlZCB0byBzdG9wIHRoZSBldmVudC5cbiAgICAgICAgaWYgKGNvbnRhaW5zKGZsb2F0aW5nLCBhY3RpdmVFbGVtZW50KGdldERvY3VtZW50KGZsb2F0aW5nKSkpICYmIGdldFRhYmJhYmxlQ29udGVudCgpLmxlbmd0aCA9PT0gMCAmJiAhaXNVbnRyYXBwZWRUeXBlYWJsZUNvbWJvYm94KSB7XG4gICAgICAgICAgc3RvcEV2ZW50KGV2ZW50KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBlbHMgPSBnZXRUYWJiYWJsZUVsZW1lbnRzKCk7XG4gICAgICAgIGNvbnN0IHRhcmdldCA9IGdldFRhcmdldChldmVudCk7XG4gICAgICAgIGlmIChvcmRlclJlZi5jdXJyZW50WzBdID09PSAncmVmZXJlbmNlJyAmJiB0YXJnZXQgPT09IGRvbVJlZmVyZW5jZSkge1xuICAgICAgICAgIHN0b3BFdmVudChldmVudCk7XG4gICAgICAgICAgaWYgKGV2ZW50LnNoaWZ0S2V5KSB7XG4gICAgICAgICAgICBlbnF1ZXVlRm9jdXMoZWxzW2Vscy5sZW5ndGggLSAxXSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGVucXVldWVGb2N1cyhlbHNbMV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAob3JkZXJSZWYuY3VycmVudFsxXSA9PT0gJ2Zsb2F0aW5nJyAmJiB0YXJnZXQgPT09IGZsb2F0aW5nICYmIGV2ZW50LnNoaWZ0S2V5KSB7XG4gICAgICAgICAgc3RvcEV2ZW50KGV2ZW50KTtcbiAgICAgICAgICBlbnF1ZXVlRm9jdXMoZWxzWzBdKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBkb2MgPSBnZXREb2N1bWVudChmbG9hdGluZyk7XG4gICAgZG9jLmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCBvbktleURvd24pO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBkb2MucmVtb3ZlRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIG9uS2V5RG93bik7XG4gICAgfTtcbiAgfSwgW2Rpc2FibGVkLCBkb21SZWZlcmVuY2UsIGZsb2F0aW5nLCBtb2RhbCwgb3JkZXJSZWYsIGlzVW50cmFwcGVkVHlwZWFibGVDb21ib2JveCwgZ2V0VGFiYmFibGVDb250ZW50LCBnZXRUYWJiYWJsZUVsZW1lbnRzXSk7XG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKGRpc2FibGVkIHx8ICFjbG9zZU9uRm9jdXNPdXQpIHJldHVybjtcblxuICAgIC8vIEluIFNhZmFyaSwgYnV0dG9ucyBsb3NlIGZvY3VzIHdoZW4gcHJlc3NpbmcgdGhlbS5cbiAgICBmdW5jdGlvbiBoYW5kbGVQb2ludGVyRG93bigpIHtcbiAgICAgIGlzUG9pbnRlckRvd25SZWYuY3VycmVudCA9IHRydWU7XG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgaXNQb2ludGVyRG93blJlZi5jdXJyZW50ID0gZmFsc2U7XG4gICAgICB9KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaGFuZGxlRm9jdXNPdXRzaWRlKGV2ZW50KSB7XG4gICAgICBjb25zdCByZWxhdGVkVGFyZ2V0ID0gZXZlbnQucmVsYXRlZFRhcmdldDtcbiAgICAgIHF1ZXVlTWljcm90YXNrKCgpID0+IHtcbiAgICAgICAgY29uc3QgbW92ZWRUb1VucmVsYXRlZE5vZGUgPSAhKGNvbnRhaW5zKGRvbVJlZmVyZW5jZSwgcmVsYXRlZFRhcmdldCkgfHwgY29udGFpbnMoZmxvYXRpbmcsIHJlbGF0ZWRUYXJnZXQpIHx8IGNvbnRhaW5zKHJlbGF0ZWRUYXJnZXQsIGZsb2F0aW5nKSB8fCBjb250YWlucyhwb3J0YWxDb250ZXh0ID09IG51bGwgPyB2b2lkIDAgOiBwb3J0YWxDb250ZXh0LnBvcnRhbE5vZGUsIHJlbGF0ZWRUYXJnZXQpIHx8IHJlbGF0ZWRUYXJnZXQgIT0gbnVsbCAmJiByZWxhdGVkVGFyZ2V0Lmhhc0F0dHJpYnV0ZShjcmVhdGVBdHRyaWJ1dGUoJ2ZvY3VzLWd1YXJkJykpIHx8IHRyZWUgJiYgKGdldENoaWxkcmVuKHRyZWUubm9kZXNSZWYuY3VycmVudCwgbm9kZUlkKS5maW5kKG5vZGUgPT4ge1xuICAgICAgICAgIHZhciBfbm9kZSRjb250ZXh0LCBfbm9kZSRjb250ZXh0MjtcbiAgICAgICAgICByZXR1cm4gY29udGFpbnMoKF9ub2RlJGNvbnRleHQgPSBub2RlLmNvbnRleHQpID09IG51bGwgPyB2b2lkIDAgOiBfbm9kZSRjb250ZXh0LmVsZW1lbnRzLmZsb2F0aW5nLCByZWxhdGVkVGFyZ2V0KSB8fCBjb250YWlucygoX25vZGUkY29udGV4dDIgPSBub2RlLmNvbnRleHQpID09IG51bGwgPyB2b2lkIDAgOiBfbm9kZSRjb250ZXh0Mi5lbGVtZW50cy5kb21SZWZlcmVuY2UsIHJlbGF0ZWRUYXJnZXQpO1xuICAgICAgICB9KSB8fCBnZXRBbmNlc3RvcnModHJlZS5ub2Rlc1JlZi5jdXJyZW50LCBub2RlSWQpLmZpbmQobm9kZSA9PiB7XG4gICAgICAgICAgdmFyIF9ub2RlJGNvbnRleHQzLCBfbm9kZSRjb250ZXh0NDtcbiAgICAgICAgICByZXR1cm4gKChfbm9kZSRjb250ZXh0MyA9IG5vZGUuY29udGV4dCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9ub2RlJGNvbnRleHQzLmVsZW1lbnRzLmZsb2F0aW5nKSA9PT0gcmVsYXRlZFRhcmdldCB8fCAoKF9ub2RlJGNvbnRleHQ0ID0gbm9kZS5jb250ZXh0KSA9PSBudWxsID8gdm9pZCAwIDogX25vZGUkY29udGV4dDQuZWxlbWVudHMuZG9tUmVmZXJlbmNlKSA9PT0gcmVsYXRlZFRhcmdldDtcbiAgICAgICAgfSkpKTtcblxuICAgICAgICAvLyBGb2N1cyBkaWQgbm90IG1vdmUgaW5zaWRlIHRoZSBmbG9hdGluZyB0cmVlLCBhbmQgdGhlcmUgYXJlIG5vIHRhYmJhYmxlXG4gICAgICAgIC8vIHBvcnRhbCBndWFyZHMgdG8gaGFuZGxlIGNsb3NpbmcuXG4gICAgICAgIGlmIChyZWxhdGVkVGFyZ2V0ICYmIG1vdmVkVG9VbnJlbGF0ZWROb2RlICYmICFpc1BvaW50ZXJEb3duUmVmLmN1cnJlbnQgJiZcbiAgICAgICAgLy8gRml4IFJlYWN0IDE4IFN0cmljdCBNb2RlIHJldHVybkZvY3VzIGR1ZSB0byBkb3VibGUgcmVuZGVyaW5nLlxuICAgICAgICByZWxhdGVkVGFyZ2V0ICE9PSBnZXRQcmV2aW91c2x5Rm9jdXNlZEVsZW1lbnQoKSkge1xuICAgICAgICAgIHByZXZlbnRSZXR1cm5Gb2N1c1JlZi5jdXJyZW50ID0gdHJ1ZTtcbiAgICAgICAgICBvbk9wZW5DaGFuZ2UoZmFsc2UsIGV2ZW50KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChmbG9hdGluZyAmJiBpc0hUTUxFbGVtZW50KGRvbVJlZmVyZW5jZSkpIHtcbiAgICAgIGRvbVJlZmVyZW5jZS5hZGRFdmVudExpc3RlbmVyKCdmb2N1c291dCcsIGhhbmRsZUZvY3VzT3V0c2lkZSk7XG4gICAgICBkb21SZWZlcmVuY2UuYWRkRXZlbnRMaXN0ZW5lcigncG9pbnRlcmRvd24nLCBoYW5kbGVQb2ludGVyRG93bik7XG4gICAgICAhbW9kYWwgJiYgZmxvYXRpbmcuYWRkRXZlbnRMaXN0ZW5lcignZm9jdXNvdXQnLCBoYW5kbGVGb2N1c091dHNpZGUpO1xuICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgZG9tUmVmZXJlbmNlLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2ZvY3Vzb3V0JywgaGFuZGxlRm9jdXNPdXRzaWRlKTtcbiAgICAgICAgZG9tUmVmZXJlbmNlLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3BvaW50ZXJkb3duJywgaGFuZGxlUG9pbnRlckRvd24pO1xuICAgICAgICAhbW9kYWwgJiYgZmxvYXRpbmcucmVtb3ZlRXZlbnRMaXN0ZW5lcignZm9jdXNvdXQnLCBoYW5kbGVGb2N1c091dHNpZGUpO1xuICAgICAgfTtcbiAgICB9XG4gIH0sIFtkaXNhYmxlZCwgZG9tUmVmZXJlbmNlLCBmbG9hdGluZywgbW9kYWwsIG5vZGVJZCwgdHJlZSwgcG9ydGFsQ29udGV4dCwgb25PcGVuQ2hhbmdlLCBjbG9zZU9uRm9jdXNPdXRdKTtcbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICB2YXIgX3BvcnRhbENvbnRleHQkcG9ydGFsO1xuICAgIGlmIChkaXNhYmxlZCkgcmV0dXJuO1xuXG4gICAgLy8gRG9uJ3QgaGlkZSBwb3J0YWxzIG5lc3RlZCB3aXRoaW4gdGhlIHBhcmVudCBwb3J0YWwuXG4gICAgY29uc3QgcG9ydGFsTm9kZXMgPSBBcnJheS5mcm9tKChwb3J0YWxDb250ZXh0ID09IG51bGwgfHwgKF9wb3J0YWxDb250ZXh0JHBvcnRhbCA9IHBvcnRhbENvbnRleHQucG9ydGFsTm9kZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9wb3J0YWxDb250ZXh0JHBvcnRhbC5xdWVyeVNlbGVjdG9yQWxsKFwiW1wiICsgY3JlYXRlQXR0cmlidXRlKCdwb3J0YWwnKSArIFwiXVwiKSkgfHwgW10pO1xuICAgIGlmIChmbG9hdGluZykge1xuICAgICAgY29uc3QgaW5zaWRlRWxlbWVudHMgPSBbZmxvYXRpbmcsIC4uLnBvcnRhbE5vZGVzLCBzdGFydERpc21pc3NCdXR0b25SZWYuY3VycmVudCwgZW5kRGlzbWlzc0J1dHRvblJlZi5jdXJyZW50LCBvcmRlclJlZi5jdXJyZW50LmluY2x1ZGVzKCdyZWZlcmVuY2UnKSB8fCBpc1VudHJhcHBlZFR5cGVhYmxlQ29tYm9ib3ggPyBkb21SZWZlcmVuY2UgOiBudWxsXS5maWx0ZXIoeCA9PiB4ICE9IG51bGwpO1xuICAgICAgY29uc3QgY2xlYW51cCA9IG1vZGFsIHx8IGlzVW50cmFwcGVkVHlwZWFibGVDb21ib2JveCA/IG1hcmtPdGhlcnMoaW5zaWRlRWxlbWVudHMsIGd1YXJkcywgIWd1YXJkcykgOiBtYXJrT3RoZXJzKGluc2lkZUVsZW1lbnRzKTtcbiAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIGNsZWFudXAoKTtcbiAgICAgIH07XG4gICAgfVxuICB9LCBbZGlzYWJsZWQsIGRvbVJlZmVyZW5jZSwgZmxvYXRpbmcsIG1vZGFsLCBvcmRlclJlZiwgcG9ydGFsQ29udGV4dCwgaXNVbnRyYXBwZWRUeXBlYWJsZUNvbWJvYm94LCBndWFyZHNdKTtcbiAgaW5kZXgoKCkgPT4ge1xuICAgIGlmIChkaXNhYmxlZCB8fCAhZmxvYXRpbmcpIHJldHVybjtcbiAgICBjb25zdCBkb2MgPSBnZXREb2N1bWVudChmbG9hdGluZyk7XG4gICAgY29uc3QgcHJldmlvdXNseUZvY3VzZWRFbGVtZW50ID0gYWN0aXZlRWxlbWVudChkb2MpO1xuXG4gICAgLy8gV2FpdCBmb3IgYW55IGxheW91dCBlZmZlY3Qgc3RhdGUgc2V0dGVycyB0byBleGVjdXRlIHRvIHNldCBgdGFiSW5kZXhgLlxuICAgIHF1ZXVlTWljcm90YXNrKCgpID0+IHtcbiAgICAgIGNvbnN0IGZvY3VzYWJsZUVsZW1lbnRzID0gZ2V0VGFiYmFibGVFbGVtZW50cyhmbG9hdGluZyk7XG4gICAgICBjb25zdCBpbml0aWFsRm9jdXNWYWx1ZSA9IGluaXRpYWxGb2N1c1JlZi5jdXJyZW50O1xuICAgICAgY29uc3QgZWxUb0ZvY3VzID0gKHR5cGVvZiBpbml0aWFsRm9jdXNWYWx1ZSA9PT0gJ251bWJlcicgPyBmb2N1c2FibGVFbGVtZW50c1tpbml0aWFsRm9jdXNWYWx1ZV0gOiBpbml0aWFsRm9jdXNWYWx1ZS5jdXJyZW50KSB8fCBmbG9hdGluZztcbiAgICAgIGNvbnN0IGZvY3VzQWxyZWFkeUluc2lkZUZsb2F0aW5nRWwgPSBjb250YWlucyhmbG9hdGluZywgcHJldmlvdXNseUZvY3VzZWRFbGVtZW50KTtcbiAgICAgIGlmICghaWdub3JlSW5pdGlhbEZvY3VzICYmICFmb2N1c0FscmVhZHlJbnNpZGVGbG9hdGluZ0VsICYmIG9wZW4pIHtcbiAgICAgICAgZW5xdWV1ZUZvY3VzKGVsVG9Gb2N1cywge1xuICAgICAgICAgIHByZXZlbnRTY3JvbGw6IGVsVG9Gb2N1cyA9PT0gZmxvYXRpbmdcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0sIFtkaXNhYmxlZCwgb3BlbiwgZmxvYXRpbmcsIGlnbm9yZUluaXRpYWxGb2N1cywgZ2V0VGFiYmFibGVFbGVtZW50cywgaW5pdGlhbEZvY3VzUmVmXSk7XG4gIGluZGV4KCgpID0+IHtcbiAgICBpZiAoZGlzYWJsZWQgfHwgIWZsb2F0aW5nKSByZXR1cm47XG4gICAgbGV0IHByZXZlbnRSZXR1cm5Gb2N1c1Njcm9sbCA9IGZhbHNlO1xuICAgIGNvbnN0IGRvYyA9IGdldERvY3VtZW50KGZsb2F0aW5nKTtcbiAgICBjb25zdCBwcmV2aW91c2x5Rm9jdXNlZEVsZW1lbnQgPSBhY3RpdmVFbGVtZW50KGRvYyk7XG4gICAgY29uc3QgY29udGV4dERhdGEgPSBkYXRhUmVmLmN1cnJlbnQ7XG4gICAgYWRkUHJldmlvdXNseUZvY3VzZWRFbGVtZW50KHByZXZpb3VzbHlGb2N1c2VkRWxlbWVudCk7XG5cbiAgICAvLyBEaXNtaXNzaW5nIHZpYSBvdXRzaWRlIHByZXNzIHNob3VsZCBhbHdheXMgaWdub3JlIGByZXR1cm5Gb2N1c2AgdG9cbiAgICAvLyBwcmV2ZW50IHVud2FudGVkIHNjcm9sbGluZy5cbiAgICBmdW5jdGlvbiBvbk9wZW5DaGFuZ2UoX3JlZikge1xuICAgICAgbGV0IHtcbiAgICAgICAgcmVhc29uLFxuICAgICAgICBldmVudCxcbiAgICAgICAgbmVzdGVkXG4gICAgICB9ID0gX3JlZjtcbiAgICAgIGlmIChyZWFzb24gPT09ICdlc2NhcGUta2V5JyAmJiByZWZzLmRvbVJlZmVyZW5jZS5jdXJyZW50KSB7XG4gICAgICAgIGFkZFByZXZpb3VzbHlGb2N1c2VkRWxlbWVudChyZWZzLmRvbVJlZmVyZW5jZS5jdXJyZW50KTtcbiAgICAgIH1cbiAgICAgIGlmIChyZWFzb24gPT09ICdob3ZlcicgJiYgZXZlbnQudHlwZSA9PT0gJ21vdXNlbGVhdmUnKSB7XG4gICAgICAgIHByZXZlbnRSZXR1cm5Gb2N1c1JlZi5jdXJyZW50ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChyZWFzb24gIT09ICdvdXRzaWRlLXByZXNzJykgcmV0dXJuO1xuICAgICAgaWYgKG5lc3RlZCkge1xuICAgICAgICBwcmV2ZW50UmV0dXJuRm9jdXNSZWYuY3VycmVudCA9IGZhbHNlO1xuICAgICAgICBwcmV2ZW50UmV0dXJuRm9jdXNTY3JvbGwgPSB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcHJldmVudFJldHVybkZvY3VzUmVmLmN1cnJlbnQgPSAhKGlzVmlydHVhbENsaWNrKGV2ZW50KSB8fCBpc1ZpcnR1YWxQb2ludGVyRXZlbnQoZXZlbnQpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZXZlbnRzLm9uKCdvcGVuY2hhbmdlJywgb25PcGVuQ2hhbmdlKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgZXZlbnRzLm9mZignb3BlbmNoYW5nZScsIG9uT3BlbkNoYW5nZSk7XG4gICAgICBjb25zdCBhY3RpdmVFbCA9IGFjdGl2ZUVsZW1lbnQoZG9jKTtcbiAgICAgIGNvbnN0IGlzRm9jdXNJbnNpZGVGbG9hdGluZ1RyZWUgPSBjb250YWlucyhmbG9hdGluZywgYWN0aXZlRWwpIHx8IHRyZWUgJiYgZ2V0Q2hpbGRyZW4odHJlZS5ub2Rlc1JlZi5jdXJyZW50LCBub2RlSWQpLnNvbWUobm9kZSA9PiB7XG4gICAgICAgIHZhciBfbm9kZSRjb250ZXh0NTtcbiAgICAgICAgcmV0dXJuIGNvbnRhaW5zKChfbm9kZSRjb250ZXh0NSA9IG5vZGUuY29udGV4dCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9ub2RlJGNvbnRleHQ1LmVsZW1lbnRzLmZsb2F0aW5nLCBhY3RpdmVFbCk7XG4gICAgICB9KTtcbiAgICAgIGNvbnN0IHNob3VsZEZvY3VzUmVmZXJlbmNlID0gaXNGb2N1c0luc2lkZUZsb2F0aW5nVHJlZSB8fCBjb250ZXh0RGF0YS5vcGVuRXZlbnQgJiYgWydjbGljaycsICdtb3VzZWRvd24nXS5pbmNsdWRlcyhjb250ZXh0RGF0YS5vcGVuRXZlbnQudHlwZSk7XG4gICAgICBpZiAoc2hvdWxkRm9jdXNSZWZlcmVuY2UgJiYgcmVmcy5kb21SZWZlcmVuY2UuY3VycmVudCkge1xuICAgICAgICBhZGRQcmV2aW91c2x5Rm9jdXNlZEVsZW1lbnQocmVmcy5kb21SZWZlcmVuY2UuY3VycmVudCk7XG4gICAgICB9XG4gICAgICBjb25zdCByZXR1cm5FbGVtZW50ID0gZ2V0UHJldmlvdXNseUZvY3VzZWRFbGVtZW50KCk7XG4gICAgICBpZiAocmV0dXJuRm9jdXNSZWYuY3VycmVudCAmJiAhcHJldmVudFJldHVybkZvY3VzUmVmLmN1cnJlbnQgJiYgaXNIVE1MRWxlbWVudChyZXR1cm5FbGVtZW50KSAmJiAoXG4gICAgICAvLyBJZiB0aGUgZm9jdXMgbW92ZWQgc29tZXdoZXJlIGVsc2UgYWZ0ZXIgbW91bnQsIGF2b2lkIHJldHVybmluZyBmb2N1c1xuICAgICAgLy8gc2luY2UgaXQgbGlrZWx5IGVudGVyZWQgYSBkaWZmZXJlbnQgZWxlbWVudCB3aGljaCBzaG91bGQgYmVcbiAgICAgIC8vIHJlc3BlY3RlZDogaHR0cHM6Ly9naXRodWIuY29tL2Zsb2F0aW5nLXVpL2Zsb2F0aW5nLXVpL2lzc3Vlcy8yNjA3XG4gICAgICByZXR1cm5FbGVtZW50ICE9PSBhY3RpdmVFbCAmJiBhY3RpdmVFbCAhPT0gZG9jLmJvZHkgPyBpc0ZvY3VzSW5zaWRlRmxvYXRpbmdUcmVlIDogdHJ1ZSkpIHtcbiAgICAgICAgZW5xdWV1ZUZvY3VzKHJldHVybkVsZW1lbnQsIHtcbiAgICAgICAgICAvLyBXaGVuIGRpc21pc3NpbmcgbmVzdGVkIGZsb2F0aW5nIGVsZW1lbnRzLCBieSB0aGUgdGltZSB0aGUgckFGIGhhc1xuICAgICAgICAgIC8vIGV4ZWN1dGVkLCB0aGUgbWVudXMgd2lsbCBhbGwgaGF2ZSBiZWVuIHVubW91bnRlZC4gV2hlbiB0aGV5IHRyeVxuICAgICAgICAgIC8vIHRvIGdldCBmb2N1c2VkLCB0aGUgY2FsbHMgZ2V0IGlnbm9yZWQg4oCUIGxlYXZpbmcgdGhlIHJvb3RcbiAgICAgICAgICAvLyByZWZlcmVuY2UgZm9jdXNlZCBhcyBkZXNpcmVkLlxuICAgICAgICAgIGNhbmNlbFByZXZpb3VzOiBmYWxzZSxcbiAgICAgICAgICBwcmV2ZW50U2Nyb2xsOiBwcmV2ZW50UmV0dXJuRm9jdXNTY3JvbGxcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfTtcbiAgfSwgW2Rpc2FibGVkLCBmbG9hdGluZywgcmV0dXJuRm9jdXNSZWYsIGRhdGFSZWYsIHJlZnMsIGV2ZW50cywgdHJlZSwgbm9kZUlkXSk7XG5cbiAgLy8gU3luY2hyb25pemUgdGhlIGBjb250ZXh0YCAmIGBtb2RhbGAgdmFsdWUgdG8gdGhlIEZsb2F0aW5nUG9ydGFsIGNvbnRleHQuXG4gIC8vIEl0IHdpbGwgZGVjaWRlIHdoZXRoZXIgb3Igbm90IGl0IG5lZWRzIHRvIHJlbmRlciBpdHMgb3duIGd1YXJkcy5cbiAgaW5kZXgoKCkgPT4ge1xuICAgIGlmIChkaXNhYmxlZCB8fCAhcG9ydGFsQ29udGV4dCkgcmV0dXJuO1xuICAgIHBvcnRhbENvbnRleHQuc2V0Rm9jdXNNYW5hZ2VyU3RhdGUoe1xuICAgICAgbW9kYWwsXG4gICAgICBjbG9zZU9uRm9jdXNPdXQsXG4gICAgICBvcGVuLFxuICAgICAgb25PcGVuQ2hhbmdlLFxuICAgICAgcmVmc1xuICAgIH0pO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBwb3J0YWxDb250ZXh0LnNldEZvY3VzTWFuYWdlclN0YXRlKG51bGwpO1xuICAgIH07XG4gIH0sIFtkaXNhYmxlZCwgcG9ydGFsQ29udGV4dCwgbW9kYWwsIG9wZW4sIG9uT3BlbkNoYW5nZSwgcmVmcywgY2xvc2VPbkZvY3VzT3V0XSk7XG4gIGluZGV4KCgpID0+IHtcbiAgICBpZiAoZGlzYWJsZWQgfHwgIWZsb2F0aW5nIHx8IHR5cGVvZiBNdXRhdGlvbk9ic2VydmVyICE9PSAnZnVuY3Rpb24nIHx8IGlnbm9yZUluaXRpYWxGb2N1cykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBoYW5kbGVNdXRhdGlvbiA9ICgpID0+IHtcbiAgICAgIGNvbnN0IHRhYkluZGV4ID0gZmxvYXRpbmcuZ2V0QXR0cmlidXRlKCd0YWJpbmRleCcpO1xuICAgICAgaWYgKG9yZGVyUmVmLmN1cnJlbnQuaW5jbHVkZXMoJ2Zsb2F0aW5nJykgfHwgYWN0aXZlRWxlbWVudChnZXREb2N1bWVudChmbG9hdGluZykpICE9PSByZWZzLmRvbVJlZmVyZW5jZS5jdXJyZW50ICYmIGdldFRhYmJhYmxlQ29udGVudCgpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBpZiAodGFiSW5kZXggIT09ICcwJykge1xuICAgICAgICAgIGZsb2F0aW5nLnNldEF0dHJpYnV0ZSgndGFiaW5kZXgnLCAnMCcpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHRhYkluZGV4ICE9PSAnLTEnKSB7XG4gICAgICAgIGZsb2F0aW5nLnNldEF0dHJpYnV0ZSgndGFiaW5kZXgnLCAnLTEnKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGhhbmRsZU11dGF0aW9uKCk7XG4gICAgY29uc3Qgb2JzZXJ2ZXIgPSBuZXcgTXV0YXRpb25PYnNlcnZlcihoYW5kbGVNdXRhdGlvbik7XG4gICAgb2JzZXJ2ZXIub2JzZXJ2ZShmbG9hdGluZywge1xuICAgICAgY2hpbGRMaXN0OiB0cnVlLFxuICAgICAgc3VidHJlZTogdHJ1ZSxcbiAgICAgIGF0dHJpYnV0ZXM6IHRydWVcbiAgICB9KTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgb2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICAgIH07XG4gIH0sIFtkaXNhYmxlZCwgZmxvYXRpbmcsIHJlZnMsIG9yZGVyUmVmLCBnZXRUYWJiYWJsZUNvbnRlbnQsIGlnbm9yZUluaXRpYWxGb2N1c10pO1xuICBmdW5jdGlvbiByZW5kZXJEaXNtaXNzQnV0dG9uKGxvY2F0aW9uKSB7XG4gICAgaWYgKGRpc2FibGVkIHx8ICF2aXN1YWxseUhpZGRlbkRpc21pc3MgfHwgIW1vZGFsKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFZpc3VhbGx5SGlkZGVuRGlzbWlzcywge1xuICAgICAgcmVmOiBsb2NhdGlvbiA9PT0gJ3N0YXJ0JyA/IHN0YXJ0RGlzbWlzc0J1dHRvblJlZiA6IGVuZERpc21pc3NCdXR0b25SZWYsXG4gICAgICBvbkNsaWNrOiBldmVudCA9PiBvbk9wZW5DaGFuZ2UoZmFsc2UsIGV2ZW50Lm5hdGl2ZUV2ZW50KVxuICAgIH0sIHR5cGVvZiB2aXN1YWxseUhpZGRlbkRpc21pc3MgPT09ICdzdHJpbmcnID8gdmlzdWFsbHlIaWRkZW5EaXNtaXNzIDogJ0Rpc21pc3MnKTtcbiAgfVxuICBjb25zdCBzaG91bGRSZW5kZXJHdWFyZHMgPSAhZGlzYWJsZWQgJiYgZ3VhcmRzICYmIChpc0luc2lkZVBvcnRhbCB8fCBtb2RhbCk7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChSZWFjdC5GcmFnbWVudCwgbnVsbCwgc2hvdWxkUmVuZGVyR3VhcmRzICYmIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KEZvY3VzR3VhcmQsIHtcbiAgICBcImRhdGEtdHlwZVwiOiBcImluc2lkZVwiLFxuICAgIHJlZjogcG9ydGFsQ29udGV4dCA9PSBudWxsID8gdm9pZCAwIDogcG9ydGFsQ29udGV4dC5iZWZvcmVJbnNpZGVSZWYsXG4gICAgb25Gb2N1czogZXZlbnQgPT4ge1xuICAgICAgaWYgKG1vZGFsKSB7XG4gICAgICAgIGNvbnN0IGVscyA9IGdldFRhYmJhYmxlRWxlbWVudHMoKTtcbiAgICAgICAgZW5xdWV1ZUZvY3VzKG9yZGVyWzBdID09PSAncmVmZXJlbmNlJyA/IGVsc1swXSA6IGVsc1tlbHMubGVuZ3RoIC0gMV0pO1xuICAgICAgfSBlbHNlIGlmIChwb3J0YWxDb250ZXh0ICE9IG51bGwgJiYgcG9ydGFsQ29udGV4dC5wcmVzZXJ2ZVRhYk9yZGVyICYmIHBvcnRhbENvbnRleHQucG9ydGFsTm9kZSkge1xuICAgICAgICBwcmV2ZW50UmV0dXJuRm9jdXNSZWYuY3VycmVudCA9IGZhbHNlO1xuICAgICAgICBpZiAoaXNPdXRzaWRlRXZlbnQoZXZlbnQsIHBvcnRhbENvbnRleHQucG9ydGFsTm9kZSkpIHtcbiAgICAgICAgICBjb25zdCBuZXh0VGFiYmFibGUgPSBnZXROZXh0VGFiYmFibGUoKSB8fCBkb21SZWZlcmVuY2U7XG4gICAgICAgICAgbmV4dFRhYmJhYmxlID09IG51bGwgfHwgbmV4dFRhYmJhYmxlLmZvY3VzKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIF9wb3J0YWxDb250ZXh0JGJlZm9yZTtcbiAgICAgICAgICAoX3BvcnRhbENvbnRleHQkYmVmb3JlID0gcG9ydGFsQ29udGV4dC5iZWZvcmVPdXRzaWRlUmVmLmN1cnJlbnQpID09IG51bGwgfHwgX3BvcnRhbENvbnRleHQkYmVmb3JlLmZvY3VzKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0pLCAhaXNVbnRyYXBwZWRUeXBlYWJsZUNvbWJvYm94ICYmIHJlbmRlckRpc21pc3NCdXR0b24oJ3N0YXJ0JyksIGNoaWxkcmVuLCByZW5kZXJEaXNtaXNzQnV0dG9uKCdlbmQnKSwgc2hvdWxkUmVuZGVyR3VhcmRzICYmIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KEZvY3VzR3VhcmQsIHtcbiAgICBcImRhdGEtdHlwZVwiOiBcImluc2lkZVwiLFxuICAgIHJlZjogcG9ydGFsQ29udGV4dCA9PSBudWxsID8gdm9pZCAwIDogcG9ydGFsQ29udGV4dC5hZnRlckluc2lkZVJlZixcbiAgICBvbkZvY3VzOiBldmVudCA9PiB7XG4gICAgICBpZiAobW9kYWwpIHtcbiAgICAgICAgZW5xdWV1ZUZvY3VzKGdldFRhYmJhYmxlRWxlbWVudHMoKVswXSk7XG4gICAgICB9IGVsc2UgaWYgKHBvcnRhbENvbnRleHQgIT0gbnVsbCAmJiBwb3J0YWxDb250ZXh0LnByZXNlcnZlVGFiT3JkZXIgJiYgcG9ydGFsQ29udGV4dC5wb3J0YWxOb2RlKSB7XG4gICAgICAgIGlmIChjbG9zZU9uRm9jdXNPdXQpIHtcbiAgICAgICAgICBwcmV2ZW50UmV0dXJuRm9jdXNSZWYuY3VycmVudCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzT3V0c2lkZUV2ZW50KGV2ZW50LCBwb3J0YWxDb250ZXh0LnBvcnRhbE5vZGUpKSB7XG4gICAgICAgICAgY29uc3QgcHJldlRhYmJhYmxlID0gZ2V0UHJldmlvdXNUYWJiYWJsZSgpIHx8IGRvbVJlZmVyZW5jZTtcbiAgICAgICAgICBwcmV2VGFiYmFibGUgPT0gbnVsbCB8fCBwcmV2VGFiYmFibGUuZm9jdXMoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgX3BvcnRhbENvbnRleHQkYWZ0ZXJPO1xuICAgICAgICAgIChfcG9ydGFsQ29udGV4dCRhZnRlck8gPSBwb3J0YWxDb250ZXh0LmFmdGVyT3V0c2lkZVJlZi5jdXJyZW50KSA9PSBudWxsIHx8IF9wb3J0YWxDb250ZXh0JGFmdGVyTy5mb2N1cygpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9KSk7XG59XG5cbmNvbnN0IGFjdGl2ZUxvY2tzID0gLyojX19QVVJFX18qL25ldyBTZXQoKTtcbi8qKlxuICogUHJvdmlkZXMgYmFzZSBzdHlsaW5nIGZvciBhIGZpeGVkIG92ZXJsYXkgZWxlbWVudCB0byBkaW0gY29udGVudCBvciBibG9ja1xuICogcG9pbnRlciBldmVudHMgYmVoaW5kIGEgZmxvYXRpbmcgZWxlbWVudC5cbiAqIEl0J3MgYSByZWd1bGFyIGA8ZGl2PmAsIHNvIGl0IGNhbiBiZSBzdHlsZWQgdmlhIGFueSBDU1Mgc29sdXRpb24geW91IHByZWZlci5cbiAqIEBzZWUgaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy9GbG9hdGluZ092ZXJsYXlcbiAqL1xuY29uc3QgRmxvYXRpbmdPdmVybGF5ID0gLyojX19QVVJFX18qL1JlYWN0LmZvcndhcmRSZWYoZnVuY3Rpb24gRmxvYXRpbmdPdmVybGF5KF9yZWYsIHJlZikge1xuICBsZXQge1xuICAgIGxvY2tTY3JvbGwgPSBmYWxzZSxcbiAgICAuLi5yZXN0XG4gIH0gPSBfcmVmO1xuICBjb25zdCBsb2NrSWQgPSB1c2VJZCgpO1xuICBpbmRleCgoKSA9PiB7XG4gICAgaWYgKCFsb2NrU2Nyb2xsKSByZXR1cm47XG4gICAgYWN0aXZlTG9ja3MuYWRkKGxvY2tJZCk7XG4gICAgY29uc3QgaXNJT1MgPSAvaVAoaG9uZXxhZHxvZCl8aU9TLy50ZXN0KGdldFBsYXRmb3JtKCkpO1xuICAgIGNvbnN0IGJvZHlTdHlsZSA9IGRvY3VtZW50LmJvZHkuc3R5bGU7XG4gICAgLy8gUlRMIDxib2R5PiBzY3JvbGxiYXJcbiAgICBjb25zdCBzY3JvbGxiYXJYID0gTWF0aC5yb3VuZChkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkubGVmdCkgKyBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsTGVmdDtcbiAgICBjb25zdCBwYWRkaW5nUHJvcCA9IHNjcm9sbGJhclggPyAncGFkZGluZ0xlZnQnIDogJ3BhZGRpbmdSaWdodCc7XG4gICAgY29uc3Qgc2Nyb2xsYmFyV2lkdGggPSB3aW5kb3cuaW5uZXJXaWR0aCAtIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRXaWR0aDtcbiAgICBjb25zdCBzY3JvbGxYID0gYm9keVN0eWxlLmxlZnQgPyBwYXJzZUZsb2F0KGJvZHlTdHlsZS5sZWZ0KSA6IHdpbmRvdy5wYWdlWE9mZnNldDtcbiAgICBjb25zdCBzY3JvbGxZID0gYm9keVN0eWxlLnRvcCA/IHBhcnNlRmxvYXQoYm9keVN0eWxlLnRvcCkgOiB3aW5kb3cucGFnZVlPZmZzZXQ7XG4gICAgYm9keVN0eWxlLm92ZXJmbG93ID0gJ2hpZGRlbic7XG4gICAgaWYgKHNjcm9sbGJhcldpZHRoKSB7XG4gICAgICBib2R5U3R5bGVbcGFkZGluZ1Byb3BdID0gc2Nyb2xsYmFyV2lkdGggKyBcInB4XCI7XG4gICAgfVxuXG4gICAgLy8gT25seSBpT1MgZG9lc24ndCByZXNwZWN0IGBvdmVyZmxvdzogaGlkZGVuYCBvbiBkb2N1bWVudC5ib2R5LCBhbmQgdGhpc1xuICAgIC8vIHRlY2huaXF1ZSBoYXMgZmV3ZXIgc2lkZSBlZmZlY3RzLlxuICAgIGlmIChpc0lPUykge1xuICAgICAgdmFyIF93aW5kb3ckdmlzdWFsVmlld3BvciwgX3dpbmRvdyR2aXN1YWxWaWV3cG9yMjtcbiAgICAgIC8vIGlPUyAxMiBkb2VzIG5vdCBzdXBwb3J0IGB2aXN1YWxWaWV3cG9ydGAuXG4gICAgICBjb25zdCBvZmZzZXRMZWZ0ID0gKChfd2luZG93JHZpc3VhbFZpZXdwb3IgPSB3aW5kb3cudmlzdWFsVmlld3BvcnQpID09IG51bGwgPyB2b2lkIDAgOiBfd2luZG93JHZpc3VhbFZpZXdwb3Iub2Zmc2V0TGVmdCkgfHwgMDtcbiAgICAgIGNvbnN0IG9mZnNldFRvcCA9ICgoX3dpbmRvdyR2aXN1YWxWaWV3cG9yMiA9IHdpbmRvdy52aXN1YWxWaWV3cG9ydCkgPT0gbnVsbCA/IHZvaWQgMCA6IF93aW5kb3ckdmlzdWFsVmlld3BvcjIub2Zmc2V0VG9wKSB8fCAwO1xuICAgICAgT2JqZWN0LmFzc2lnbihib2R5U3R5bGUsIHtcbiAgICAgICAgcG9zaXRpb246ICdmaXhlZCcsXG4gICAgICAgIHRvcDogLShzY3JvbGxZIC0gTWF0aC5mbG9vcihvZmZzZXRUb3ApKSArIFwicHhcIixcbiAgICAgICAgbGVmdDogLShzY3JvbGxYIC0gTWF0aC5mbG9vcihvZmZzZXRMZWZ0KSkgKyBcInB4XCIsXG4gICAgICAgIHJpZ2h0OiAnMCdcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgYWN0aXZlTG9ja3MuZGVsZXRlKGxvY2tJZCk7XG4gICAgICBpZiAoYWN0aXZlTG9ja3Muc2l6ZSA9PT0gMCkge1xuICAgICAgICBPYmplY3QuYXNzaWduKGJvZHlTdHlsZSwge1xuICAgICAgICAgIG92ZXJmbG93OiAnJyxcbiAgICAgICAgICBbcGFkZGluZ1Byb3BdOiAnJ1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGlzSU9TKSB7XG4gICAgICAgICAgT2JqZWN0LmFzc2lnbihib2R5U3R5bGUsIHtcbiAgICAgICAgICAgIHBvc2l0aW9uOiAnJyxcbiAgICAgICAgICAgIHRvcDogJycsXG4gICAgICAgICAgICBsZWZ0OiAnJyxcbiAgICAgICAgICAgIHJpZ2h0OiAnJ1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHdpbmRvdy5zY3JvbGxUbyhzY3JvbGxYLCBzY3JvbGxZKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gIH0sIFtsb2NrSWQsIGxvY2tTY3JvbGxdKTtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIF9leHRlbmRzKHtcbiAgICByZWY6IHJlZlxuICB9LCByZXN0LCB7XG4gICAgc3R5bGU6IHtcbiAgICAgIHBvc2l0aW9uOiAnZml4ZWQnLFxuICAgICAgb3ZlcmZsb3c6ICdhdXRvJyxcbiAgICAgIHRvcDogMCxcbiAgICAgIHJpZ2h0OiAwLFxuICAgICAgYm90dG9tOiAwLFxuICAgICAgbGVmdDogMCxcbiAgICAgIC4uLnJlc3Quc3R5bGVcbiAgICB9XG4gIH0pKTtcbn0pO1xuXG5mdW5jdGlvbiBpc0J1dHRvblRhcmdldChldmVudCkge1xuICByZXR1cm4gaXNIVE1MRWxlbWVudChldmVudC50YXJnZXQpICYmIGV2ZW50LnRhcmdldC50YWdOYW1lID09PSAnQlVUVE9OJztcbn1cbmZ1bmN0aW9uIGlzU3BhY2VJZ25vcmVkKGVsZW1lbnQpIHtcbiAgcmV0dXJuIGlzVHlwZWFibGVFbGVtZW50KGVsZW1lbnQpO1xufVxuLyoqXG4gKiBPcGVucyBvciBjbG9zZXMgdGhlIGZsb2F0aW5nIGVsZW1lbnQgd2hlbiBjbGlja2luZyB0aGUgcmVmZXJlbmNlIGVsZW1lbnQuXG4gKiBAc2VlIGh0dHBzOi8vZmxvYXRpbmctdWkuY29tL2RvY3MvdXNlQ2xpY2tcbiAqL1xuZnVuY3Rpb24gdXNlQ2xpY2soY29udGV4dCwgcHJvcHMpIHtcbiAgaWYgKHByb3BzID09PSB2b2lkIDApIHtcbiAgICBwcm9wcyA9IHt9O1xuICB9XG4gIGNvbnN0IHtcbiAgICBvcGVuLFxuICAgIG9uT3BlbkNoYW5nZSxcbiAgICBkYXRhUmVmLFxuICAgIGVsZW1lbnRzOiB7XG4gICAgICBkb21SZWZlcmVuY2VcbiAgICB9XG4gIH0gPSBjb250ZXh0O1xuICBjb25zdCB7XG4gICAgZW5hYmxlZCA9IHRydWUsXG4gICAgZXZlbnQ6IGV2ZW50T3B0aW9uID0gJ2NsaWNrJyxcbiAgICB0b2dnbGUgPSB0cnVlLFxuICAgIGlnbm9yZU1vdXNlID0gZmFsc2UsXG4gICAga2V5Ym9hcmRIYW5kbGVycyA9IHRydWVcbiAgfSA9IHByb3BzO1xuICBjb25zdCBwb2ludGVyVHlwZVJlZiA9IFJlYWN0LnVzZVJlZigpO1xuICBjb25zdCBkaWRLZXlEb3duUmVmID0gUmVhY3QudXNlUmVmKGZhbHNlKTtcbiAgcmV0dXJuIFJlYWN0LnVzZU1lbW8oKCkgPT4ge1xuICAgIGlmICghZW5hYmxlZCkgcmV0dXJuIHt9O1xuICAgIHJldHVybiB7XG4gICAgICByZWZlcmVuY2U6IHtcbiAgICAgICAgb25Qb2ludGVyRG93bihldmVudCkge1xuICAgICAgICAgIHBvaW50ZXJUeXBlUmVmLmN1cnJlbnQgPSBldmVudC5wb2ludGVyVHlwZTtcbiAgICAgICAgfSxcbiAgICAgICAgb25Nb3VzZURvd24oZXZlbnQpIHtcbiAgICAgICAgICAvLyBJZ25vcmUgYWxsIGJ1dHRvbnMgZXhjZXB0IGZvciB0aGUgXCJtYWluXCIgYnV0dG9uLlxuICAgICAgICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9Nb3VzZUV2ZW50L2J1dHRvblxuICAgICAgICAgIGlmIChldmVudC5idXR0b24gIT09IDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGlzTW91c2VMaWtlUG9pbnRlclR5cGUocG9pbnRlclR5cGVSZWYuY3VycmVudCwgdHJ1ZSkgJiYgaWdub3JlTW91c2UpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGV2ZW50T3B0aW9uID09PSAnY2xpY2snKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChvcGVuICYmIHRvZ2dsZSAmJiAoZGF0YVJlZi5jdXJyZW50Lm9wZW5FdmVudCA/IGRhdGFSZWYuY3VycmVudC5vcGVuRXZlbnQudHlwZSA9PT0gJ21vdXNlZG93bicgOiB0cnVlKSkge1xuICAgICAgICAgICAgb25PcGVuQ2hhbmdlKGZhbHNlLCBldmVudC5uYXRpdmVFdmVudCwgJ2NsaWNrJyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIFByZXZlbnQgc3RlYWxpbmcgZm9jdXMgZnJvbSB0aGUgZmxvYXRpbmcgZWxlbWVudFxuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIG9uT3BlbkNoYW5nZSh0cnVlLCBldmVudC5uYXRpdmVFdmVudCwgJ2NsaWNrJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBvbkNsaWNrKGV2ZW50KSB7XG4gICAgICAgICAgaWYgKGV2ZW50T3B0aW9uID09PSAnbW91c2Vkb3duJyAmJiBwb2ludGVyVHlwZVJlZi5jdXJyZW50KSB7XG4gICAgICAgICAgICBwb2ludGVyVHlwZVJlZi5jdXJyZW50ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaXNNb3VzZUxpa2VQb2ludGVyVHlwZShwb2ludGVyVHlwZVJlZi5jdXJyZW50LCB0cnVlKSAmJiBpZ25vcmVNb3VzZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAob3BlbiAmJiB0b2dnbGUgJiYgKGRhdGFSZWYuY3VycmVudC5vcGVuRXZlbnQgPyBkYXRhUmVmLmN1cnJlbnQub3BlbkV2ZW50LnR5cGUgPT09ICdjbGljaycgOiB0cnVlKSkge1xuICAgICAgICAgICAgb25PcGVuQ2hhbmdlKGZhbHNlLCBldmVudC5uYXRpdmVFdmVudCwgJ2NsaWNrJyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG9uT3BlbkNoYW5nZSh0cnVlLCBldmVudC5uYXRpdmVFdmVudCwgJ2NsaWNrJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBvbktleURvd24oZXZlbnQpIHtcbiAgICAgICAgICBwb2ludGVyVHlwZVJlZi5jdXJyZW50ID0gdW5kZWZpbmVkO1xuICAgICAgICAgIGlmIChldmVudC5kZWZhdWx0UHJldmVudGVkIHx8ICFrZXlib2FyZEhhbmRsZXJzIHx8IGlzQnV0dG9uVGFyZ2V0KGV2ZW50KSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZXZlbnQua2V5ID09PSAnICcgJiYgIWlzU3BhY2VJZ25vcmVkKGRvbVJlZmVyZW5jZSkpIHtcbiAgICAgICAgICAgIC8vIFByZXZlbnQgc2Nyb2xsaW5nXG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgZGlkS2V5RG93blJlZi5jdXJyZW50ID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGV2ZW50LmtleSA9PT0gJ0VudGVyJykge1xuICAgICAgICAgICAgaWYgKG9wZW4gJiYgdG9nZ2xlKSB7XG4gICAgICAgICAgICAgIG9uT3BlbkNoYW5nZShmYWxzZSwgZXZlbnQubmF0aXZlRXZlbnQsICdjbGljaycpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgb25PcGVuQ2hhbmdlKHRydWUsIGV2ZW50Lm5hdGl2ZUV2ZW50LCAnY2xpY2snKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIG9uS2V5VXAoZXZlbnQpIHtcbiAgICAgICAgICBpZiAoZXZlbnQuZGVmYXVsdFByZXZlbnRlZCB8fCAha2V5Ym9hcmRIYW5kbGVycyB8fCBpc0J1dHRvblRhcmdldChldmVudCkgfHwgaXNTcGFjZUlnbm9yZWQoZG9tUmVmZXJlbmNlKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZXZlbnQua2V5ID09PSAnICcgJiYgZGlkS2V5RG93blJlZi5jdXJyZW50KSB7XG4gICAgICAgICAgICBkaWRLZXlEb3duUmVmLmN1cnJlbnQgPSBmYWxzZTtcbiAgICAgICAgICAgIGlmIChvcGVuICYmIHRvZ2dsZSkge1xuICAgICAgICAgICAgICBvbk9wZW5DaGFuZ2UoZmFsc2UsIGV2ZW50Lm5hdGl2ZUV2ZW50LCAnY2xpY2snKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG9uT3BlbkNoYW5nZSh0cnVlLCBldmVudC5uYXRpdmVFdmVudCwgJ2NsaWNrJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgfSwgW2VuYWJsZWQsIGRhdGFSZWYsIGV2ZW50T3B0aW9uLCBpZ25vcmVNb3VzZSwga2V5Ym9hcmRIYW5kbGVycywgZG9tUmVmZXJlbmNlLCB0b2dnbGUsIG9wZW4sIG9uT3BlbkNoYW5nZV0pO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVWaXJ0dWFsRWxlbWVudChkb21SZWYsIGRhdGEpIHtcbiAgbGV0IG9mZnNldFggPSBudWxsO1xuICBsZXQgb2Zmc2V0WSA9IG51bGw7XG4gIGxldCBpc0F1dG9VcGRhdGVFdmVudCA9IGZhbHNlO1xuICByZXR1cm4ge1xuICAgIGNvbnRleHRFbGVtZW50OiBkb21SZWYuY3VycmVudCB8fCB1bmRlZmluZWQsXG4gICAgZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkge1xuICAgICAgdmFyIF9kb21SZWYkY3VycmVudCwgX2RhdGEkZGF0YVJlZiRjdXJyZW50O1xuICAgICAgY29uc3QgZG9tUmVjdCA9ICgoX2RvbVJlZiRjdXJyZW50ID0gZG9tUmVmLmN1cnJlbnQpID09IG51bGwgPyB2b2lkIDAgOiBfZG9tUmVmJGN1cnJlbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkpIHx8IHtcbiAgICAgICAgd2lkdGg6IDAsXG4gICAgICAgIGhlaWdodDogMCxcbiAgICAgICAgeDogMCxcbiAgICAgICAgeTogMFxuICAgICAgfTtcbiAgICAgIGNvbnN0IGlzWEF4aXMgPSBkYXRhLmF4aXMgPT09ICd4JyB8fCBkYXRhLmF4aXMgPT09ICdib3RoJztcbiAgICAgIGNvbnN0IGlzWUF4aXMgPSBkYXRhLmF4aXMgPT09ICd5JyB8fCBkYXRhLmF4aXMgPT09ICdib3RoJztcbiAgICAgIGNvbnN0IGNhblRyYWNrQ3Vyc29yT25BdXRvVXBkYXRlID0gWydtb3VzZWVudGVyJywgJ21vdXNlbW92ZSddLmluY2x1ZGVzKCgoX2RhdGEkZGF0YVJlZiRjdXJyZW50ID0gZGF0YS5kYXRhUmVmLmN1cnJlbnQub3BlbkV2ZW50KSA9PSBudWxsID8gdm9pZCAwIDogX2RhdGEkZGF0YVJlZiRjdXJyZW50LnR5cGUpIHx8ICcnKSAmJiBkYXRhLnBvaW50ZXJUeXBlICE9PSAndG91Y2gnO1xuICAgICAgbGV0IHdpZHRoID0gZG9tUmVjdC53aWR0aDtcbiAgICAgIGxldCBoZWlnaHQgPSBkb21SZWN0LmhlaWdodDtcbiAgICAgIGxldCB4ID0gZG9tUmVjdC54O1xuICAgICAgbGV0IHkgPSBkb21SZWN0Lnk7XG4gICAgICBpZiAob2Zmc2V0WCA9PSBudWxsICYmIGRhdGEueCAmJiBpc1hBeGlzKSB7XG4gICAgICAgIG9mZnNldFggPSBkb21SZWN0LnggLSBkYXRhLng7XG4gICAgICB9XG4gICAgICBpZiAob2Zmc2V0WSA9PSBudWxsICYmIGRhdGEueSAmJiBpc1lBeGlzKSB7XG4gICAgICAgIG9mZnNldFkgPSBkb21SZWN0LnkgLSBkYXRhLnk7XG4gICAgICB9XG4gICAgICB4IC09IG9mZnNldFggfHwgMDtcbiAgICAgIHkgLT0gb2Zmc2V0WSB8fCAwO1xuICAgICAgd2lkdGggPSAwO1xuICAgICAgaGVpZ2h0ID0gMDtcbiAgICAgIGlmICghaXNBdXRvVXBkYXRlRXZlbnQgfHwgY2FuVHJhY2tDdXJzb3JPbkF1dG9VcGRhdGUpIHtcbiAgICAgICAgd2lkdGggPSBkYXRhLmF4aXMgPT09ICd5JyA/IGRvbVJlY3Qud2lkdGggOiAwO1xuICAgICAgICBoZWlnaHQgPSBkYXRhLmF4aXMgPT09ICd4JyA/IGRvbVJlY3QuaGVpZ2h0IDogMDtcbiAgICAgICAgeCA9IGlzWEF4aXMgJiYgZGF0YS54ICE9IG51bGwgPyBkYXRhLnggOiB4O1xuICAgICAgICB5ID0gaXNZQXhpcyAmJiBkYXRhLnkgIT0gbnVsbCA/IGRhdGEueSA6IHk7XG4gICAgICB9IGVsc2UgaWYgKGlzQXV0b1VwZGF0ZUV2ZW50ICYmICFjYW5UcmFja0N1cnNvck9uQXV0b1VwZGF0ZSkge1xuICAgICAgICBoZWlnaHQgPSBkYXRhLmF4aXMgPT09ICd4JyA/IGRvbVJlY3QuaGVpZ2h0IDogaGVpZ2h0O1xuICAgICAgICB3aWR0aCA9IGRhdGEuYXhpcyA9PT0gJ3knID8gZG9tUmVjdC53aWR0aCA6IHdpZHRoO1xuICAgICAgfVxuICAgICAgaXNBdXRvVXBkYXRlRXZlbnQgPSB0cnVlO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgd2lkdGgsXG4gICAgICAgIGhlaWdodCxcbiAgICAgICAgeCxcbiAgICAgICAgeSxcbiAgICAgICAgdG9wOiB5LFxuICAgICAgICByaWdodDogeCArIHdpZHRoLFxuICAgICAgICBib3R0b206IHkgKyBoZWlnaHQsXG4gICAgICAgIGxlZnQ6IHhcbiAgICAgIH07XG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24gaXNNb3VzZUJhc2VkRXZlbnQoZXZlbnQpIHtcbiAgcmV0dXJuIGV2ZW50ICE9IG51bGwgJiYgZXZlbnQuY2xpZW50WCAhPSBudWxsO1xufVxuLyoqXG4gKiBQb3NpdGlvbnMgdGhlIGZsb2F0aW5nIGVsZW1lbnQgcmVsYXRpdmUgdG8gYSBjbGllbnQgcG9pbnQgKGluIHRoZSB2aWV3cG9ydCksXG4gKiBzdWNoIGFzIHRoZSBtb3VzZSBwb3NpdGlvbi4gQnkgZGVmYXVsdCwgaXQgZm9sbG93cyB0aGUgbW91c2UgY3Vyc29yLlxuICogQHNlZSBodHRwczovL2Zsb2F0aW5nLXVpLmNvbS9kb2NzL3VzZUNsaWVudFBvaW50XG4gKi9cbmZ1bmN0aW9uIHVzZUNsaWVudFBvaW50KGNvbnRleHQsIHByb3BzKSB7XG4gIGlmIChwcm9wcyA9PT0gdm9pZCAwKSB7XG4gICAgcHJvcHMgPSB7fTtcbiAgfVxuICBjb25zdCB7XG4gICAgb3BlbixcbiAgICByZWZzLFxuICAgIGRhdGFSZWYsXG4gICAgZWxlbWVudHM6IHtcbiAgICAgIGZsb2F0aW5nXG4gICAgfVxuICB9ID0gY29udGV4dDtcbiAgY29uc3Qge1xuICAgIGVuYWJsZWQgPSB0cnVlLFxuICAgIGF4aXMgPSAnYm90aCcsXG4gICAgeCA9IG51bGwsXG4gICAgeSA9IG51bGxcbiAgfSA9IHByb3BzO1xuICBjb25zdCBpbml0aWFsUmVmID0gUmVhY3QudXNlUmVmKGZhbHNlKTtcbiAgY29uc3QgY2xlYW51cExpc3RlbmVyUmVmID0gUmVhY3QudXNlUmVmKG51bGwpO1xuICBjb25zdCBbcG9pbnRlclR5cGUsIHNldFBvaW50ZXJUeXBlXSA9IFJlYWN0LnVzZVN0YXRlKCk7XG4gIGNvbnN0IFtyZWFjdGl2ZSwgc2V0UmVhY3RpdmVdID0gUmVhY3QudXNlU3RhdGUoW10pO1xuICBjb25zdCBzZXRSZWZlcmVuY2UgPSB1c2VFZmZlY3RFdmVudCgoeCwgeSkgPT4ge1xuICAgIGlmIChpbml0aWFsUmVmLmN1cnJlbnQpIHJldHVybjtcblxuICAgIC8vIFByZXZlbnQgc2V0dGluZyBpZiB0aGUgb3BlbiBldmVudCB3YXMgbm90IGEgbW91c2UtbGlrZSBvbmVcbiAgICAvLyAoZS5nLiBmb2N1cyB0byBvcGVuLCB0aGVuIGhvdmVyIG92ZXIgdGhlIHJlZmVyZW5jZSBlbGVtZW50KS5cbiAgICAvLyBPbmx5IGFwcGx5IGlmIHRoZSBldmVudCBleGlzdHMuXG4gICAgaWYgKGRhdGFSZWYuY3VycmVudC5vcGVuRXZlbnQgJiYgIWlzTW91c2VCYXNlZEV2ZW50KGRhdGFSZWYuY3VycmVudC5vcGVuRXZlbnQpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHJlZnMuc2V0UG9zaXRpb25SZWZlcmVuY2UoY3JlYXRlVmlydHVhbEVsZW1lbnQocmVmcy5kb21SZWZlcmVuY2UsIHtcbiAgICAgIHgsXG4gICAgICB5LFxuICAgICAgYXhpcyxcbiAgICAgIGRhdGFSZWYsXG4gICAgICBwb2ludGVyVHlwZVxuICAgIH0pKTtcbiAgfSk7XG4gIGNvbnN0IGhhbmRsZVJlZmVyZW5jZUVudGVyT3JNb3ZlID0gdXNlRWZmZWN0RXZlbnQoZXZlbnQgPT4ge1xuICAgIGlmICh4ICE9IG51bGwgfHwgeSAhPSBudWxsKSByZXR1cm47XG4gICAgaWYgKCFvcGVuKSB7XG4gICAgICBzZXRSZWZlcmVuY2UoZXZlbnQuY2xpZW50WCwgZXZlbnQuY2xpZW50WSk7XG4gICAgfSBlbHNlIGlmICghY2xlYW51cExpc3RlbmVyUmVmLmN1cnJlbnQpIHtcbiAgICAgIC8vIElmIHRoZXJlJ3Mgbm8gY2xlYW51cCwgdGhlcmUncyBubyBsaXN0ZW5lciwgYnV0IHdlIHdhbnQgdG8gZW5zdXJlXG4gICAgICAvLyB3ZSBhZGQgdGhlIGxpc3RlbmVyIGlmIHRoZSBjdXJzb3IgbGFuZGVkIG9uIHRoZSBmbG9hdGluZyBlbGVtZW50IGFuZFxuICAgICAgLy8gdGhlbiBiYWNrIG9uIHRoZSByZWZlcmVuY2UgKGkuZS4gaXQncyBpbnRlcmFjdGl2ZSkuXG4gICAgICBzZXRSZWFjdGl2ZShbXSk7XG4gICAgfVxuICB9KTtcblxuICAvLyBJZiB0aGUgcG9pbnRlciBpcyBhIG1vdXNlLWxpa2UgcG9pbnRlciwgd2Ugd2FudCB0byBjb250aW51ZSBmb2xsb3dpbmcgdGhlXG4gIC8vIG1vdXNlIGV2ZW4gaWYgdGhlIGZsb2F0aW5nIGVsZW1lbnQgaXMgdHJhbnNpdGlvbmluZyBvdXQuIE9uIHRvdWNoXG4gIC8vIGRldmljZXMsIHRoaXMgaXMgdW5kZXNpcmFibGUgYmVjYXVzZSB0aGUgZmxvYXRpbmcgZWxlbWVudCB3aWxsIG1vdmUgdG9cbiAgLy8gdGhlIGRpc21pc3NhbCB0b3VjaCBwb2ludC5cbiAgY29uc3Qgb3BlbkNoZWNrID0gaXNNb3VzZUxpa2VQb2ludGVyVHlwZShwb2ludGVyVHlwZSkgPyBmbG9hdGluZyA6IG9wZW47XG4gIGNvbnN0IGFkZExpc3RlbmVyID0gUmVhY3QudXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgIC8vIEV4cGxpY2l0bHkgc3BlY2lmaWVkIGB4YC9geWAgY29vcmRpbmF0ZXMgc2hvdWxkbid0IGFkZCBhIGxpc3RlbmVyLlxuICAgIGlmICghb3BlbkNoZWNrIHx8ICFlbmFibGVkIHx8IHggIT0gbnVsbCB8fCB5ICE9IG51bGwpIHJldHVybjtcbiAgICBjb25zdCB3aW4gPSBnZXRXaW5kb3cocmVmcy5mbG9hdGluZy5jdXJyZW50KTtcbiAgICBmdW5jdGlvbiBoYW5kbGVNb3VzZU1vdmUoZXZlbnQpIHtcbiAgICAgIGNvbnN0IHRhcmdldCA9IGdldFRhcmdldChldmVudCk7XG4gICAgICBpZiAoIWNvbnRhaW5zKHJlZnMuZmxvYXRpbmcuY3VycmVudCwgdGFyZ2V0KSkge1xuICAgICAgICBzZXRSZWZlcmVuY2UoZXZlbnQuY2xpZW50WCwgZXZlbnQuY2xpZW50WSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3aW4ucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgaGFuZGxlTW91c2VNb3ZlKTtcbiAgICAgICAgY2xlYW51cExpc3RlbmVyUmVmLmN1cnJlbnQgPSBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIWRhdGFSZWYuY3VycmVudC5vcGVuRXZlbnQgfHwgaXNNb3VzZUJhc2VkRXZlbnQoZGF0YVJlZi5jdXJyZW50Lm9wZW5FdmVudCkpIHtcbiAgICAgIHdpbi5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBoYW5kbGVNb3VzZU1vdmUpO1xuICAgICAgY29uc3QgY2xlYW51cCA9ICgpID0+IHtcbiAgICAgICAgd2luLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIGhhbmRsZU1vdXNlTW92ZSk7XG4gICAgICAgIGNsZWFudXBMaXN0ZW5lclJlZi5jdXJyZW50ID0gbnVsbDtcbiAgICAgIH07XG4gICAgICBjbGVhbnVwTGlzdGVuZXJSZWYuY3VycmVudCA9IGNsZWFudXA7XG4gICAgICByZXR1cm4gY2xlYW51cDtcbiAgICB9XG4gICAgcmVmcy5zZXRQb3NpdGlvblJlZmVyZW5jZShyZWZzLmRvbVJlZmVyZW5jZS5jdXJyZW50KTtcbiAgfSwgW2RhdGFSZWYsIGVuYWJsZWQsIG9wZW5DaGVjaywgcmVmcywgc2V0UmVmZXJlbmNlLCB4LCB5XSk7XG5cbiAgLy8gYmlvbWUtaWdub3JlIGxpbnQvY29ycmVjdG5lc3MvdXNlRXhoYXVzdGl2ZURlcGVuZGVuY2llczogaW50ZW50aW9uYWxseSBzcGVjaWZ5aW5nIGByZWFjdGl2ZWBcbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICByZXR1cm4gYWRkTGlzdGVuZXIoKTtcbiAgfSwgW2FkZExpc3RlbmVyLCByZWFjdGl2ZV0pO1xuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChlbmFibGVkICYmICFmbG9hdGluZykge1xuICAgICAgaW5pdGlhbFJlZi5jdXJyZW50ID0gZmFsc2U7XG4gICAgfVxuICB9LCBbZW5hYmxlZCwgZmxvYXRpbmddKTtcbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoIWVuYWJsZWQgJiYgb3Blbikge1xuICAgICAgaW5pdGlhbFJlZi5jdXJyZW50ID0gdHJ1ZTtcbiAgICB9XG4gIH0sIFtlbmFibGVkLCBvcGVuXSk7XG4gIGluZGV4KCgpID0+IHtcbiAgICBpZiAoZW5hYmxlZCAmJiAoeCAhPSBudWxsIHx8IHkgIT0gbnVsbCkpIHtcbiAgICAgIGluaXRpYWxSZWYuY3VycmVudCA9IGZhbHNlO1xuICAgICAgc2V0UmVmZXJlbmNlKHgsIHkpO1xuICAgIH1cbiAgfSwgW2VuYWJsZWQsIHgsIHksIHNldFJlZmVyZW5jZV0pO1xuICByZXR1cm4gUmVhY3QudXNlTWVtbygoKSA9PiB7XG4gICAgaWYgKCFlbmFibGVkKSByZXR1cm4ge307XG4gICAgZnVuY3Rpb24gc2V0UG9pbnRlclR5cGVSZWYoX3JlZikge1xuICAgICAgbGV0IHtcbiAgICAgICAgcG9pbnRlclR5cGVcbiAgICAgIH0gPSBfcmVmO1xuICAgICAgc2V0UG9pbnRlclR5cGUocG9pbnRlclR5cGUpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgcmVmZXJlbmNlOiB7XG4gICAgICAgIG9uUG9pbnRlckRvd246IHNldFBvaW50ZXJUeXBlUmVmLFxuICAgICAgICBvblBvaW50ZXJFbnRlcjogc2V0UG9pbnRlclR5cGVSZWYsXG4gICAgICAgIG9uTW91c2VNb3ZlOiBoYW5kbGVSZWZlcmVuY2VFbnRlck9yTW92ZSxcbiAgICAgICAgb25Nb3VzZUVudGVyOiBoYW5kbGVSZWZlcmVuY2VFbnRlck9yTW92ZVxuICAgICAgfVxuICAgIH07XG4gIH0sIFtlbmFibGVkLCBoYW5kbGVSZWZlcmVuY2VFbnRlck9yTW92ZV0pO1xufVxuXG5jb25zdCBidWJibGVIYW5kbGVyS2V5cyA9IHtcbiAgcG9pbnRlcmRvd246ICdvblBvaW50ZXJEb3duJyxcbiAgbW91c2Vkb3duOiAnb25Nb3VzZURvd24nLFxuICBjbGljazogJ29uQ2xpY2snXG59O1xuY29uc3QgY2FwdHVyZUhhbmRsZXJLZXlzID0ge1xuICBwb2ludGVyZG93bjogJ29uUG9pbnRlckRvd25DYXB0dXJlJyxcbiAgbW91c2Vkb3duOiAnb25Nb3VzZURvd25DYXB0dXJlJyxcbiAgY2xpY2s6ICdvbkNsaWNrQ2FwdHVyZSdcbn07XG5jb25zdCBub3JtYWxpemVQcm9wID0gbm9ybWFsaXphYmxlID0+IHtcbiAgdmFyIF9ub3JtYWxpemFibGUkZXNjYXBlSywgX25vcm1hbGl6YWJsZSRvdXRzaWRlO1xuICByZXR1cm4ge1xuICAgIGVzY2FwZUtleTogdHlwZW9mIG5vcm1hbGl6YWJsZSA9PT0gJ2Jvb2xlYW4nID8gbm9ybWFsaXphYmxlIDogKF9ub3JtYWxpemFibGUkZXNjYXBlSyA9IG5vcm1hbGl6YWJsZSA9PSBudWxsID8gdm9pZCAwIDogbm9ybWFsaXphYmxlLmVzY2FwZUtleSkgIT0gbnVsbCA/IF9ub3JtYWxpemFibGUkZXNjYXBlSyA6IGZhbHNlLFxuICAgIG91dHNpZGVQcmVzczogdHlwZW9mIG5vcm1hbGl6YWJsZSA9PT0gJ2Jvb2xlYW4nID8gbm9ybWFsaXphYmxlIDogKF9ub3JtYWxpemFibGUkb3V0c2lkZSA9IG5vcm1hbGl6YWJsZSA9PSBudWxsID8gdm9pZCAwIDogbm9ybWFsaXphYmxlLm91dHNpZGVQcmVzcykgIT0gbnVsbCA/IF9ub3JtYWxpemFibGUkb3V0c2lkZSA6IHRydWVcbiAgfTtcbn07XG4vKipcbiAqIENsb3NlcyB0aGUgZmxvYXRpbmcgZWxlbWVudCB3aGVuIGEgZGlzbWlzc2FsIGlzIHJlcXVlc3RlZCDigJQgYnkgZGVmYXVsdCwgd2hlblxuICogdGhlIHVzZXIgcHJlc3NlcyB0aGUgYGVzY2FwZWAga2V5IG9yIG91dHNpZGUgb2YgdGhlIGZsb2F0aW5nIGVsZW1lbnQuXG4gKiBAc2VlIGh0dHBzOi8vZmxvYXRpbmctdWkuY29tL2RvY3MvdXNlRGlzbWlzc1xuICovXG5mdW5jdGlvbiB1c2VEaXNtaXNzKGNvbnRleHQsIHByb3BzKSB7XG4gIGlmIChwcm9wcyA9PT0gdm9pZCAwKSB7XG4gICAgcHJvcHMgPSB7fTtcbiAgfVxuICBjb25zdCB7XG4gICAgb3BlbixcbiAgICBvbk9wZW5DaGFuZ2UsXG4gICAgbm9kZUlkLFxuICAgIGVsZW1lbnRzOiB7XG4gICAgICByZWZlcmVuY2UsXG4gICAgICBkb21SZWZlcmVuY2UsXG4gICAgICBmbG9hdGluZ1xuICAgIH0sXG4gICAgZGF0YVJlZlxuICB9ID0gY29udGV4dDtcbiAgY29uc3Qge1xuICAgIGVuYWJsZWQgPSB0cnVlLFxuICAgIGVzY2FwZUtleSA9IHRydWUsXG4gICAgb3V0c2lkZVByZXNzOiB1bnN0YWJsZV9vdXRzaWRlUHJlc3MgPSB0cnVlLFxuICAgIG91dHNpZGVQcmVzc0V2ZW50ID0gJ3BvaW50ZXJkb3duJyxcbiAgICByZWZlcmVuY2VQcmVzcyA9IGZhbHNlLFxuICAgIHJlZmVyZW5jZVByZXNzRXZlbnQgPSAncG9pbnRlcmRvd24nLFxuICAgIGFuY2VzdG9yU2Nyb2xsID0gZmFsc2UsXG4gICAgYnViYmxlcyxcbiAgICBjYXB0dXJlXG4gIH0gPSBwcm9wcztcbiAgY29uc3QgdHJlZSA9IHVzZUZsb2F0aW5nVHJlZSgpO1xuICBjb25zdCBvdXRzaWRlUHJlc3NGbiA9IHVzZUVmZmVjdEV2ZW50KHR5cGVvZiB1bnN0YWJsZV9vdXRzaWRlUHJlc3MgPT09ICdmdW5jdGlvbicgPyB1bnN0YWJsZV9vdXRzaWRlUHJlc3MgOiAoKSA9PiBmYWxzZSk7XG4gIGNvbnN0IG91dHNpZGVQcmVzcyA9IHR5cGVvZiB1bnN0YWJsZV9vdXRzaWRlUHJlc3MgPT09ICdmdW5jdGlvbicgPyBvdXRzaWRlUHJlc3NGbiA6IHVuc3RhYmxlX291dHNpZGVQcmVzcztcbiAgY29uc3QgaW5zaWRlUmVhY3RUcmVlUmVmID0gUmVhY3QudXNlUmVmKGZhbHNlKTtcbiAgY29uc3QgZW5kZWRPclN0YXJ0ZWRJbnNpZGVSZWYgPSBSZWFjdC51c2VSZWYoZmFsc2UpO1xuICBjb25zdCB7XG4gICAgZXNjYXBlS2V5OiBlc2NhcGVLZXlCdWJibGVzLFxuICAgIG91dHNpZGVQcmVzczogb3V0c2lkZVByZXNzQnViYmxlc1xuICB9ID0gbm9ybWFsaXplUHJvcChidWJibGVzKTtcbiAgY29uc3Qge1xuICAgIGVzY2FwZUtleTogZXNjYXBlS2V5Q2FwdHVyZSxcbiAgICBvdXRzaWRlUHJlc3M6IG91dHNpZGVQcmVzc0NhcHR1cmVcbiAgfSA9IG5vcm1hbGl6ZVByb3AoY2FwdHVyZSk7XG4gIGNvbnN0IGNsb3NlT25Fc2NhcGVLZXlEb3duID0gdXNlRWZmZWN0RXZlbnQoZXZlbnQgPT4ge1xuICAgIGlmICghb3BlbiB8fCAhZW5hYmxlZCB8fCAhZXNjYXBlS2V5IHx8IGV2ZW50LmtleSAhPT0gJ0VzY2FwZScpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgY2hpbGRyZW4gPSB0cmVlID8gZ2V0Q2hpbGRyZW4odHJlZS5ub2Rlc1JlZi5jdXJyZW50LCBub2RlSWQpIDogW107XG4gICAgaWYgKCFlc2NhcGVLZXlCdWJibGVzKSB7XG4gICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgIGlmIChjaGlsZHJlbi5sZW5ndGggPiAwKSB7XG4gICAgICAgIGxldCBzaG91bGREaXNtaXNzID0gdHJ1ZTtcbiAgICAgICAgY2hpbGRyZW4uZm9yRWFjaChjaGlsZCA9PiB7XG4gICAgICAgICAgdmFyIF9jaGlsZCRjb250ZXh0O1xuICAgICAgICAgIGlmICgoX2NoaWxkJGNvbnRleHQgPSBjaGlsZC5jb250ZXh0KSAhPSBudWxsICYmIF9jaGlsZCRjb250ZXh0Lm9wZW4gJiYgIWNoaWxkLmNvbnRleHQuZGF0YVJlZi5jdXJyZW50Ll9fZXNjYXBlS2V5QnViYmxlcykge1xuICAgICAgICAgICAgc2hvdWxkRGlzbWlzcyA9IGZhbHNlO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGlmICghc2hvdWxkRGlzbWlzcykge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBvbk9wZW5DaGFuZ2UoZmFsc2UsIGlzUmVhY3RFdmVudChldmVudCkgPyBldmVudC5uYXRpdmVFdmVudCA6IGV2ZW50LCAnZXNjYXBlLWtleScpO1xuICB9KTtcbiAgY29uc3QgY2xvc2VPbkVzY2FwZUtleURvd25DYXB0dXJlID0gdXNlRWZmZWN0RXZlbnQoZXZlbnQgPT4ge1xuICAgIHZhciBfZ2V0VGFyZ2V0MjtcbiAgICBjb25zdCBjYWxsYmFjayA9ICgpID0+IHtcbiAgICAgIHZhciBfZ2V0VGFyZ2V0O1xuICAgICAgY2xvc2VPbkVzY2FwZUtleURvd24oZXZlbnQpO1xuICAgICAgKF9nZXRUYXJnZXQgPSBnZXRUYXJnZXQoZXZlbnQpKSA9PSBudWxsIHx8IF9nZXRUYXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIGNhbGxiYWNrKTtcbiAgICB9O1xuICAgIChfZ2V0VGFyZ2V0MiA9IGdldFRhcmdldChldmVudCkpID09IG51bGwgfHwgX2dldFRhcmdldDIuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIGNhbGxiYWNrKTtcbiAgfSk7XG4gIGNvbnN0IGNsb3NlT25QcmVzc091dHNpZGUgPSB1c2VFZmZlY3RFdmVudChldmVudCA9PiB7XG4gICAgLy8gR2l2ZW4gZGV2ZWxvcGVycyBjYW4gc3RvcCB0aGUgcHJvcGFnYXRpb24gb2YgdGhlIHN5bnRoZXRpYyBldmVudCxcbiAgICAvLyB3ZSBjYW4gb25seSBiZSBjb25maWRlbnQgd2l0aCBhIHBvc2l0aXZlIHZhbHVlLlxuICAgIGNvbnN0IGluc2lkZVJlYWN0VHJlZSA9IGluc2lkZVJlYWN0VHJlZVJlZi5jdXJyZW50O1xuICAgIGluc2lkZVJlYWN0VHJlZVJlZi5jdXJyZW50ID0gZmFsc2U7XG5cbiAgICAvLyBXaGVuIGNsaWNrIG91dHNpZGUgaXMgbGF6eSAoYGNsaWNrYCBldmVudCksIGhhbmRsZSBkcmFnZ2luZy5cbiAgICAvLyBEb24ndCBjbG9zZSBpZjpcbiAgICAvLyAtIFRoZSBjbGljayBzdGFydGVkIGluc2lkZSB0aGUgZmxvYXRpbmcgZWxlbWVudC5cbiAgICAvLyAtIFRoZSBjbGljayBlbmRlZCBpbnNpZGUgdGhlIGZsb2F0aW5nIGVsZW1lbnQuXG4gICAgY29uc3QgZW5kZWRPclN0YXJ0ZWRJbnNpZGUgPSBlbmRlZE9yU3RhcnRlZEluc2lkZVJlZi5jdXJyZW50O1xuICAgIGVuZGVkT3JTdGFydGVkSW5zaWRlUmVmLmN1cnJlbnQgPSBmYWxzZTtcbiAgICBpZiAob3V0c2lkZVByZXNzRXZlbnQgPT09ICdjbGljaycgJiYgZW5kZWRPclN0YXJ0ZWRJbnNpZGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGluc2lkZVJlYWN0VHJlZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIG91dHNpZGVQcmVzcyA9PT0gJ2Z1bmN0aW9uJyAmJiAhb3V0c2lkZVByZXNzKGV2ZW50KSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB0YXJnZXQgPSBnZXRUYXJnZXQoZXZlbnQpO1xuICAgIGNvbnN0IGluZXJ0U2VsZWN0b3IgPSBcIltcIiArIGNyZWF0ZUF0dHJpYnV0ZSgnaW5lcnQnKSArIFwiXVwiO1xuICAgIGNvbnN0IG1hcmtlcnMgPSBnZXREb2N1bWVudChmbG9hdGluZykucXVlcnlTZWxlY3RvckFsbChpbmVydFNlbGVjdG9yKTtcbiAgICBsZXQgdGFyZ2V0Um9vdEFuY2VzdG9yID0gaXNFbGVtZW50KHRhcmdldCkgPyB0YXJnZXQgOiBudWxsO1xuICAgIHdoaWxlICh0YXJnZXRSb290QW5jZXN0b3IgJiYgIWlzTGFzdFRyYXZlcnNhYmxlTm9kZSh0YXJnZXRSb290QW5jZXN0b3IpKSB7XG4gICAgICBjb25zdCBuZXh0UGFyZW50ID0gZ2V0UGFyZW50Tm9kZSh0YXJnZXRSb290QW5jZXN0b3IpO1xuICAgICAgaWYgKGlzTGFzdFRyYXZlcnNhYmxlTm9kZShuZXh0UGFyZW50KSB8fCAhaXNFbGVtZW50KG5leHRQYXJlbnQpKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgdGFyZ2V0Um9vdEFuY2VzdG9yID0gbmV4dFBhcmVudDtcbiAgICB9XG5cbiAgICAvLyBDaGVjayBpZiB0aGUgY2xpY2sgb2NjdXJyZWQgb24gYSB0aGlyZC1wYXJ0eSBlbGVtZW50IGluamVjdGVkIGFmdGVyIHRoZVxuICAgIC8vIGZsb2F0aW5nIGVsZW1lbnQgcmVuZGVyZWQuXG4gICAgaWYgKG1hcmtlcnMubGVuZ3RoICYmIGlzRWxlbWVudCh0YXJnZXQpICYmICFpc1Jvb3RFbGVtZW50KHRhcmdldCkgJiZcbiAgICAvLyBDbGlja2VkIG9uIGEgZGlyZWN0IGFuY2VzdG9yIChlLmcuIEZsb2F0aW5nT3ZlcmxheSkuXG4gICAgIWNvbnRhaW5zKHRhcmdldCwgZmxvYXRpbmcpICYmXG4gICAgLy8gSWYgdGhlIHRhcmdldCByb290IGVsZW1lbnQgY29udGFpbnMgbm9uZSBvZiB0aGUgbWFya2VycywgdGhlbiB0aGVcbiAgICAvLyBlbGVtZW50IHdhcyBpbmplY3RlZCBhZnRlciB0aGUgZmxvYXRpbmcgZWxlbWVudCByZW5kZXJlZC5cbiAgICBBcnJheS5mcm9tKG1hcmtlcnMpLmV2ZXJ5KG1hcmtlciA9PiAhY29udGFpbnModGFyZ2V0Um9vdEFuY2VzdG9yLCBtYXJrZXIpKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIENoZWNrIGlmIHRoZSBjbGljayBvY2N1cnJlZCBvbiB0aGUgc2Nyb2xsYmFyXG4gICAgaWYgKGlzSFRNTEVsZW1lbnQodGFyZ2V0KSAmJiBmbG9hdGluZykge1xuICAgICAgLy8gSW4gRmlyZWZveCwgYHRhcmdldC5zY3JvbGxXaWR0aCA+IHRhcmdldC5jbGllbnRXaWR0aGAgZm9yIGlubGluZVxuICAgICAgLy8gZWxlbWVudHMuXG4gICAgICBjb25zdCBjYW5TY3JvbGxYID0gdGFyZ2V0LmNsaWVudFdpZHRoID4gMCAmJiB0YXJnZXQuc2Nyb2xsV2lkdGggPiB0YXJnZXQuY2xpZW50V2lkdGg7XG4gICAgICBjb25zdCBjYW5TY3JvbGxZID0gdGFyZ2V0LmNsaWVudEhlaWdodCA+IDAgJiYgdGFyZ2V0LnNjcm9sbEhlaWdodCA+IHRhcmdldC5jbGllbnRIZWlnaHQ7XG4gICAgICBsZXQgeENvbmQgPSBjYW5TY3JvbGxZICYmIGV2ZW50Lm9mZnNldFggPiB0YXJnZXQuY2xpZW50V2lkdGg7XG5cbiAgICAgIC8vIEluIHNvbWUgYnJvd3NlcnMgaXQgaXMgcG9zc2libGUgdG8gY2hhbmdlIHRoZSA8Ym9keT4gKG9yIHdpbmRvdylcbiAgICAgIC8vIHNjcm9sbGJhciB0byB0aGUgbGVmdCBzaWRlLCBidXQgaXMgdmVyeSByYXJlIGFuZCBpcyBkaWZmaWN1bHQgdG9cbiAgICAgIC8vIGNoZWNrIGZvci4gUGx1cywgZm9yIG1vZGFsIGRpYWxvZ3Mgd2l0aCBiYWNrZHJvcHMsIGl0IGlzIG1vcmVcbiAgICAgIC8vIGltcG9ydGFudCB0aGF0IHRoZSBiYWNrZHJvcCBpcyBjaGVja2VkIGJ1dCBub3Qgc28gbXVjaCB0aGUgd2luZG93LlxuICAgICAgaWYgKGNhblNjcm9sbFkpIHtcbiAgICAgICAgY29uc3QgaXNSVEwgPSBnZXRDb21wdXRlZFN0eWxlKHRhcmdldCkuZGlyZWN0aW9uID09PSAncnRsJztcbiAgICAgICAgaWYgKGlzUlRMKSB7XG4gICAgICAgICAgeENvbmQgPSBldmVudC5vZmZzZXRYIDw9IHRhcmdldC5vZmZzZXRXaWR0aCAtIHRhcmdldC5jbGllbnRXaWR0aDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHhDb25kIHx8IGNhblNjcm9sbFggJiYgZXZlbnQub2Zmc2V0WSA+IHRhcmdldC5jbGllbnRIZWlnaHQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCB0YXJnZXRJc0luc2lkZUNoaWxkcmVuID0gdHJlZSAmJiBnZXRDaGlsZHJlbih0cmVlLm5vZGVzUmVmLmN1cnJlbnQsIG5vZGVJZCkuc29tZShub2RlID0+IHtcbiAgICAgIHZhciBfbm9kZSRjb250ZXh0O1xuICAgICAgcmV0dXJuIGlzRXZlbnRUYXJnZXRXaXRoaW4oZXZlbnQsIChfbm9kZSRjb250ZXh0ID0gbm9kZS5jb250ZXh0KSA9PSBudWxsID8gdm9pZCAwIDogX25vZGUkY29udGV4dC5lbGVtZW50cy5mbG9hdGluZyk7XG4gICAgfSk7XG4gICAgaWYgKGlzRXZlbnRUYXJnZXRXaXRoaW4oZXZlbnQsIGZsb2F0aW5nKSB8fCBpc0V2ZW50VGFyZ2V0V2l0aGluKGV2ZW50LCBkb21SZWZlcmVuY2UpIHx8IHRhcmdldElzSW5zaWRlQ2hpbGRyZW4pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgY2hpbGRyZW4gPSB0cmVlID8gZ2V0Q2hpbGRyZW4odHJlZS5ub2Rlc1JlZi5jdXJyZW50LCBub2RlSWQpIDogW107XG4gICAgaWYgKGNoaWxkcmVuLmxlbmd0aCA+IDApIHtcbiAgICAgIGxldCBzaG91bGREaXNtaXNzID0gdHJ1ZTtcbiAgICAgIGNoaWxkcmVuLmZvckVhY2goY2hpbGQgPT4ge1xuICAgICAgICB2YXIgX2NoaWxkJGNvbnRleHQyO1xuICAgICAgICBpZiAoKF9jaGlsZCRjb250ZXh0MiA9IGNoaWxkLmNvbnRleHQpICE9IG51bGwgJiYgX2NoaWxkJGNvbnRleHQyLm9wZW4gJiYgIWNoaWxkLmNvbnRleHQuZGF0YVJlZi5jdXJyZW50Ll9fb3V0c2lkZVByZXNzQnViYmxlcykge1xuICAgICAgICAgIHNob3VsZERpc21pc3MgPSBmYWxzZTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgaWYgKCFzaG91bGREaXNtaXNzKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgb25PcGVuQ2hhbmdlKGZhbHNlLCBldmVudCwgJ291dHNpZGUtcHJlc3MnKTtcbiAgfSk7XG4gIGNvbnN0IGNsb3NlT25QcmVzc091dHNpZGVDYXB0dXJlID0gdXNlRWZmZWN0RXZlbnQoZXZlbnQgPT4ge1xuICAgIHZhciBfZ2V0VGFyZ2V0NDtcbiAgICBjb25zdCBjYWxsYmFjayA9ICgpID0+IHtcbiAgICAgIHZhciBfZ2V0VGFyZ2V0MztcbiAgICAgIGNsb3NlT25QcmVzc091dHNpZGUoZXZlbnQpO1xuICAgICAgKF9nZXRUYXJnZXQzID0gZ2V0VGFyZ2V0KGV2ZW50KSkgPT0gbnVsbCB8fCBfZ2V0VGFyZ2V0My5yZW1vdmVFdmVudExpc3RlbmVyKG91dHNpZGVQcmVzc0V2ZW50LCBjYWxsYmFjayk7XG4gICAgfTtcbiAgICAoX2dldFRhcmdldDQgPSBnZXRUYXJnZXQoZXZlbnQpKSA9PSBudWxsIHx8IF9nZXRUYXJnZXQ0LmFkZEV2ZW50TGlzdGVuZXIob3V0c2lkZVByZXNzRXZlbnQsIGNhbGxiYWNrKTtcbiAgfSk7XG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKCFvcGVuIHx8ICFlbmFibGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGRhdGFSZWYuY3VycmVudC5fX2VzY2FwZUtleUJ1YmJsZXMgPSBlc2NhcGVLZXlCdWJibGVzO1xuICAgIGRhdGFSZWYuY3VycmVudC5fX291dHNpZGVQcmVzc0J1YmJsZXMgPSBvdXRzaWRlUHJlc3NCdWJibGVzO1xuICAgIGZ1bmN0aW9uIG9uU2Nyb2xsKGV2ZW50KSB7XG4gICAgICBvbk9wZW5DaGFuZ2UoZmFsc2UsIGV2ZW50LCAnYW5jZXN0b3Itc2Nyb2xsJyk7XG4gICAgfVxuICAgIGNvbnN0IGRvYyA9IGdldERvY3VtZW50KGZsb2F0aW5nKTtcbiAgICBlc2NhcGVLZXkgJiYgZG9jLmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCBlc2NhcGVLZXlDYXB0dXJlID8gY2xvc2VPbkVzY2FwZUtleURvd25DYXB0dXJlIDogY2xvc2VPbkVzY2FwZUtleURvd24sIGVzY2FwZUtleUNhcHR1cmUpO1xuICAgIG91dHNpZGVQcmVzcyAmJiBkb2MuYWRkRXZlbnRMaXN0ZW5lcihvdXRzaWRlUHJlc3NFdmVudCwgb3V0c2lkZVByZXNzQ2FwdHVyZSA/IGNsb3NlT25QcmVzc091dHNpZGVDYXB0dXJlIDogY2xvc2VPblByZXNzT3V0c2lkZSwgb3V0c2lkZVByZXNzQ2FwdHVyZSk7XG4gICAgbGV0IGFuY2VzdG9ycyA9IFtdO1xuICAgIGlmIChhbmNlc3RvclNjcm9sbCkge1xuICAgICAgaWYgKGlzRWxlbWVudChkb21SZWZlcmVuY2UpKSB7XG4gICAgICAgIGFuY2VzdG9ycyA9IGdldE92ZXJmbG93QW5jZXN0b3JzKGRvbVJlZmVyZW5jZSk7XG4gICAgICB9XG4gICAgICBpZiAoaXNFbGVtZW50KGZsb2F0aW5nKSkge1xuICAgICAgICBhbmNlc3RvcnMgPSBhbmNlc3RvcnMuY29uY2F0KGdldE92ZXJmbG93QW5jZXN0b3JzKGZsb2F0aW5nKSk7XG4gICAgICB9XG4gICAgICBpZiAoIWlzRWxlbWVudChyZWZlcmVuY2UpICYmIHJlZmVyZW5jZSAmJiByZWZlcmVuY2UuY29udGV4dEVsZW1lbnQpIHtcbiAgICAgICAgYW5jZXN0b3JzID0gYW5jZXN0b3JzLmNvbmNhdChnZXRPdmVyZmxvd0FuY2VzdG9ycyhyZWZlcmVuY2UuY29udGV4dEVsZW1lbnQpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBJZ25vcmUgdGhlIHZpc3VhbCB2aWV3cG9ydCBmb3Igc2Nyb2xsaW5nIGRpc21pc3NhbCAoYWxsb3cgcGluY2gtem9vbSlcbiAgICBhbmNlc3RvcnMgPSBhbmNlc3RvcnMuZmlsdGVyKGFuY2VzdG9yID0+IHtcbiAgICAgIHZhciBfZG9jJGRlZmF1bHRWaWV3O1xuICAgICAgcmV0dXJuIGFuY2VzdG9yICE9PSAoKF9kb2MkZGVmYXVsdFZpZXcgPSBkb2MuZGVmYXVsdFZpZXcpID09IG51bGwgPyB2b2lkIDAgOiBfZG9jJGRlZmF1bHRWaWV3LnZpc3VhbFZpZXdwb3J0KTtcbiAgICB9KTtcbiAgICBhbmNlc3RvcnMuZm9yRWFjaChhbmNlc3RvciA9PiB7XG4gICAgICBhbmNlc3Rvci5hZGRFdmVudExpc3RlbmVyKCdzY3JvbGwnLCBvblNjcm9sbCwge1xuICAgICAgICBwYXNzaXZlOiB0cnVlXG4gICAgICB9KTtcbiAgICB9KTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgZXNjYXBlS2V5ICYmIGRvYy5yZW1vdmVFdmVudExpc3RlbmVyKCdrZXlkb3duJywgZXNjYXBlS2V5Q2FwdHVyZSA/IGNsb3NlT25Fc2NhcGVLZXlEb3duQ2FwdHVyZSA6IGNsb3NlT25Fc2NhcGVLZXlEb3duLCBlc2NhcGVLZXlDYXB0dXJlKTtcbiAgICAgIG91dHNpZGVQcmVzcyAmJiBkb2MucmVtb3ZlRXZlbnRMaXN0ZW5lcihvdXRzaWRlUHJlc3NFdmVudCwgb3V0c2lkZVByZXNzQ2FwdHVyZSA/IGNsb3NlT25QcmVzc091dHNpZGVDYXB0dXJlIDogY2xvc2VPblByZXNzT3V0c2lkZSwgb3V0c2lkZVByZXNzQ2FwdHVyZSk7XG4gICAgICBhbmNlc3RvcnMuZm9yRWFjaChhbmNlc3RvciA9PiB7XG4gICAgICAgIGFuY2VzdG9yLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIG9uU2Nyb2xsKTtcbiAgICAgIH0pO1xuICAgIH07XG4gIH0sIFtkYXRhUmVmLCBmbG9hdGluZywgZG9tUmVmZXJlbmNlLCByZWZlcmVuY2UsIGVzY2FwZUtleSwgb3V0c2lkZVByZXNzLCBvdXRzaWRlUHJlc3NFdmVudCwgb3Blbiwgb25PcGVuQ2hhbmdlLCBhbmNlc3RvclNjcm9sbCwgZW5hYmxlZCwgZXNjYXBlS2V5QnViYmxlcywgb3V0c2lkZVByZXNzQnViYmxlcywgY2xvc2VPbkVzY2FwZUtleURvd24sIGVzY2FwZUtleUNhcHR1cmUsIGNsb3NlT25Fc2NhcGVLZXlEb3duQ2FwdHVyZSwgY2xvc2VPblByZXNzT3V0c2lkZSwgb3V0c2lkZVByZXNzQ2FwdHVyZSwgY2xvc2VPblByZXNzT3V0c2lkZUNhcHR1cmVdKTtcblxuICAvLyBiaW9tZS1pZ25vcmUgbGludC9jb3JyZWN0bmVzcy91c2VFeGhhdXN0aXZlRGVwZW5kZW5jaWVzOiBpbnRlbnRpb25hbFxuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGluc2lkZVJlYWN0VHJlZVJlZi5jdXJyZW50ID0gZmFsc2U7XG4gIH0sIFtvdXRzaWRlUHJlc3MsIG91dHNpZGVQcmVzc0V2ZW50XSk7XG4gIHJldHVybiBSZWFjdC51c2VNZW1vKCgpID0+IHtcbiAgICBpZiAoIWVuYWJsZWQpIHtcbiAgICAgIHJldHVybiB7fTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHJlZmVyZW5jZToge1xuICAgICAgICBvbktleURvd246IGNsb3NlT25Fc2NhcGVLZXlEb3duLFxuICAgICAgICBbYnViYmxlSGFuZGxlcktleXNbcmVmZXJlbmNlUHJlc3NFdmVudF1dOiBldmVudCA9PiB7XG4gICAgICAgICAgaWYgKHJlZmVyZW5jZVByZXNzKSB7XG4gICAgICAgICAgICBvbk9wZW5DaGFuZ2UoZmFsc2UsIGV2ZW50Lm5hdGl2ZUV2ZW50LCAncmVmZXJlbmNlLXByZXNzJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgZmxvYXRpbmc6IHtcbiAgICAgICAgb25LZXlEb3duOiBjbG9zZU9uRXNjYXBlS2V5RG93bixcbiAgICAgICAgb25Nb3VzZURvd24oKSB7XG4gICAgICAgICAgZW5kZWRPclN0YXJ0ZWRJbnNpZGVSZWYuY3VycmVudCA9IHRydWU7XG4gICAgICAgIH0sXG4gICAgICAgIG9uTW91c2VVcCgpIHtcbiAgICAgICAgICBlbmRlZE9yU3RhcnRlZEluc2lkZVJlZi5jdXJyZW50ID0gdHJ1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgW2NhcHR1cmVIYW5kbGVyS2V5c1tvdXRzaWRlUHJlc3NFdmVudF1dOiAoKSA9PiB7XG4gICAgICAgICAgaW5zaWRlUmVhY3RUcmVlUmVmLmN1cnJlbnQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgfSwgW2VuYWJsZWQsIHJlZmVyZW5jZVByZXNzLCBvdXRzaWRlUHJlc3NFdmVudCwgcmVmZXJlbmNlUHJlc3NFdmVudCwgb25PcGVuQ2hhbmdlLCBjbG9zZU9uRXNjYXBlS2V5RG93bl0pO1xufVxuXG5sZXQgZGV2TWVzc2FnZVNldDtcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgZGV2TWVzc2FnZVNldCA9IC8qI19fUFVSRV9fKi9uZXcgU2V0KCk7XG59XG5cbi8qKlxuICogUHJvdmlkZXMgZGF0YSB0byBwb3NpdGlvbiBhIGZsb2F0aW5nIGVsZW1lbnQgYW5kIGNvbnRleHQgdG8gYWRkIGludGVyYWN0aW9ucy5cbiAqIEBzZWUgaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy91c2VGbG9hdGluZ1xuICovXG5mdW5jdGlvbiB1c2VGbG9hdGluZyhvcHRpb25zKSB7XG4gIHZhciBfb3B0aW9ucyRlbGVtZW50czI7XG4gIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICBvcHRpb25zID0ge307XG4gIH1cbiAgY29uc3Qge1xuICAgIG9wZW4gPSBmYWxzZSxcbiAgICBvbk9wZW5DaGFuZ2U6IHVuc3RhYmxlX29uT3BlbkNoYW5nZSxcbiAgICBub2RlSWRcbiAgfSA9IG9wdGlvbnM7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICB2YXIgX29wdGlvbnMkZWxlbWVudHM7XG4gICAgY29uc3QgZXJyID0gJ0Zsb2F0aW5nIFVJOiBDYW5ub3QgcGFzcyBhIHZpcnR1YWwgZWxlbWVudCB0byB0aGUgJyArICdgZWxlbWVudHMucmVmZXJlbmNlYCBvcHRpb24sIGFzIGl0IG11c3QgYmUgYSByZWFsIERPTSBlbGVtZW50LiAnICsgJ1VzZSBgcmVmcy5zZXRQb3NpdGlvblJlZmVyZW5jZWAgaW5zdGVhZC4nO1xuICAgIGlmICgoX29wdGlvbnMkZWxlbWVudHMgPSBvcHRpb25zLmVsZW1lbnRzKSAhPSBudWxsICYmIF9vcHRpb25zJGVsZW1lbnRzLnJlZmVyZW5jZSAmJiAhaXNFbGVtZW50KG9wdGlvbnMuZWxlbWVudHMucmVmZXJlbmNlKSkge1xuICAgICAgdmFyIF9kZXZNZXNzYWdlU2V0O1xuICAgICAgaWYgKCEoKF9kZXZNZXNzYWdlU2V0ID0gZGV2TWVzc2FnZVNldCkgIT0gbnVsbCAmJiBfZGV2TWVzc2FnZVNldC5oYXMoZXJyKSkpIHtcbiAgICAgICAgdmFyIF9kZXZNZXNzYWdlU2V0MjtcbiAgICAgICAgKF9kZXZNZXNzYWdlU2V0MiA9IGRldk1lc3NhZ2VTZXQpID09IG51bGwgfHwgX2Rldk1lc3NhZ2VTZXQyLmFkZChlcnIpO1xuICAgICAgICBjb25zb2xlLmVycm9yKGVycik7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGNvbnN0IFtfZG9tUmVmZXJlbmNlLCBzZXREb21SZWZlcmVuY2VdID0gUmVhY3QudXNlU3RhdGUobnVsbCk7XG4gIGNvbnN0IGRvbVJlZmVyZW5jZSA9ICgoX29wdGlvbnMkZWxlbWVudHMyID0gb3B0aW9ucy5lbGVtZW50cykgPT0gbnVsbCA/IHZvaWQgMCA6IF9vcHRpb25zJGVsZW1lbnRzMi5yZWZlcmVuY2UpIHx8IF9kb21SZWZlcmVuY2U7XG4gIGNvbnN0IHBvc2l0aW9uID0gdXNlRmxvYXRpbmckMShvcHRpb25zKTtcbiAgY29uc3QgdHJlZSA9IHVzZUZsb2F0aW5nVHJlZSgpO1xuICBjb25zdCBuZXN0ZWQgPSB1c2VGbG9hdGluZ1BhcmVudE5vZGVJZCgpICE9IG51bGw7XG4gIGNvbnN0IG9uT3BlbkNoYW5nZSA9IHVzZUVmZmVjdEV2ZW50KChvcGVuLCBldmVudCwgcmVhc29uKSA9PiB7XG4gICAgaWYgKG9wZW4pIHtcbiAgICAgIGRhdGFSZWYuY3VycmVudC5vcGVuRXZlbnQgPSBldmVudDtcbiAgICB9XG4gICAgZXZlbnRzLmVtaXQoJ29wZW5jaGFuZ2UnLCB7XG4gICAgICBvcGVuLFxuICAgICAgZXZlbnQsXG4gICAgICByZWFzb24sXG4gICAgICBuZXN0ZWRcbiAgICB9KTtcbiAgICB1bnN0YWJsZV9vbk9wZW5DaGFuZ2UgPT0gbnVsbCB8fCB1bnN0YWJsZV9vbk9wZW5DaGFuZ2Uob3BlbiwgZXZlbnQsIHJlYXNvbik7XG4gIH0pO1xuICBjb25zdCBkb21SZWZlcmVuY2VSZWYgPSBSZWFjdC51c2VSZWYobnVsbCk7XG4gIGNvbnN0IGRhdGFSZWYgPSBSZWFjdC51c2VSZWYoe30pO1xuICBjb25zdCBldmVudHMgPSBSZWFjdC51c2VTdGF0ZSgoKSA9PiBjcmVhdGVQdWJTdWIoKSlbMF07XG4gIGNvbnN0IGZsb2F0aW5nSWQgPSB1c2VJZCgpO1xuICBjb25zdCBzZXRQb3NpdGlvblJlZmVyZW5jZSA9IFJlYWN0LnVzZUNhbGxiYWNrKG5vZGUgPT4ge1xuICAgIGNvbnN0IHBvc2l0aW9uUmVmZXJlbmNlID0gaXNFbGVtZW50KG5vZGUpID8ge1xuICAgICAgZ2V0Qm91bmRpbmdDbGllbnRSZWN0OiAoKSA9PiBub2RlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLFxuICAgICAgY29udGV4dEVsZW1lbnQ6IG5vZGVcbiAgICB9IDogbm9kZTtcbiAgICBwb3NpdGlvbi5yZWZzLnNldFJlZmVyZW5jZShwb3NpdGlvblJlZmVyZW5jZSk7XG4gIH0sIFtwb3NpdGlvbi5yZWZzXSk7XG4gIGNvbnN0IHNldFJlZmVyZW5jZSA9IFJlYWN0LnVzZUNhbGxiYWNrKG5vZGUgPT4ge1xuICAgIGlmIChpc0VsZW1lbnQobm9kZSkgfHwgbm9kZSA9PT0gbnVsbCkge1xuICAgICAgZG9tUmVmZXJlbmNlUmVmLmN1cnJlbnQgPSBub2RlO1xuICAgICAgc2V0RG9tUmVmZXJlbmNlKG5vZGUpO1xuICAgIH1cblxuICAgIC8vIEJhY2t3YXJkcy1jb21wYXRpYmlsaXR5IGZvciBwYXNzaW5nIGEgdmlydHVhbCBlbGVtZW50IHRvIGByZWZlcmVuY2VgXG4gICAgLy8gYWZ0ZXIgaXQgaGFzIHNldCB0aGUgRE9NIHJlZmVyZW5jZS5cbiAgICBpZiAoaXNFbGVtZW50KHBvc2l0aW9uLnJlZnMucmVmZXJlbmNlLmN1cnJlbnQpIHx8IHBvc2l0aW9uLnJlZnMucmVmZXJlbmNlLmN1cnJlbnQgPT09IG51bGwgfHxcbiAgICAvLyBEb24ndCBhbGxvdyBzZXR0aW5nIHZpcnR1YWwgZWxlbWVudHMgdXNpbmcgdGhlIG9sZCB0ZWNobmlxdWUgYmFjayB0b1xuICAgIC8vIGBudWxsYCB0byBzdXBwb3J0IGBwb3NpdGlvblJlZmVyZW5jZWAgKyBhbiB1bnN0YWJsZSBgcmVmZXJlbmNlYFxuICAgIC8vIGNhbGxiYWNrIHJlZi5cbiAgICBub2RlICE9PSBudWxsICYmICFpc0VsZW1lbnQobm9kZSkpIHtcbiAgICAgIHBvc2l0aW9uLnJlZnMuc2V0UmVmZXJlbmNlKG5vZGUpO1xuICAgIH1cbiAgfSwgW3Bvc2l0aW9uLnJlZnNdKTtcbiAgY29uc3QgcmVmcyA9IFJlYWN0LnVzZU1lbW8oKCkgPT4gKHtcbiAgICAuLi5wb3NpdGlvbi5yZWZzLFxuICAgIHNldFJlZmVyZW5jZSxcbiAgICBzZXRQb3NpdGlvblJlZmVyZW5jZSxcbiAgICBkb21SZWZlcmVuY2U6IGRvbVJlZmVyZW5jZVJlZlxuICB9KSwgW3Bvc2l0aW9uLnJlZnMsIHNldFJlZmVyZW5jZSwgc2V0UG9zaXRpb25SZWZlcmVuY2VdKTtcbiAgY29uc3QgZWxlbWVudHMgPSBSZWFjdC51c2VNZW1vKCgpID0+ICh7XG4gICAgLi4ucG9zaXRpb24uZWxlbWVudHMsXG4gICAgZG9tUmVmZXJlbmNlOiBkb21SZWZlcmVuY2VcbiAgfSksIFtwb3NpdGlvbi5lbGVtZW50cywgZG9tUmVmZXJlbmNlXSk7XG4gIGNvbnN0IGNvbnRleHQgPSBSZWFjdC51c2VNZW1vKCgpID0+ICh7XG4gICAgLi4ucG9zaXRpb24sXG4gICAgcmVmcyxcbiAgICBlbGVtZW50cyxcbiAgICBkYXRhUmVmLFxuICAgIG5vZGVJZCxcbiAgICBmbG9hdGluZ0lkLFxuICAgIGV2ZW50cyxcbiAgICBvcGVuLFxuICAgIG9uT3BlbkNoYW5nZVxuICB9KSwgW3Bvc2l0aW9uLCBub2RlSWQsIGZsb2F0aW5nSWQsIGV2ZW50cywgb3Blbiwgb25PcGVuQ2hhbmdlLCByZWZzLCBlbGVtZW50c10pO1xuICBpbmRleCgoKSA9PiB7XG4gICAgY29uc3Qgbm9kZSA9IHRyZWUgPT0gbnVsbCA/IHZvaWQgMCA6IHRyZWUubm9kZXNSZWYuY3VycmVudC5maW5kKG5vZGUgPT4gbm9kZS5pZCA9PT0gbm9kZUlkKTtcbiAgICBpZiAobm9kZSkge1xuICAgICAgbm9kZS5jb250ZXh0ID0gY29udGV4dDtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gUmVhY3QudXNlTWVtbygoKSA9PiAoe1xuICAgIC4uLnBvc2l0aW9uLFxuICAgIGNvbnRleHQsXG4gICAgcmVmcyxcbiAgICBlbGVtZW50c1xuICB9KSwgW3Bvc2l0aW9uLCByZWZzLCBlbGVtZW50cywgY29udGV4dF0pO1xufVxuXG4vKipcbiAqIE9wZW5zIHRoZSBmbG9hdGluZyBlbGVtZW50IHdoaWxlIHRoZSByZWZlcmVuY2UgZWxlbWVudCBoYXMgZm9jdXMsIGxpa2UgQ1NTXG4gKiBgOmZvY3VzYC5cbiAqIEBzZWUgaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy91c2VGb2N1c1xuICovXG5mdW5jdGlvbiB1c2VGb2N1cyhjb250ZXh0LCBwcm9wcykge1xuICBpZiAocHJvcHMgPT09IHZvaWQgMCkge1xuICAgIHByb3BzID0ge307XG4gIH1cbiAgY29uc3Qge1xuICAgIG9wZW4sXG4gICAgb25PcGVuQ2hhbmdlLFxuICAgIGV2ZW50cyxcbiAgICByZWZzLFxuICAgIGVsZW1lbnRzOiB7XG4gICAgICBkb21SZWZlcmVuY2VcbiAgICB9XG4gIH0gPSBjb250ZXh0O1xuICBjb25zdCB7XG4gICAgZW5hYmxlZCA9IHRydWUsXG4gICAgdmlzaWJsZU9ubHkgPSB0cnVlXG4gIH0gPSBwcm9wcztcbiAgY29uc3QgYmxvY2tGb2N1c1JlZiA9IFJlYWN0LnVzZVJlZihmYWxzZSk7XG4gIGNvbnN0IHRpbWVvdXRSZWYgPSBSZWFjdC51c2VSZWYoKTtcbiAgY29uc3Qga2V5Ym9hcmRNb2RhbGl0eVJlZiA9IFJlYWN0LnVzZVJlZih0cnVlKTtcbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoIWVuYWJsZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qgd2luID0gZ2V0V2luZG93KGRvbVJlZmVyZW5jZSk7XG5cbiAgICAvLyBJZiB0aGUgcmVmZXJlbmNlIHdhcyBmb2N1c2VkIGFuZCB0aGUgdXNlciBsZWZ0IHRoZSB0YWIvd2luZG93LCBhbmQgdGhlXG4gICAgLy8gZmxvYXRpbmcgZWxlbWVudCB3YXMgbm90IG9wZW4sIHRoZSBmb2N1cyBzaG91bGQgYmUgYmxvY2tlZCB3aGVuIHRoZXlcbiAgICAvLyByZXR1cm4gdG8gdGhlIHRhYi93aW5kb3cuXG4gICAgZnVuY3Rpb24gb25CbHVyKCkge1xuICAgICAgaWYgKCFvcGVuICYmIGlzSFRNTEVsZW1lbnQoZG9tUmVmZXJlbmNlKSAmJiBkb21SZWZlcmVuY2UgPT09IGFjdGl2ZUVsZW1lbnQoZ2V0RG9jdW1lbnQoZG9tUmVmZXJlbmNlKSkpIHtcbiAgICAgICAgYmxvY2tGb2N1c1JlZi5jdXJyZW50ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gb25LZXlEb3duKCkge1xuICAgICAga2V5Ym9hcmRNb2RhbGl0eVJlZi5jdXJyZW50ID0gdHJ1ZTtcbiAgICB9XG4gICAgd2luLmFkZEV2ZW50TGlzdGVuZXIoJ2JsdXInLCBvbkJsdXIpO1xuICAgIHdpbi5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgb25LZXlEb3duLCB0cnVlKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgd2luLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2JsdXInLCBvbkJsdXIpO1xuICAgICAgd2luLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCBvbktleURvd24sIHRydWUpO1xuICAgIH07XG4gIH0sIFtkb21SZWZlcmVuY2UsIG9wZW4sIGVuYWJsZWRdKTtcbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoIWVuYWJsZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZnVuY3Rpb24gb25PcGVuQ2hhbmdlKF9yZWYpIHtcbiAgICAgIGxldCB7XG4gICAgICAgIHJlYXNvblxuICAgICAgfSA9IF9yZWY7XG4gICAgICBpZiAocmVhc29uID09PSAncmVmZXJlbmNlLXByZXNzJyB8fCByZWFzb24gPT09ICdlc2NhcGUta2V5Jykge1xuICAgICAgICBibG9ja0ZvY3VzUmVmLmN1cnJlbnQgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICBldmVudHMub24oJ29wZW5jaGFuZ2UnLCBvbk9wZW5DaGFuZ2UpO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBldmVudHMub2ZmKCdvcGVuY2hhbmdlJywgb25PcGVuQ2hhbmdlKTtcbiAgICB9O1xuICB9LCBbZXZlbnRzLCBlbmFibGVkXSk7XG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0UmVmLmN1cnJlbnQpO1xuICAgIH07XG4gIH0sIFtdKTtcbiAgcmV0dXJuIFJlYWN0LnVzZU1lbW8oKCkgPT4ge1xuICAgIGlmICghZW5hYmxlZCkge1xuICAgICAgcmV0dXJuIHt9O1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgcmVmZXJlbmNlOiB7XG4gICAgICAgIG9uUG9pbnRlckRvd24oZXZlbnQpIHtcbiAgICAgICAgICBpZiAoaXNWaXJ0dWFsUG9pbnRlckV2ZW50KGV2ZW50Lm5hdGl2ZUV2ZW50KSkgcmV0dXJuO1xuICAgICAgICAgIGtleWJvYXJkTW9kYWxpdHlSZWYuY3VycmVudCA9IGZhbHNlO1xuICAgICAgICB9LFxuICAgICAgICBvbk1vdXNlTGVhdmUoKSB7XG4gICAgICAgICAgYmxvY2tGb2N1c1JlZi5jdXJyZW50ID0gZmFsc2U7XG4gICAgICAgIH0sXG4gICAgICAgIG9uRm9jdXMoZXZlbnQpIHtcbiAgICAgICAgICBpZiAoYmxvY2tGb2N1c1JlZi5jdXJyZW50KSByZXR1cm47XG4gICAgICAgICAgY29uc3QgdGFyZ2V0ID0gZ2V0VGFyZ2V0KGV2ZW50Lm5hdGl2ZUV2ZW50KTtcbiAgICAgICAgICBpZiAodmlzaWJsZU9ubHkgJiYgaXNFbGVtZW50KHRhcmdldCkpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIC8vIE1hYyBTYWZhcmkgdW5yZWxpYWJseSBtYXRjaGVzIGA6Zm9jdXMtdmlzaWJsZWAgb24gdGhlIHJlZmVyZW5jZVxuICAgICAgICAgICAgICAvLyBpZiBmb2N1cyB3YXMgb3V0c2lkZSB0aGUgcGFnZSBpbml0aWFsbHkgLSB1c2UgdGhlIGZhbGxiYWNrXG4gICAgICAgICAgICAgIC8vIGluc3RlYWQuXG4gICAgICAgICAgICAgIGlmIChpc1NhZmFyaSgpICYmIGlzTWFjKCkpIHRocm93IEVycm9yKCk7XG4gICAgICAgICAgICAgIGlmICghdGFyZ2V0Lm1hdGNoZXMoJzpmb2N1cy12aXNpYmxlJykpIHJldHVybjtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgLy8gT2xkIGJyb3dzZXJzIHdpbGwgdGhyb3cgYW4gZXJyb3Igd2hlbiB1c2luZyBgOmZvY3VzLXZpc2libGVgLlxuICAgICAgICAgICAgICBpZiAoIWtleWJvYXJkTW9kYWxpdHlSZWYuY3VycmVudCAmJiAhaXNUeXBlYWJsZUVsZW1lbnQodGFyZ2V0KSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBvbk9wZW5DaGFuZ2UodHJ1ZSwgZXZlbnQubmF0aXZlRXZlbnQsICdmb2N1cycpO1xuICAgICAgICB9LFxuICAgICAgICBvbkJsdXIoZXZlbnQpIHtcbiAgICAgICAgICBibG9ja0ZvY3VzUmVmLmN1cnJlbnQgPSBmYWxzZTtcbiAgICAgICAgICBjb25zdCByZWxhdGVkVGFyZ2V0ID0gZXZlbnQucmVsYXRlZFRhcmdldDtcblxuICAgICAgICAgIC8vIEhpdCB0aGUgbm9uLW1vZGFsIGZvY3VzIG1hbmFnZW1lbnQgcG9ydGFsIGd1YXJkLiBGb2N1cyB3aWxsIGJlXG4gICAgICAgICAgLy8gbW92ZWQgaW50byB0aGUgZmxvYXRpbmcgZWxlbWVudCBpbW1lZGlhdGVseSBhZnRlci5cbiAgICAgICAgICBjb25zdCBtb3ZlZFRvRm9jdXNHdWFyZCA9IGlzRWxlbWVudChyZWxhdGVkVGFyZ2V0KSAmJiByZWxhdGVkVGFyZ2V0Lmhhc0F0dHJpYnV0ZShjcmVhdGVBdHRyaWJ1dGUoJ2ZvY3VzLWd1YXJkJykpICYmIHJlbGF0ZWRUYXJnZXQuZ2V0QXR0cmlidXRlKCdkYXRhLXR5cGUnKSA9PT0gJ291dHNpZGUnO1xuXG4gICAgICAgICAgLy8gV2FpdCBmb3IgdGhlIHdpbmRvdyBibHVyIGxpc3RlbmVyIHRvIGZpcmUuXG4gICAgICAgICAgdGltZW91dFJlZi5jdXJyZW50ID0gd2luZG93LnNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgYWN0aXZlRWwgPSBhY3RpdmVFbGVtZW50KGRvbVJlZmVyZW5jZSA/IGRvbVJlZmVyZW5jZS5vd25lckRvY3VtZW50IDogZG9jdW1lbnQpO1xuXG4gICAgICAgICAgICAvLyBGb2N1cyBsZWZ0IHRoZSBwYWdlLCBrZWVwIGl0IG9wZW4uXG4gICAgICAgICAgICBpZiAoIXJlbGF0ZWRUYXJnZXQgJiYgYWN0aXZlRWwgPT09IGRvbVJlZmVyZW5jZSkgcmV0dXJuO1xuXG4gICAgICAgICAgICAvLyBXaGVuIGZvY3VzaW5nIHRoZSByZWZlcmVuY2UgZWxlbWVudCAoZS5nLiByZWd1bGFyIGNsaWNrKSwgdGhlblxuICAgICAgICAgICAgLy8gY2xpY2tpbmcgaW50byB0aGUgZmxvYXRpbmcgZWxlbWVudCwgcHJldmVudCBpdCBmcm9tIGhpZGluZy5cbiAgICAgICAgICAgIC8vIE5vdGU6IGl0IG11c3QgYmUgZm9jdXNhYmxlLCBlLmcuIGB0YWJpbmRleD1cIi0xXCJgLlxuICAgICAgICAgICAgLy8gV2UgY2FuIG5vdCByZWx5IG9uIHJlbGF0ZWRUYXJnZXQgdG8gcG9pbnQgdG8gdGhlIGNvcnJlY3QgZWxlbWVudFxuICAgICAgICAgICAgLy8gYXMgaXQgd2lsbCBvbmx5IHBvaW50IHRvIHRoZSBzaGFkb3cgaG9zdCBvZiB0aGUgbmV3bHkgZm9jdXNlZCBlbGVtZW50XG4gICAgICAgICAgICAvLyBhbmQgbm90IHRoZSBlbGVtZW50IHRoYXQgYWN0dWFsbHkgaGFzIHJlY2VpdmVkIGZvY3VzIGlmIGl0IGlzIGxvY2F0ZWRcbiAgICAgICAgICAgIC8vIGluc2lkZSBhIHNoYWRvdyByb290LlxuICAgICAgICAgICAgaWYgKGNvbnRhaW5zKHJlZnMuZmxvYXRpbmcuY3VycmVudCwgYWN0aXZlRWwpIHx8IGNvbnRhaW5zKGRvbVJlZmVyZW5jZSwgYWN0aXZlRWwpIHx8IG1vdmVkVG9Gb2N1c0d1YXJkKSB7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9uT3BlbkNoYW5nZShmYWxzZSwgZXZlbnQubmF0aXZlRXZlbnQsICdmb2N1cycpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgfSwgW2VuYWJsZWQsIHZpc2libGVPbmx5LCBkb21SZWZlcmVuY2UsIHJlZnMsIG9uT3BlbkNoYW5nZV0pO1xufVxuXG5jb25zdCBBQ1RJVkVfS0VZID0gJ2FjdGl2ZSc7XG5jb25zdCBTRUxFQ1RFRF9LRVkgPSAnc2VsZWN0ZWQnO1xuZnVuY3Rpb24gbWVyZ2VQcm9wcyh1c2VyUHJvcHMsIHByb3BzTGlzdCwgZWxlbWVudEtleSkge1xuICBjb25zdCBtYXAgPSBuZXcgTWFwKCk7XG4gIGNvbnN0IGlzSXRlbSA9IGVsZW1lbnRLZXkgPT09ICdpdGVtJztcbiAgbGV0IGRvbVVzZXJQcm9wcyA9IHVzZXJQcm9wcztcbiAgaWYgKGlzSXRlbSAmJiB1c2VyUHJvcHMpIHtcbiAgICBjb25zdCB7XG4gICAgICBbQUNUSVZFX0tFWV06IF8sXG4gICAgICBbU0VMRUNURURfS0VZXTogX18sXG4gICAgICAuLi52YWxpZFByb3BzXG4gICAgfSA9IHVzZXJQcm9wcztcbiAgICBkb21Vc2VyUHJvcHMgPSB2YWxpZFByb3BzO1xuICB9XG4gIHJldHVybiB7XG4gICAgLi4uKGVsZW1lbnRLZXkgPT09ICdmbG9hdGluZycgJiYge1xuICAgICAgdGFiSW5kZXg6IC0xXG4gICAgfSksXG4gICAgLi4uZG9tVXNlclByb3BzLFxuICAgIC4uLnByb3BzTGlzdC5tYXAodmFsdWUgPT4ge1xuICAgICAgY29uc3QgcHJvcHNPckdldFByb3BzID0gdmFsdWUgPyB2YWx1ZVtlbGVtZW50S2V5XSA6IG51bGw7XG4gICAgICBpZiAodHlwZW9mIHByb3BzT3JHZXRQcm9wcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gdXNlclByb3BzID8gcHJvcHNPckdldFByb3BzKHVzZXJQcm9wcykgOiBudWxsO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHByb3BzT3JHZXRQcm9wcztcbiAgICB9KS5jb25jYXQodXNlclByb3BzKS5yZWR1Y2UoKGFjYywgcHJvcHMpID0+IHtcbiAgICAgIGlmICghcHJvcHMpIHtcbiAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgIH1cbiAgICAgIE9iamVjdC5lbnRyaWVzKHByb3BzKS5mb3JFYWNoKF9yZWYgPT4ge1xuICAgICAgICBsZXQgW2tleSwgdmFsdWVdID0gX3JlZjtcbiAgICAgICAgaWYgKGlzSXRlbSAmJiBbQUNUSVZFX0tFWSwgU0VMRUNURURfS0VZXS5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChrZXkuaW5kZXhPZignb24nKSA9PT0gMCkge1xuICAgICAgICAgIGlmICghbWFwLmhhcyhrZXkpKSB7XG4gICAgICAgICAgICBtYXAuc2V0KGtleSwgW10pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB2YXIgX21hcCRnZXQ7XG4gICAgICAgICAgICAoX21hcCRnZXQgPSBtYXAuZ2V0KGtleSkpID09IG51bGwgfHwgX21hcCRnZXQucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgICBhY2Nba2V5XSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgdmFyIF9tYXAkZ2V0MjtcbiAgICAgICAgICAgICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICAgICAgICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gKF9tYXAkZ2V0MiA9IG1hcC5nZXQoa2V5KSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9tYXAkZ2V0Mi5tYXAoZm4gPT4gZm4oLi4uYXJncykpLmZpbmQodmFsID0+IHZhbCAhPT0gdW5kZWZpbmVkKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFjY1trZXldID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGFjYztcbiAgICB9LCB7fSlcbiAgfTtcbn1cblxuLyoqXG4gKiBNZXJnZXMgYW4gYXJyYXkgb2YgaW50ZXJhY3Rpb24gaG9va3MnIHByb3BzIGludG8gcHJvcCBnZXR0ZXJzLCBhbGxvd2luZ1xuICogZXZlbnQgaGFuZGxlciBmdW5jdGlvbnMgdG8gYmUgY29tcG9zZWQgdG9nZXRoZXIgd2l0aG91dCBvdmVyd3JpdGluZyBvbmVcbiAqIGFub3RoZXIuXG4gKiBAc2VlIGh0dHBzOi8vZmxvYXRpbmctdWkuY29tL2RvY3MvdXNlSW50ZXJhY3Rpb25zXG4gKi9cbmZ1bmN0aW9uIHVzZUludGVyYWN0aW9ucyhwcm9wc0xpc3QpIHtcbiAgaWYgKHByb3BzTGlzdCA9PT0gdm9pZCAwKSB7XG4gICAgcHJvcHNMaXN0ID0gW107XG4gIH1cbiAgLy8gVGhlIGRlcGVuZGVuY2llcyBhcmUgYSBkeW5hbWljIGFycmF5LCBzbyB3ZSBjYW4ndCB1c2UgdGhlIGxpbnRlcidzXG4gIC8vIHN1Z2dlc3Rpb24gdG8gYWRkIGl0IHRvIHRoZSBkZXBzIGFycmF5LlxuICBjb25zdCBkZXBzID0gcHJvcHNMaXN0O1xuXG4gIC8vIGJpb21lLWlnbm9yZSBsaW50L2NvcnJlY3RuZXNzL3VzZUV4aGF1c3RpdmVEZXBlbmRlbmNpZXM6IGludGVudGlvbmFsXG4gIGNvbnN0IGdldFJlZmVyZW5jZVByb3BzID0gUmVhY3QudXNlQ2FsbGJhY2sodXNlclByb3BzID0+IG1lcmdlUHJvcHModXNlclByb3BzLCBwcm9wc0xpc3QsICdyZWZlcmVuY2UnKSwgZGVwcyk7XG5cbiAgLy8gYmlvbWUtaWdub3JlIGxpbnQvY29ycmVjdG5lc3MvdXNlRXhoYXVzdGl2ZURlcGVuZGVuY2llczogaW50ZW50aW9uYWxcbiAgY29uc3QgZ2V0RmxvYXRpbmdQcm9wcyA9IFJlYWN0LnVzZUNhbGxiYWNrKHVzZXJQcm9wcyA9PiBtZXJnZVByb3BzKHVzZXJQcm9wcywgcHJvcHNMaXN0LCAnZmxvYXRpbmcnKSwgZGVwcyk7XG5cbiAgLy8gYmlvbWUtaWdub3JlIGxpbnQvY29ycmVjdG5lc3MvdXNlRXhoYXVzdGl2ZURlcGVuZGVuY2llczogaW50ZW50aW9uYWxcbiAgY29uc3QgZ2V0SXRlbVByb3BzID0gUmVhY3QudXNlQ2FsbGJhY2sodXNlclByb3BzID0+IG1lcmdlUHJvcHModXNlclByb3BzLCBwcm9wc0xpc3QsICdpdGVtJyksXG4gIC8vIEdyYW51bGFybHkgY2hlY2sgZm9yIGBpdGVtYCBjaGFuZ2VzLCBiZWNhdXNlIHRoZSBgZ2V0SXRlbVByb3BzYCBnZXR0ZXJcbiAgLy8gc2hvdWxkIGJlIGFzIHJlZmVyZW50aWFsbHkgc3RhYmxlIGFzIHBvc3NpYmxlIHNpbmNlIGl0IG1heSBiZSBwYXNzZWQgYXNcbiAgLy8gYSBwcm9wIHRvIG1hbnkgY29tcG9uZW50cy4gQWxsIGBpdGVtYCBrZXkgdmFsdWVzIG11c3QgdGhlcmVmb3JlIGJlXG4gIC8vIG1lbW9pemVkLlxuICBwcm9wc0xpc3QubWFwKGtleSA9PiBrZXkgPT0gbnVsbCA/IHZvaWQgMCA6IGtleS5pdGVtKSk7XG4gIHJldHVybiBSZWFjdC51c2VNZW1vKCgpID0+ICh7XG4gICAgZ2V0UmVmZXJlbmNlUHJvcHMsXG4gICAgZ2V0RmxvYXRpbmdQcm9wcyxcbiAgICBnZXRJdGVtUHJvcHNcbiAgfSksIFtnZXRSZWZlcmVuY2VQcm9wcywgZ2V0RmxvYXRpbmdQcm9wcywgZ2V0SXRlbVByb3BzXSk7XG59XG5cbmxldCBpc1ByZXZlbnRTY3JvbGxTdXBwb3J0ZWQgPSBmYWxzZTtcbmZ1bmN0aW9uIGRvU3dpdGNoKG9yaWVudGF0aW9uLCB2ZXJ0aWNhbCwgaG9yaXpvbnRhbCkge1xuICBzd2l0Y2ggKG9yaWVudGF0aW9uKSB7XG4gICAgY2FzZSAndmVydGljYWwnOlxuICAgICAgcmV0dXJuIHZlcnRpY2FsO1xuICAgIGNhc2UgJ2hvcml6b250YWwnOlxuICAgICAgcmV0dXJuIGhvcml6b250YWw7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiB2ZXJ0aWNhbCB8fCBob3Jpem9udGFsO1xuICB9XG59XG5mdW5jdGlvbiBpc01haW5PcmllbnRhdGlvbktleShrZXksIG9yaWVudGF0aW9uKSB7XG4gIGNvbnN0IHZlcnRpY2FsID0ga2V5ID09PSBBUlJPV19VUCB8fCBrZXkgPT09IEFSUk9XX0RPV047XG4gIGNvbnN0IGhvcml6b250YWwgPSBrZXkgPT09IEFSUk9XX0xFRlQgfHwga2V5ID09PSBBUlJPV19SSUdIVDtcbiAgcmV0dXJuIGRvU3dpdGNoKG9yaWVudGF0aW9uLCB2ZXJ0aWNhbCwgaG9yaXpvbnRhbCk7XG59XG5mdW5jdGlvbiBpc01haW5PcmllbnRhdGlvblRvRW5kS2V5KGtleSwgb3JpZW50YXRpb24sIHJ0bCkge1xuICBjb25zdCB2ZXJ0aWNhbCA9IGtleSA9PT0gQVJST1dfRE9XTjtcbiAgY29uc3QgaG9yaXpvbnRhbCA9IHJ0bCA/IGtleSA9PT0gQVJST1dfTEVGVCA6IGtleSA9PT0gQVJST1dfUklHSFQ7XG4gIHJldHVybiBkb1N3aXRjaChvcmllbnRhdGlvbiwgdmVydGljYWwsIGhvcml6b250YWwpIHx8IGtleSA9PT0gJ0VudGVyJyB8fCBrZXkgPT09ICcgJyB8fCBrZXkgPT09ICcnO1xufVxuZnVuY3Rpb24gaXNDcm9zc09yaWVudGF0aW9uT3BlbktleShrZXksIG9yaWVudGF0aW9uLCBydGwpIHtcbiAgY29uc3QgdmVydGljYWwgPSBydGwgPyBrZXkgPT09IEFSUk9XX0xFRlQgOiBrZXkgPT09IEFSUk9XX1JJR0hUO1xuICBjb25zdCBob3Jpem9udGFsID0ga2V5ID09PSBBUlJPV19ET1dOO1xuICByZXR1cm4gZG9Td2l0Y2gob3JpZW50YXRpb24sIHZlcnRpY2FsLCBob3Jpem9udGFsKTtcbn1cbmZ1bmN0aW9uIGlzQ3Jvc3NPcmllbnRhdGlvbkNsb3NlS2V5KGtleSwgb3JpZW50YXRpb24sIHJ0bCkge1xuICBjb25zdCB2ZXJ0aWNhbCA9IHJ0bCA/IGtleSA9PT0gQVJST1dfUklHSFQgOiBrZXkgPT09IEFSUk9XX0xFRlQ7XG4gIGNvbnN0IGhvcml6b250YWwgPSBrZXkgPT09IEFSUk9XX1VQO1xuICByZXR1cm4gZG9Td2l0Y2gob3JpZW50YXRpb24sIHZlcnRpY2FsLCBob3Jpem9udGFsKTtcbn1cbi8qKlxuICogQWRkcyBhcnJvdyBrZXktYmFzZWQgbmF2aWdhdGlvbiBvZiBhIGxpc3Qgb2YgaXRlbXMsIGVpdGhlciB1c2luZyByZWFsIERPTVxuICogZm9jdXMgb3IgdmlydHVhbCBmb2N1cy5cbiAqIEBzZWUgaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy91c2VMaXN0TmF2aWdhdGlvblxuICovXG5mdW5jdGlvbiB1c2VMaXN0TmF2aWdhdGlvbihjb250ZXh0LCBwcm9wcykge1xuICBjb25zdCB7XG4gICAgb3BlbixcbiAgICBvbk9wZW5DaGFuZ2UsXG4gICAgcmVmcyxcbiAgICBlbGVtZW50czoge1xuICAgICAgZG9tUmVmZXJlbmNlLFxuICAgICAgZmxvYXRpbmdcbiAgICB9XG4gIH0gPSBjb250ZXh0O1xuICBjb25zdCB7XG4gICAgbGlzdFJlZixcbiAgICBhY3RpdmVJbmRleCxcbiAgICBvbk5hdmlnYXRlOiB1bnN0YWJsZV9vbk5hdmlnYXRlID0gKCkgPT4ge30sXG4gICAgZW5hYmxlZCA9IHRydWUsXG4gICAgc2VsZWN0ZWRJbmRleCA9IG51bGwsXG4gICAgYWxsb3dFc2NhcGUgPSBmYWxzZSxcbiAgICBsb29wID0gZmFsc2UsXG4gICAgbmVzdGVkID0gZmFsc2UsXG4gICAgcnRsID0gZmFsc2UsXG4gICAgdmlydHVhbCA9IGZhbHNlLFxuICAgIGZvY3VzSXRlbU9uT3BlbiA9ICdhdXRvJyxcbiAgICBmb2N1c0l0ZW1PbkhvdmVyID0gdHJ1ZSxcbiAgICBvcGVuT25BcnJvd0tleURvd24gPSB0cnVlLFxuICAgIGRpc2FibGVkSW5kaWNlcyA9IHVuZGVmaW5lZCxcbiAgICBvcmllbnRhdGlvbiA9ICd2ZXJ0aWNhbCcsXG4gICAgY29scyA9IDEsXG4gICAgc2Nyb2xsSXRlbUludG9WaWV3ID0gdHJ1ZSxcbiAgICB2aXJ0dWFsSXRlbVJlZixcbiAgICBpdGVtU2l6ZXMsXG4gICAgZGVuc2UgPSBmYWxzZVxuICB9ID0gcHJvcHM7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICBpZiAoYWxsb3dFc2NhcGUpIHtcbiAgICAgIGlmICghbG9vcCkge1xuICAgICAgICBjb25zb2xlLndhcm4oWydGbG9hdGluZyBVSTogYHVzZUxpc3ROYXZpZ2F0aW9uYCBsb29waW5nIG11c3QgYmUgZW5hYmxlZCB0byBhbGxvdycsICdlc2NhcGluZy4nXS5qb2luKCcgJykpO1xuICAgICAgfVxuICAgICAgaWYgKCF2aXJ0dWFsKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihbJ0Zsb2F0aW5nIFVJOiBgdXNlTGlzdE5hdmlnYXRpb25gIG11c3QgYmUgdmlydHVhbCB0byBhbGxvdycsICdlc2NhcGluZy4nXS5qb2luKCcgJykpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAob3JpZW50YXRpb24gPT09ICd2ZXJ0aWNhbCcgJiYgY29scyA+IDEpIHtcbiAgICAgIGNvbnNvbGUud2FybihbJ0Zsb2F0aW5nIFVJOiBJbiBncmlkIGxpc3QgbmF2aWdhdGlvbiBtb2RlIChgY29sc2AgPiAxKSwgdGhlJywgJ2BvcmllbnRhdGlvbmAgc2hvdWxkIGJlIGVpdGhlciBcImhvcml6b250YWxcIiBvciBcImJvdGhcIi4nXS5qb2luKCcgJykpO1xuICAgIH1cbiAgfVxuICBjb25zdCBwYXJlbnRJZCA9IHVzZUZsb2F0aW5nUGFyZW50Tm9kZUlkKCk7XG4gIGNvbnN0IHRyZWUgPSB1c2VGbG9hdGluZ1RyZWUoKTtcbiAgY29uc3Qgb25OYXZpZ2F0ZSA9IHVzZUVmZmVjdEV2ZW50KHVuc3RhYmxlX29uTmF2aWdhdGUpO1xuICBjb25zdCBmb2N1c0l0ZW1Pbk9wZW5SZWYgPSBSZWFjdC51c2VSZWYoZm9jdXNJdGVtT25PcGVuKTtcbiAgY29uc3QgaW5kZXhSZWYgPSBSZWFjdC51c2VSZWYoc2VsZWN0ZWRJbmRleCAhPSBudWxsID8gc2VsZWN0ZWRJbmRleCA6IC0xKTtcbiAgY29uc3Qga2V5UmVmID0gUmVhY3QudXNlUmVmKG51bGwpO1xuICBjb25zdCBpc1BvaW50ZXJNb2RhbGl0eVJlZiA9IFJlYWN0LnVzZVJlZih0cnVlKTtcbiAgY29uc3QgcHJldmlvdXNPbk5hdmlnYXRlUmVmID0gUmVhY3QudXNlUmVmKG9uTmF2aWdhdGUpO1xuICBjb25zdCBwcmV2aW91c01vdW50ZWRSZWYgPSBSZWFjdC51c2VSZWYoISFmbG9hdGluZyk7XG4gIGNvbnN0IGZvcmNlU3luY0ZvY3VzID0gUmVhY3QudXNlUmVmKGZhbHNlKTtcbiAgY29uc3QgZm9yY2VTY3JvbGxJbnRvVmlld1JlZiA9IFJlYWN0LnVzZVJlZihmYWxzZSk7XG4gIGNvbnN0IGRpc2FibGVkSW5kaWNlc1JlZiA9IHVzZUxhdGVzdFJlZihkaXNhYmxlZEluZGljZXMpO1xuICBjb25zdCBsYXRlc3RPcGVuUmVmID0gdXNlTGF0ZXN0UmVmKG9wZW4pO1xuICBjb25zdCBzY3JvbGxJdGVtSW50b1ZpZXdSZWYgPSB1c2VMYXRlc3RSZWYoc2Nyb2xsSXRlbUludG9WaWV3KTtcbiAgY29uc3QgW2FjdGl2ZUlkLCBzZXRBY3RpdmVJZF0gPSBSZWFjdC51c2VTdGF0ZSgpO1xuICBjb25zdCBbdmlydHVhbElkLCBzZXRWaXJ0dWFsSWRdID0gUmVhY3QudXNlU3RhdGUoKTtcbiAgY29uc3QgZm9jdXNJdGVtID0gdXNlRWZmZWN0RXZlbnQoZnVuY3Rpb24gKGxpc3RSZWYsIGluZGV4UmVmLCBmb3JjZVNjcm9sbEludG9WaWV3KSB7XG4gICAgaWYgKGZvcmNlU2Nyb2xsSW50b1ZpZXcgPT09IHZvaWQgMCkge1xuICAgICAgZm9yY2VTY3JvbGxJbnRvVmlldyA9IGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBpdGVtID0gbGlzdFJlZi5jdXJyZW50W2luZGV4UmVmLmN1cnJlbnRdO1xuICAgIGlmICghaXRlbSkgcmV0dXJuO1xuICAgIGlmICh2aXJ0dWFsKSB7XG4gICAgICBzZXRBY3RpdmVJZChpdGVtLmlkKTtcbiAgICAgIHRyZWUgPT0gbnVsbCB8fCB0cmVlLmV2ZW50cy5lbWl0KCd2aXJ0dWFsZm9jdXMnLCBpdGVtKTtcbiAgICAgIGlmICh2aXJ0dWFsSXRlbVJlZikge1xuICAgICAgICB2aXJ0dWFsSXRlbVJlZi5jdXJyZW50ID0gaXRlbTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZW5xdWV1ZUZvY3VzKGl0ZW0sIHtcbiAgICAgICAgcHJldmVudFNjcm9sbDogdHJ1ZSxcbiAgICAgICAgLy8gTWFjIFNhZmFyaSBkb2VzIG5vdCBtb3ZlIHRoZSB2aXJ0dWFsIGN1cnNvciB1bmxlc3MgdGhlIGZvY3VzIGNhbGxcbiAgICAgICAgLy8gaXMgc3luYy4gSG93ZXZlciwgZm9yIHRoZSB2ZXJ5IGZpcnN0IGZvY3VzIGNhbGwsIHdlIG5lZWQgdG8gd2FpdFxuICAgICAgICAvLyBmb3IgdGhlIHBvc2l0aW9uIHRvIGJlIHJlYWR5IGluIG9yZGVyIHRvIHByZXZlbnQgdW53YW50ZWRcbiAgICAgICAgLy8gc2Nyb2xsaW5nLiBUaGlzIG1lYW5zIHRoZSB2aXJ0dWFsIGN1cnNvciB3aWxsIG5vdCBtb3ZlIHRvIHRoZSBmaXJzdFxuICAgICAgICAvLyBpdGVtIHdoZW4gZmlyc3Qgb3BlbmluZyB0aGUgZmxvYXRpbmcgZWxlbWVudCwgYnV0IHdpbGwgb25cbiAgICAgICAgLy8gc3Vic2VxdWVudCBjYWxscy4gYHByZXZlbnRTY3JvbGxgIGlzIHN1cHBvcnRlZCBpbiBtb2Rlcm4gU2FmYXJpLFxuICAgICAgICAvLyBzbyB3ZSBjYW4gdXNlIHRoYXQgaW5zdGVhZC5cbiAgICAgICAgLy8gaU9TIFNhZmFyaSBtdXN0IGJlIGFzeW5jIG9yIHRoZSBmaXJzdCBpdGVtIHdpbGwgbm90IGJlIGZvY3VzZWQuXG4gICAgICAgIHN5bmM6IGlzTWFjKCkgJiYgaXNTYWZhcmkoKSA/IGlzUHJldmVudFNjcm9sbFN1cHBvcnRlZCB8fCBmb3JjZVN5bmNGb2N1cy5jdXJyZW50IDogZmFsc2VcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgY29uc3Qgc2Nyb2xsSW50b1ZpZXdPcHRpb25zID0gc2Nyb2xsSXRlbUludG9WaWV3UmVmLmN1cnJlbnQ7XG4gICAgICBjb25zdCBzaG91bGRTY3JvbGxJbnRvVmlldyA9IHNjcm9sbEludG9WaWV3T3B0aW9ucyAmJiBpdGVtICYmIChmb3JjZVNjcm9sbEludG9WaWV3IHx8ICFpc1BvaW50ZXJNb2RhbGl0eVJlZi5jdXJyZW50KTtcbiAgICAgIGlmIChzaG91bGRTY3JvbGxJbnRvVmlldykge1xuICAgICAgICAvLyBKU0RPTSBkb2Vzbid0IHN1cHBvcnQgYC5zY3JvbGxJbnRvVmlldygpYCBidXQgaXQncyB3aWRlbHkgc3VwcG9ydGVkXG4gICAgICAgIC8vIGJ5IGFsbCBicm93c2Vycy5cbiAgICAgICAgaXRlbS5zY3JvbGxJbnRvVmlldyA9PSBudWxsIHx8IGl0ZW0uc2Nyb2xsSW50b1ZpZXcodHlwZW9mIHNjcm9sbEludG9WaWV3T3B0aW9ucyA9PT0gJ2Jvb2xlYW4nID8ge1xuICAgICAgICAgIGJsb2NrOiAnbmVhcmVzdCcsXG4gICAgICAgICAgaW5saW5lOiAnbmVhcmVzdCdcbiAgICAgICAgfSA6IHNjcm9sbEludG9WaWV3T3B0aW9ucyk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xuICBpbmRleCgoKSA9PiB7XG4gICAgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JykuZm9jdXMoe1xuICAgICAgZ2V0IHByZXZlbnRTY3JvbGwoKSB7XG4gICAgICAgIGlzUHJldmVudFNjcm9sbFN1cHBvcnRlZCA9IHRydWU7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSwgW10pO1xuXG4gIC8vIFN5bmMgYHNlbGVjdGVkSW5kZXhgIHRvIGJlIHRoZSBgYWN0aXZlSW5kZXhgIHVwb24gb3BlbmluZyB0aGUgZmxvYXRpbmdcbiAgLy8gZWxlbWVudC4gQWxzbywgcmVzZXQgYGFjdGl2ZUluZGV4YCB1cG9uIGNsb3NpbmcgdGhlIGZsb2F0aW5nIGVsZW1lbnQuXG4gIGluZGV4KCgpID0+IHtcbiAgICBpZiAoIWVuYWJsZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKG9wZW4gJiYgZmxvYXRpbmcpIHtcbiAgICAgIGlmIChmb2N1c0l0ZW1Pbk9wZW5SZWYuY3VycmVudCAmJiBzZWxlY3RlZEluZGV4ICE9IG51bGwpIHtcbiAgICAgICAgLy8gUmVnYXJkbGVzcyBvZiB0aGUgcG9pbnRlciBtb2RhbGl0eSwgd2Ugd2FudCB0byBlbnN1cmUgdGhlIHNlbGVjdGVkXG4gICAgICAgIC8vIGl0ZW0gY29tZXMgaW50byB2aWV3IHdoZW4gdGhlIGZsb2F0aW5nIGVsZW1lbnQgaXMgb3BlbmVkLlxuICAgICAgICBmb3JjZVNjcm9sbEludG9WaWV3UmVmLmN1cnJlbnQgPSB0cnVlO1xuICAgICAgICBpbmRleFJlZi5jdXJyZW50ID0gc2VsZWN0ZWRJbmRleDtcbiAgICAgICAgb25OYXZpZ2F0ZShzZWxlY3RlZEluZGV4KTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHByZXZpb3VzTW91bnRlZFJlZi5jdXJyZW50KSB7XG4gICAgICAvLyBTaW5jZSB0aGUgdXNlciBjYW4gc3BlY2lmeSBgb25OYXZpZ2F0ZWAgY29uZGl0aW9uYWxseVxuICAgICAgLy8gKG9uTmF2aWdhdGU6IG9wZW4gPyBzZXRBY3RpdmVJbmRleCA6IHNldFNlbGVjdGVkSW5kZXgpLFxuICAgICAgLy8gd2Ugc3RvcmUgYW5kIGNhbGwgdGhlIHByZXZpb3VzIGZ1bmN0aW9uLlxuICAgICAgaW5kZXhSZWYuY3VycmVudCA9IC0xO1xuICAgICAgcHJldmlvdXNPbk5hdmlnYXRlUmVmLmN1cnJlbnQobnVsbCk7XG4gICAgfVxuICB9LCBbZW5hYmxlZCwgb3BlbiwgZmxvYXRpbmcsIHNlbGVjdGVkSW5kZXgsIG9uTmF2aWdhdGVdKTtcblxuICAvLyBTeW5jIGBhY3RpdmVJbmRleGAgdG8gYmUgdGhlIGZvY3VzZWQgaXRlbSB3aGlsZSB0aGUgZmxvYXRpbmcgZWxlbWVudCBpc1xuICAvLyBvcGVuLlxuICBpbmRleCgoKSA9PiB7XG4gICAgaWYgKCFlbmFibGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChvcGVuICYmIGZsb2F0aW5nKSB7XG4gICAgICBpZiAoYWN0aXZlSW5kZXggPT0gbnVsbCkge1xuICAgICAgICBmb3JjZVN5bmNGb2N1cy5jdXJyZW50ID0gZmFsc2U7XG4gICAgICAgIGlmIChzZWxlY3RlZEluZGV4ICE9IG51bGwpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBSZXNldCB3aGlsZSB0aGUgZmxvYXRpbmcgZWxlbWVudCB3YXMgb3BlbiAoZS5nLiB0aGUgbGlzdCBjaGFuZ2VkKS5cbiAgICAgICAgaWYgKHByZXZpb3VzTW91bnRlZFJlZi5jdXJyZW50KSB7XG4gICAgICAgICAgaW5kZXhSZWYuY3VycmVudCA9IC0xO1xuICAgICAgICAgIGZvY3VzSXRlbShsaXN0UmVmLCBpbmRleFJlZik7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJbml0aWFsIHN5bmMuXG4gICAgICAgIGlmICghcHJldmlvdXNNb3VudGVkUmVmLmN1cnJlbnQgJiYgZm9jdXNJdGVtT25PcGVuUmVmLmN1cnJlbnQgJiYgKGtleVJlZi5jdXJyZW50ICE9IG51bGwgfHwgZm9jdXNJdGVtT25PcGVuUmVmLmN1cnJlbnQgPT09IHRydWUgJiYga2V5UmVmLmN1cnJlbnQgPT0gbnVsbCkpIHtcbiAgICAgICAgICBsZXQgcnVucyA9IDA7XG4gICAgICAgICAgY29uc3Qgd2FpdEZvckxpc3RQb3B1bGF0ZWQgPSAoKSA9PiB7XG4gICAgICAgICAgICBpZiAobGlzdFJlZi5jdXJyZW50WzBdID09IG51bGwpIHtcbiAgICAgICAgICAgICAgLy8gQXZvaWQgbGV0dGluZyB0aGUgYnJvd3NlciBwYWludCBpZiBwb3NzaWJsZSBvbiB0aGUgZmlyc3QgdHJ5LFxuICAgICAgICAgICAgICAvLyBvdGhlcndpc2UgdXNlIHJBRi4gRG9uJ3QgdHJ5IG1vcmUgdGhhbiB0d2ljZSwgc2luY2Ugc29tZXRoaW5nXG4gICAgICAgICAgICAgIC8vIGlzIHdyb25nIG90aGVyd2lzZS5cbiAgICAgICAgICAgICAgaWYgKHJ1bnMgPCAyKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2NoZWR1bGVyID0gcnVucyA/IHJlcXVlc3RBbmltYXRpb25GcmFtZSA6IHF1ZXVlTWljcm90YXNrO1xuICAgICAgICAgICAgICAgIHNjaGVkdWxlcih3YWl0Rm9yTGlzdFBvcHVsYXRlZCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcnVucysrO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgaW5kZXhSZWYuY3VycmVudCA9IGtleVJlZi5jdXJyZW50ID09IG51bGwgfHwgaXNNYWluT3JpZW50YXRpb25Ub0VuZEtleShrZXlSZWYuY3VycmVudCwgb3JpZW50YXRpb24sIHJ0bCkgfHwgbmVzdGVkID8gZ2V0TWluSW5kZXgobGlzdFJlZiwgZGlzYWJsZWRJbmRpY2VzUmVmLmN1cnJlbnQpIDogZ2V0TWF4SW5kZXgobGlzdFJlZiwgZGlzYWJsZWRJbmRpY2VzUmVmLmN1cnJlbnQpO1xuICAgICAgICAgICAgICBrZXlSZWYuY3VycmVudCA9IG51bGw7XG4gICAgICAgICAgICAgIG9uTmF2aWdhdGUoaW5kZXhSZWYuY3VycmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgICB3YWl0Rm9yTGlzdFBvcHVsYXRlZCgpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKCFpc0luZGV4T3V0T2ZCb3VuZHMobGlzdFJlZiwgYWN0aXZlSW5kZXgpKSB7XG4gICAgICAgIGluZGV4UmVmLmN1cnJlbnQgPSBhY3RpdmVJbmRleDtcbiAgICAgICAgZm9jdXNJdGVtKGxpc3RSZWYsIGluZGV4UmVmLCBmb3JjZVNjcm9sbEludG9WaWV3UmVmLmN1cnJlbnQpO1xuICAgICAgICBmb3JjZVNjcm9sbEludG9WaWV3UmVmLmN1cnJlbnQgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIFtlbmFibGVkLCBvcGVuLCBmbG9hdGluZywgYWN0aXZlSW5kZXgsIHNlbGVjdGVkSW5kZXgsIG5lc3RlZCwgbGlzdFJlZiwgb3JpZW50YXRpb24sIHJ0bCwgb25OYXZpZ2F0ZSwgZm9jdXNJdGVtLCBkaXNhYmxlZEluZGljZXNSZWZdKTtcblxuICAvLyBFbnN1cmUgdGhlIHBhcmVudCBmbG9hdGluZyBlbGVtZW50IGhhcyBmb2N1cyB3aGVuIGEgbmVzdGVkIGNoaWxkIGNsb3Nlc1xuICAvLyB0byBhbGxvdyBhcnJvdyBrZXkgbmF2aWdhdGlvbiB0byB3b3JrIGFmdGVyIHRoZSBwb2ludGVyIGxlYXZlcyB0aGUgY2hpbGQuXG4gIGluZGV4KCgpID0+IHtcbiAgICB2YXIgX25vZGVzJGZpbmQ7XG4gICAgaWYgKCFlbmFibGVkIHx8IGZsb2F0aW5nIHx8ICF0cmVlIHx8IHZpcnR1YWwgfHwgIXByZXZpb3VzTW91bnRlZFJlZi5jdXJyZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IG5vZGVzID0gdHJlZS5ub2Rlc1JlZi5jdXJyZW50O1xuICAgIGNvbnN0IHBhcmVudCA9IChfbm9kZXMkZmluZCA9IG5vZGVzLmZpbmQobm9kZSA9PiBub2RlLmlkID09PSBwYXJlbnRJZCkpID09IG51bGwgfHwgKF9ub2RlcyRmaW5kID0gX25vZGVzJGZpbmQuY29udGV4dCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9ub2RlcyRmaW5kLmVsZW1lbnRzLmZsb2F0aW5nO1xuICAgIGNvbnN0IGFjdGl2ZUVsID0gYWN0aXZlRWxlbWVudChnZXREb2N1bWVudChmbG9hdGluZykpO1xuICAgIGNvbnN0IHRyZWVDb250YWluc0FjdGl2ZUVsID0gbm9kZXMuc29tZShub2RlID0+IG5vZGUuY29udGV4dCAmJiBjb250YWlucyhub2RlLmNvbnRleHQuZWxlbWVudHMuZmxvYXRpbmcsIGFjdGl2ZUVsKSk7XG4gICAgaWYgKHBhcmVudCAmJiAhdHJlZUNvbnRhaW5zQWN0aXZlRWwgJiYgaXNQb2ludGVyTW9kYWxpdHlSZWYuY3VycmVudCkge1xuICAgICAgcGFyZW50LmZvY3VzKHtcbiAgICAgICAgcHJldmVudFNjcm9sbDogdHJ1ZVxuICAgICAgfSk7XG4gICAgfVxuICB9LCBbZW5hYmxlZCwgZmxvYXRpbmcsIHRyZWUsIHBhcmVudElkLCB2aXJ0dWFsXSk7XG4gIGluZGV4KCgpID0+IHtcbiAgICBpZiAoIWVuYWJsZWQgfHwgIXRyZWUgfHwgIXZpcnR1YWwgfHwgcGFyZW50SWQpIHJldHVybjtcbiAgICBmdW5jdGlvbiBoYW5kbGVWaXJ0dWFsRm9jdXMoaXRlbSkge1xuICAgICAgc2V0VmlydHVhbElkKGl0ZW0uaWQpO1xuICAgICAgaWYgKHZpcnR1YWxJdGVtUmVmKSB7XG4gICAgICAgIHZpcnR1YWxJdGVtUmVmLmN1cnJlbnQgPSBpdGVtO1xuICAgICAgfVxuICAgIH1cbiAgICB0cmVlLmV2ZW50cy5vbigndmlydHVhbGZvY3VzJywgaGFuZGxlVmlydHVhbEZvY3VzKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgdHJlZS5ldmVudHMub2ZmKCd2aXJ0dWFsZm9jdXMnLCBoYW5kbGVWaXJ0dWFsRm9jdXMpO1xuICAgIH07XG4gIH0sIFtlbmFibGVkLCB0cmVlLCB2aXJ0dWFsLCBwYXJlbnRJZCwgdmlydHVhbEl0ZW1SZWZdKTtcbiAgaW5kZXgoKCkgPT4ge1xuICAgIHByZXZpb3VzT25OYXZpZ2F0ZVJlZi5jdXJyZW50ID0gb25OYXZpZ2F0ZTtcbiAgICBwcmV2aW91c01vdW50ZWRSZWYuY3VycmVudCA9ICEhZmxvYXRpbmc7XG4gIH0pO1xuICBpbmRleCgoKSA9PiB7XG4gICAgaWYgKCFvcGVuKSB7XG4gICAgICBrZXlSZWYuY3VycmVudCA9IG51bGw7XG4gICAgfVxuICB9LCBbb3Blbl0pO1xuICBjb25zdCBoYXNBY3RpdmVJbmRleCA9IGFjdGl2ZUluZGV4ICE9IG51bGw7XG4gIGNvbnN0IGl0ZW0gPSBSZWFjdC51c2VNZW1vKCgpID0+IHtcbiAgICBmdW5jdGlvbiBzeW5jQ3VycmVudFRhcmdldChjdXJyZW50VGFyZ2V0KSB7XG4gICAgICBpZiAoIW9wZW4pIHJldHVybjtcbiAgICAgIGNvbnN0IGluZGV4ID0gbGlzdFJlZi5jdXJyZW50LmluZGV4T2YoY3VycmVudFRhcmdldCk7XG4gICAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICAgIG9uTmF2aWdhdGUoaW5kZXgpO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBwcm9wcyA9IHtcbiAgICAgIG9uRm9jdXMoX3JlZikge1xuICAgICAgICBsZXQge1xuICAgICAgICAgIGN1cnJlbnRUYXJnZXRcbiAgICAgICAgfSA9IF9yZWY7XG4gICAgICAgIHN5bmNDdXJyZW50VGFyZ2V0KGN1cnJlbnRUYXJnZXQpO1xuICAgICAgfSxcbiAgICAgIG9uQ2xpY2s6IF9yZWYyID0+IHtcbiAgICAgICAgbGV0IHtcbiAgICAgICAgICBjdXJyZW50VGFyZ2V0XG4gICAgICAgIH0gPSBfcmVmMjtcbiAgICAgICAgcmV0dXJuIGN1cnJlbnRUYXJnZXQuZm9jdXMoe1xuICAgICAgICAgIHByZXZlbnRTY3JvbGw6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICB9LFxuICAgICAgLy8gU2FmYXJpXG4gICAgICAuLi4oZm9jdXNJdGVtT25Ib3ZlciAmJiB7XG4gICAgICAgIG9uTW91c2VNb3ZlKF9yZWYzKSB7XG4gICAgICAgICAgbGV0IHtcbiAgICAgICAgICAgIGN1cnJlbnRUYXJnZXRcbiAgICAgICAgICB9ID0gX3JlZjM7XG4gICAgICAgICAgc3luY0N1cnJlbnRUYXJnZXQoY3VycmVudFRhcmdldCk7XG4gICAgICAgIH0sXG4gICAgICAgIG9uUG9pbnRlckxlYXZlKF9yZWY0KSB7XG4gICAgICAgICAgbGV0IHtcbiAgICAgICAgICAgIHBvaW50ZXJUeXBlXG4gICAgICAgICAgfSA9IF9yZWY0O1xuICAgICAgICAgIGlmICghaXNQb2ludGVyTW9kYWxpdHlSZWYuY3VycmVudCB8fCBwb2ludGVyVHlwZSA9PT0gJ3RvdWNoJykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpbmRleFJlZi5jdXJyZW50ID0gLTE7XG4gICAgICAgICAgZm9jdXNJdGVtKGxpc3RSZWYsIGluZGV4UmVmKTtcbiAgICAgICAgICBvbk5hdmlnYXRlKG51bGwpO1xuICAgICAgICAgIGlmICghdmlydHVhbCkge1xuICAgICAgICAgICAgZW5xdWV1ZUZvY3VzKHJlZnMuZmxvYXRpbmcuY3VycmVudCwge1xuICAgICAgICAgICAgICBwcmV2ZW50U2Nyb2xsOiB0cnVlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfTtcbiAgICByZXR1cm4gcHJvcHM7XG4gIH0sIFtvcGVuLCByZWZzLCBmb2N1c0l0ZW0sIGZvY3VzSXRlbU9uSG92ZXIsIGxpc3RSZWYsIG9uTmF2aWdhdGUsIHZpcnR1YWxdKTtcbiAgcmV0dXJuIFJlYWN0LnVzZU1lbW8oKCkgPT4ge1xuICAgIGlmICghZW5hYmxlZCkge1xuICAgICAgcmV0dXJuIHt9O1xuICAgIH1cbiAgICBjb25zdCBkaXNhYmxlZEluZGljZXMgPSBkaXNhYmxlZEluZGljZXNSZWYuY3VycmVudDtcbiAgICBmdW5jdGlvbiBvbktleURvd24oZXZlbnQpIHtcbiAgICAgIGlzUG9pbnRlck1vZGFsaXR5UmVmLmN1cnJlbnQgPSBmYWxzZTtcbiAgICAgIGZvcmNlU3luY0ZvY3VzLmN1cnJlbnQgPSB0cnVlO1xuXG4gICAgICAvLyBJZiB0aGUgZmxvYXRpbmcgZWxlbWVudCBpcyBhbmltYXRpbmcgb3V0LCBpZ25vcmUgbmF2aWdhdGlvbi4gT3RoZXJ3aXNlLFxuICAgICAgLy8gdGhlIGBhY3RpdmVJbmRleGAgZ2V0cyBzZXQgdG8gMCBkZXNwaXRlIG5vdCBiZWluZyBvcGVuIHNvIHRoZSBuZXh0IHRpbWVcbiAgICAgIC8vIHRoZSB1c2VyIEFycm93RG93bnMsIHRoZSBmaXJzdCBpdGVtIHdvbid0IGJlIGZvY3VzZWQuXG4gICAgICBpZiAoIWxhdGVzdE9wZW5SZWYuY3VycmVudCAmJiBldmVudC5jdXJyZW50VGFyZ2V0ID09PSByZWZzLmZsb2F0aW5nLmN1cnJlbnQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKG5lc3RlZCAmJiBpc0Nyb3NzT3JpZW50YXRpb25DbG9zZUtleShldmVudC5rZXksIG9yaWVudGF0aW9uLCBydGwpKSB7XG4gICAgICAgIHN0b3BFdmVudChldmVudCk7XG4gICAgICAgIG9uT3BlbkNoYW5nZShmYWxzZSwgZXZlbnQubmF0aXZlRXZlbnQsICdsaXN0LW5hdmlnYXRpb24nKTtcbiAgICAgICAgaWYgKGlzSFRNTEVsZW1lbnQoZG9tUmVmZXJlbmNlKSAmJiAhdmlydHVhbCkge1xuICAgICAgICAgIGRvbVJlZmVyZW5jZS5mb2N1cygpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGN1cnJlbnRJbmRleCA9IGluZGV4UmVmLmN1cnJlbnQ7XG4gICAgICBjb25zdCBtaW5JbmRleCA9IGdldE1pbkluZGV4KGxpc3RSZWYsIGRpc2FibGVkSW5kaWNlcyk7XG4gICAgICBjb25zdCBtYXhJbmRleCA9IGdldE1heEluZGV4KGxpc3RSZWYsIGRpc2FibGVkSW5kaWNlcyk7XG4gICAgICBpZiAoZXZlbnQua2V5ID09PSAnSG9tZScpIHtcbiAgICAgICAgc3RvcEV2ZW50KGV2ZW50KTtcbiAgICAgICAgaW5kZXhSZWYuY3VycmVudCA9IG1pbkluZGV4O1xuICAgICAgICBvbk5hdmlnYXRlKGluZGV4UmVmLmN1cnJlbnQpO1xuICAgICAgfVxuICAgICAgaWYgKGV2ZW50LmtleSA9PT0gJ0VuZCcpIHtcbiAgICAgICAgc3RvcEV2ZW50KGV2ZW50KTtcbiAgICAgICAgaW5kZXhSZWYuY3VycmVudCA9IG1heEluZGV4O1xuICAgICAgICBvbk5hdmlnYXRlKGluZGV4UmVmLmN1cnJlbnQpO1xuICAgICAgfVxuXG4gICAgICAvLyBHcmlkIG5hdmlnYXRpb24uXG4gICAgICBpZiAoY29scyA+IDEpIHtcbiAgICAgICAgY29uc3Qgc2l6ZXMgPSBpdGVtU2l6ZXMgfHwgQXJyYXkuZnJvbSh7XG4gICAgICAgICAgbGVuZ3RoOiBsaXN0UmVmLmN1cnJlbnQubGVuZ3RoXG4gICAgICAgIH0sICgpID0+ICh7XG4gICAgICAgICAgd2lkdGg6IDEsXG4gICAgICAgICAgaGVpZ2h0OiAxXG4gICAgICAgIH0pKTtcbiAgICAgICAgLy8gVG8gY2FsY3VsYXRlIG1vdmVtZW50cyBvbiB0aGUgZ3JpZCwgd2UgdXNlIGh5cG90aGV0aWNhbCBjZWxsIGluZGljZXNcbiAgICAgICAgLy8gYXMgaWYgZXZlcnkgaXRlbSB3YXMgMXgxLCB0aGVuIGNvbnZlcnQgYmFjayB0byByZWFsIGluZGljZXMuXG4gICAgICAgIGNvbnN0IGNlbGxNYXAgPSBidWlsZENlbGxNYXAoc2l6ZXMsIGNvbHMsIGRlbnNlKTtcbiAgICAgICAgY29uc3QgbWluR3JpZEluZGV4ID0gY2VsbE1hcC5maW5kSW5kZXgoaW5kZXggPT4gaW5kZXggIT0gbnVsbCAmJiAhKGRpc2FibGVkSW5kaWNlcyAhPSBudWxsICYmIGRpc2FibGVkSW5kaWNlcy5pbmNsdWRlcyhpbmRleCkpKTtcbiAgICAgICAgLy8gbGFzdCBlbmFibGVkIGluZGV4XG4gICAgICAgIGNvbnN0IG1heEdyaWRJbmRleCA9IGNlbGxNYXAucmVkdWNlKChmb3VuZEluZGV4LCBpbmRleCwgY2VsbEluZGV4KSA9PiBpbmRleCAhPSBudWxsICYmICEoZGlzYWJsZWRJbmRpY2VzICE9IG51bGwgJiYgZGlzYWJsZWRJbmRpY2VzLmluY2x1ZGVzKGluZGV4KSkgPyBjZWxsSW5kZXggOiBmb3VuZEluZGV4LCAtMSk7XG4gICAgICAgIGluZGV4UmVmLmN1cnJlbnQgPSBjZWxsTWFwW2dldEdyaWROYXZpZ2F0ZWRJbmRleCh7XG4gICAgICAgICAgY3VycmVudDogY2VsbE1hcC5tYXAoaXRlbUluZGV4ID0+IGl0ZW1JbmRleCAhPSBudWxsID8gbGlzdFJlZi5jdXJyZW50W2l0ZW1JbmRleF0gOiBudWxsKVxuICAgICAgICB9LCB7XG4gICAgICAgICAgZXZlbnQsXG4gICAgICAgICAgb3JpZW50YXRpb24sXG4gICAgICAgICAgbG9vcCxcbiAgICAgICAgICBjb2xzLFxuICAgICAgICAgIC8vIHRyZWF0IHVuZGVmaW5lZCAoZW1wdHkgZ3JpZCBzcGFjZXMpIGFzIGRpc2FibGVkIGluZGljZXMgc28gd2VcbiAgICAgICAgICAvLyBkb24ndCBlbmQgdXAgaW4gdGhlbVxuICAgICAgICAgIGRpc2FibGVkSW5kaWNlczogZ2V0Q2VsbEluZGljZXMoWy4uLihkaXNhYmxlZEluZGljZXMgfHwgW10pLCB1bmRlZmluZWRdLCBjZWxsTWFwKSxcbiAgICAgICAgICBtaW5JbmRleDogbWluR3JpZEluZGV4LFxuICAgICAgICAgIG1heEluZGV4OiBtYXhHcmlkSW5kZXgsXG4gICAgICAgICAgcHJldkluZGV4OiBnZXRDZWxsSW5kZXhPZkNvcm5lcihpbmRleFJlZi5jdXJyZW50LCBzaXplcywgY2VsbE1hcCwgY29scyxcbiAgICAgICAgICAvLyB1c2UgYSBjb3JuZXIgbWF0Y2hpbmcgdGhlIGVkZ2UgY2xvc2VzdCB0byB0aGUgZGlyZWN0aW9uXG4gICAgICAgICAgLy8gd2UncmUgbW92aW5nIGluIHNvIHdlIGRvbid0IGVuZCB1cCBpbiB0aGUgc2FtZSBpdGVtLiBQcmVmZXJcbiAgICAgICAgICAvLyB0b3AvbGVmdCBvdmVyIGJvdHRvbS9yaWdodC5cbiAgICAgICAgICBldmVudC5rZXkgPT09IEFSUk9XX0RPV04gPyAnYmwnIDogZXZlbnQua2V5ID09PSBBUlJPV19SSUdIVCA/ICd0cicgOiAndGwnKSxcbiAgICAgICAgICBzdG9wRXZlbnQ6IHRydWVcbiAgICAgICAgfSldOyAvLyBuYXZpZ2F0ZWQgY2VsbCB3aWxsIG5ldmVyIGJlIG51bGxpc2hcblxuICAgICAgICBvbk5hdmlnYXRlKGluZGV4UmVmLmN1cnJlbnQpO1xuICAgICAgICBpZiAob3JpZW50YXRpb24gPT09ICdib3RoJykge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGlzTWFpbk9yaWVudGF0aW9uS2V5KGV2ZW50LmtleSwgb3JpZW50YXRpb24pKSB7XG4gICAgICAgIHN0b3BFdmVudChldmVudCk7XG5cbiAgICAgICAgLy8gUmVzZXQgdGhlIGluZGV4IGlmIG5vIGl0ZW0gaXMgZm9jdXNlZC5cbiAgICAgICAgaWYgKG9wZW4gJiYgIXZpcnR1YWwgJiYgYWN0aXZlRWxlbWVudChldmVudC5jdXJyZW50VGFyZ2V0Lm93bmVyRG9jdW1lbnQpID09PSBldmVudC5jdXJyZW50VGFyZ2V0KSB7XG4gICAgICAgICAgaW5kZXhSZWYuY3VycmVudCA9IGlzTWFpbk9yaWVudGF0aW9uVG9FbmRLZXkoZXZlbnQua2V5LCBvcmllbnRhdGlvbiwgcnRsKSA/IG1pbkluZGV4IDogbWF4SW5kZXg7XG4gICAgICAgICAgb25OYXZpZ2F0ZShpbmRleFJlZi5jdXJyZW50KTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzTWFpbk9yaWVudGF0aW9uVG9FbmRLZXkoZXZlbnQua2V5LCBvcmllbnRhdGlvbiwgcnRsKSkge1xuICAgICAgICAgIGlmIChsb29wKSB7XG4gICAgICAgICAgICBpbmRleFJlZi5jdXJyZW50ID0gY3VycmVudEluZGV4ID49IG1heEluZGV4ID8gYWxsb3dFc2NhcGUgJiYgY3VycmVudEluZGV4ICE9PSBsaXN0UmVmLmN1cnJlbnQubGVuZ3RoID8gLTEgOiBtaW5JbmRleCA6IGZpbmROb25EaXNhYmxlZEluZGV4KGxpc3RSZWYsIHtcbiAgICAgICAgICAgICAgc3RhcnRpbmdJbmRleDogY3VycmVudEluZGV4LFxuICAgICAgICAgICAgICBkaXNhYmxlZEluZGljZXNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpbmRleFJlZi5jdXJyZW50ID0gTWF0aC5taW4obWF4SW5kZXgsIGZpbmROb25EaXNhYmxlZEluZGV4KGxpc3RSZWYsIHtcbiAgICAgICAgICAgICAgc3RhcnRpbmdJbmRleDogY3VycmVudEluZGV4LFxuICAgICAgICAgICAgICBkaXNhYmxlZEluZGljZXNcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKGxvb3ApIHtcbiAgICAgICAgICAgIGluZGV4UmVmLmN1cnJlbnQgPSBjdXJyZW50SW5kZXggPD0gbWluSW5kZXggPyBhbGxvd0VzY2FwZSAmJiBjdXJyZW50SW5kZXggIT09IC0xID8gbGlzdFJlZi5jdXJyZW50Lmxlbmd0aCA6IG1heEluZGV4IDogZmluZE5vbkRpc2FibGVkSW5kZXgobGlzdFJlZiwge1xuICAgICAgICAgICAgICBzdGFydGluZ0luZGV4OiBjdXJyZW50SW5kZXgsXG4gICAgICAgICAgICAgIGRlY3JlbWVudDogdHJ1ZSxcbiAgICAgICAgICAgICAgZGlzYWJsZWRJbmRpY2VzXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaW5kZXhSZWYuY3VycmVudCA9IE1hdGgubWF4KG1pbkluZGV4LCBmaW5kTm9uRGlzYWJsZWRJbmRleChsaXN0UmVmLCB7XG4gICAgICAgICAgICAgIHN0YXJ0aW5nSW5kZXg6IGN1cnJlbnRJbmRleCxcbiAgICAgICAgICAgICAgZGVjcmVtZW50OiB0cnVlLFxuICAgICAgICAgICAgICBkaXNhYmxlZEluZGljZXNcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzSW5kZXhPdXRPZkJvdW5kcyhsaXN0UmVmLCBpbmRleFJlZi5jdXJyZW50KSkge1xuICAgICAgICAgIG9uTmF2aWdhdGUobnVsbCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb25OYXZpZ2F0ZShpbmRleFJlZi5jdXJyZW50KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBjaGVja1ZpcnR1YWxNb3VzZShldmVudCkge1xuICAgICAgaWYgKGZvY3VzSXRlbU9uT3BlbiA9PT0gJ2F1dG8nICYmIGlzVmlydHVhbENsaWNrKGV2ZW50Lm5hdGl2ZUV2ZW50KSkge1xuICAgICAgICBmb2N1c0l0ZW1Pbk9wZW5SZWYuY3VycmVudCA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNoZWNrVmlydHVhbFBvaW50ZXIoZXZlbnQpIHtcbiAgICAgIC8vIGBwb2ludGVyZG93bmAgZmlyZXMgZmlyc3QsIHJlc2V0IHRoZSBzdGF0ZSB0aGVuIHBlcmZvcm0gdGhlIGNoZWNrcy5cbiAgICAgIGZvY3VzSXRlbU9uT3BlblJlZi5jdXJyZW50ID0gZm9jdXNJdGVtT25PcGVuO1xuICAgICAgaWYgKGZvY3VzSXRlbU9uT3BlbiA9PT0gJ2F1dG8nICYmIGlzVmlydHVhbFBvaW50ZXJFdmVudChldmVudC5uYXRpdmVFdmVudCkpIHtcbiAgICAgICAgZm9jdXNJdGVtT25PcGVuUmVmLmN1cnJlbnQgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBhcmlhQWN0aXZlRGVzY2VuZGFudFByb3AgPSB2aXJ0dWFsICYmIG9wZW4gJiYgaGFzQWN0aXZlSW5kZXggJiYge1xuICAgICAgJ2FyaWEtYWN0aXZlZGVzY2VuZGFudCc6IHZpcnR1YWxJZCB8fCBhY3RpdmVJZFxuICAgIH07XG4gICAgY29uc3QgYWN0aXZlSXRlbSA9IGxpc3RSZWYuY3VycmVudC5maW5kKGl0ZW0gPT4gKGl0ZW0gPT0gbnVsbCA/IHZvaWQgMCA6IGl0ZW0uaWQpID09PSBhY3RpdmVJZCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJlZmVyZW5jZToge1xuICAgICAgICAuLi5hcmlhQWN0aXZlRGVzY2VuZGFudFByb3AsXG4gICAgICAgIG9uS2V5RG93bihldmVudCkge1xuICAgICAgICAgIGlzUG9pbnRlck1vZGFsaXR5UmVmLmN1cnJlbnQgPSBmYWxzZTtcbiAgICAgICAgICBjb25zdCBpc0Fycm93S2V5ID0gZXZlbnQua2V5LmluZGV4T2YoJ0Fycm93JykgPT09IDA7XG4gICAgICAgICAgY29uc3QgaXNDcm9zc09wZW5LZXkgPSBpc0Nyb3NzT3JpZW50YXRpb25PcGVuS2V5KGV2ZW50LmtleSwgb3JpZW50YXRpb24sIHJ0bCk7XG4gICAgICAgICAgY29uc3QgaXNDcm9zc0Nsb3NlS2V5ID0gaXNDcm9zc09yaWVudGF0aW9uQ2xvc2VLZXkoZXZlbnQua2V5LCBvcmllbnRhdGlvbiwgcnRsKTtcbiAgICAgICAgICBjb25zdCBpc01haW5LZXkgPSBpc01haW5PcmllbnRhdGlvbktleShldmVudC5rZXksIG9yaWVudGF0aW9uKTtcbiAgICAgICAgICBjb25zdCBpc05hdmlnYXRpb25LZXkgPSAobmVzdGVkID8gaXNDcm9zc09wZW5LZXkgOiBpc01haW5LZXkpIHx8IGV2ZW50LmtleSA9PT0gJ0VudGVyJyB8fCBldmVudC5rZXkudHJpbSgpID09PSAnJztcbiAgICAgICAgICBpZiAodmlydHVhbCAmJiBvcGVuKSB7XG4gICAgICAgICAgICBjb25zdCByb290Tm9kZSA9IHRyZWUgPT0gbnVsbCA/IHZvaWQgMCA6IHRyZWUubm9kZXNSZWYuY3VycmVudC5maW5kKG5vZGUgPT4gbm9kZS5wYXJlbnRJZCA9PSBudWxsKTtcbiAgICAgICAgICAgIGNvbnN0IGRlZXBlc3ROb2RlID0gdHJlZSAmJiByb290Tm9kZSA/IGdldERlZXBlc3ROb2RlKHRyZWUubm9kZXNSZWYuY3VycmVudCwgcm9vdE5vZGUuaWQpIDogbnVsbDtcbiAgICAgICAgICAgIGlmIChpc0Fycm93S2V5ICYmIGRlZXBlc3ROb2RlICYmIHZpcnR1YWxJdGVtUmVmKSB7XG4gICAgICAgICAgICAgIGNvbnN0IGV2ZW50T2JqZWN0ID0gbmV3IEtleWJvYXJkRXZlbnQoJ2tleWRvd24nLCB7XG4gICAgICAgICAgICAgICAga2V5OiBldmVudC5rZXksXG4gICAgICAgICAgICAgICAgYnViYmxlczogdHJ1ZVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgaWYgKGlzQ3Jvc3NPcGVuS2V5IHx8IGlzQ3Jvc3NDbG9zZUtleSkge1xuICAgICAgICAgICAgICAgIHZhciBfZGVlcGVzdE5vZGUkY29udGV4dCwgX2RlZXBlc3ROb2RlJGNvbnRleHQyO1xuICAgICAgICAgICAgICAgIGNvbnN0IGlzQ3VycmVudFRhcmdldCA9ICgoX2RlZXBlc3ROb2RlJGNvbnRleHQgPSBkZWVwZXN0Tm9kZS5jb250ZXh0KSA9PSBudWxsID8gdm9pZCAwIDogX2RlZXBlc3ROb2RlJGNvbnRleHQuZWxlbWVudHMuZG9tUmVmZXJlbmNlKSA9PT0gZXZlbnQuY3VycmVudFRhcmdldDtcbiAgICAgICAgICAgICAgICBjb25zdCBkaXNwYXRjaEl0ZW0gPSBpc0Nyb3NzQ2xvc2VLZXkgJiYgIWlzQ3VycmVudFRhcmdldCA/IChfZGVlcGVzdE5vZGUkY29udGV4dDIgPSBkZWVwZXN0Tm9kZS5jb250ZXh0KSA9PSBudWxsID8gdm9pZCAwIDogX2RlZXBlc3ROb2RlJGNvbnRleHQyLmVsZW1lbnRzLmRvbVJlZmVyZW5jZSA6IGlzQ3Jvc3NPcGVuS2V5ID8gYWN0aXZlSXRlbSA6IG51bGw7XG4gICAgICAgICAgICAgICAgaWYgKGRpc3BhdGNoSXRlbSkge1xuICAgICAgICAgICAgICAgICAgc3RvcEV2ZW50KGV2ZW50KTtcbiAgICAgICAgICAgICAgICAgIGRpc3BhdGNoSXRlbS5kaXNwYXRjaEV2ZW50KGV2ZW50T2JqZWN0KTtcbiAgICAgICAgICAgICAgICAgIHNldFZpcnR1YWxJZCh1bmRlZmluZWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoaXNNYWluS2V5ICYmIGRlZXBlc3ROb2RlLmNvbnRleHQpIHtcbiAgICAgICAgICAgICAgICBpZiAoZGVlcGVzdE5vZGUuY29udGV4dC5vcGVuICYmIGRlZXBlc3ROb2RlLnBhcmVudElkICYmIGV2ZW50LmN1cnJlbnRUYXJnZXQgIT09IGRlZXBlc3ROb2RlLmNvbnRleHQuZWxlbWVudHMuZG9tUmVmZXJlbmNlKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgX2RlZXBlc3ROb2RlJGNvbnRleHQkO1xuICAgICAgICAgICAgICAgICAgc3RvcEV2ZW50KGV2ZW50KTtcbiAgICAgICAgICAgICAgICAgIChfZGVlcGVzdE5vZGUkY29udGV4dCQgPSBkZWVwZXN0Tm9kZS5jb250ZXh0LmVsZW1lbnRzLmRvbVJlZmVyZW5jZSkgPT0gbnVsbCB8fCBfZGVlcGVzdE5vZGUkY29udGV4dCQuZGlzcGF0Y2hFdmVudChldmVudE9iamVjdCk7XG4gICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gb25LZXlEb3duKGV2ZW50KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBJZiBhIGZsb2F0aW5nIGVsZW1lbnQgc2hvdWxkIG5vdCBvcGVuIG9uIGFycm93IGtleSBkb3duLCBhdm9pZFxuICAgICAgICAgIC8vIHNldHRpbmcgYGFjdGl2ZUluZGV4YCB3aGlsZSBpdCdzIGNsb3NlZC5cbiAgICAgICAgICBpZiAoIW9wZW4gJiYgIW9wZW5PbkFycm93S2V5RG93biAmJiBpc0Fycm93S2V5KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpc05hdmlnYXRpb25LZXkpIHtcbiAgICAgICAgICAgIGtleVJlZi5jdXJyZW50ID0gbmVzdGVkICYmIGlzTWFpbktleSA/IG51bGwgOiBldmVudC5rZXk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChuZXN0ZWQpIHtcbiAgICAgICAgICAgIGlmIChpc0Nyb3NzT3BlbktleSkge1xuICAgICAgICAgICAgICBzdG9wRXZlbnQoZXZlbnQpO1xuICAgICAgICAgICAgICBpZiAob3Blbikge1xuICAgICAgICAgICAgICAgIGluZGV4UmVmLmN1cnJlbnQgPSBnZXRNaW5JbmRleChsaXN0UmVmLCBkaXNhYmxlZEluZGljZXMpO1xuICAgICAgICAgICAgICAgIG9uTmF2aWdhdGUoaW5kZXhSZWYuY3VycmVudCk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgb25PcGVuQ2hhbmdlKHRydWUsIGV2ZW50Lm5hdGl2ZUV2ZW50LCAnbGlzdC1uYXZpZ2F0aW9uJyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGlzTWFpbktleSkge1xuICAgICAgICAgICAgaWYgKHNlbGVjdGVkSW5kZXggIT0gbnVsbCkge1xuICAgICAgICAgICAgICBpbmRleFJlZi5jdXJyZW50ID0gc2VsZWN0ZWRJbmRleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN0b3BFdmVudChldmVudCk7XG4gICAgICAgICAgICBpZiAoIW9wZW4gJiYgb3Blbk9uQXJyb3dLZXlEb3duKSB7XG4gICAgICAgICAgICAgIG9uT3BlbkNoYW5nZSh0cnVlLCBldmVudC5uYXRpdmVFdmVudCwgJ2xpc3QtbmF2aWdhdGlvbicpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgb25LZXlEb3duKGV2ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvcGVuKSB7XG4gICAgICAgICAgICAgIG9uTmF2aWdhdGUoaW5kZXhSZWYuY3VycmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBvbkZvY3VzKCkge1xuICAgICAgICAgIGlmIChvcGVuKSB7XG4gICAgICAgICAgICBvbk5hdmlnYXRlKG51bGwpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgb25Qb2ludGVyRG93bjogY2hlY2tWaXJ0dWFsUG9pbnRlcixcbiAgICAgICAgb25Nb3VzZURvd246IGNoZWNrVmlydHVhbE1vdXNlLFxuICAgICAgICBvbkNsaWNrOiBjaGVja1ZpcnR1YWxNb3VzZVxuICAgICAgfSxcbiAgICAgIGZsb2F0aW5nOiB7XG4gICAgICAgICdhcmlhLW9yaWVudGF0aW9uJzogb3JpZW50YXRpb24gPT09ICdib3RoJyA/IHVuZGVmaW5lZCA6IG9yaWVudGF0aW9uLFxuICAgICAgICAuLi4oIWlzVHlwZWFibGVDb21ib2JveChkb21SZWZlcmVuY2UpICYmIGFyaWFBY3RpdmVEZXNjZW5kYW50UHJvcCksXG4gICAgICAgIG9uS2V5RG93bixcbiAgICAgICAgb25Qb2ludGVyTW92ZSgpIHtcbiAgICAgICAgICBpc1BvaW50ZXJNb2RhbGl0eVJlZi5jdXJyZW50ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGl0ZW1cbiAgICB9O1xuICB9LCBbZG9tUmVmZXJlbmNlLCByZWZzLCBhY3RpdmVJZCwgdmlydHVhbElkLCBkaXNhYmxlZEluZGljZXNSZWYsIGxhdGVzdE9wZW5SZWYsIGxpc3RSZWYsIGVuYWJsZWQsIG9yaWVudGF0aW9uLCBydGwsIHZpcnR1YWwsIG9wZW4sIGhhc0FjdGl2ZUluZGV4LCBuZXN0ZWQsIHNlbGVjdGVkSW5kZXgsIG9wZW5PbkFycm93S2V5RG93biwgYWxsb3dFc2NhcGUsIGNvbHMsIGxvb3AsIGZvY3VzSXRlbU9uT3Blbiwgb25OYXZpZ2F0ZSwgb25PcGVuQ2hhbmdlLCBpdGVtLCB0cmVlLCB2aXJ0dWFsSXRlbVJlZiwgaXRlbVNpemVzLCBkZW5zZV0pO1xufVxuXG5jb25zdCBjb21wb25lbnRSb2xlVG9BcmlhUm9sZU1hcCA9IC8qI19fUFVSRV9fKi9uZXcgTWFwKFtbJ3NlbGVjdCcsICdsaXN0Ym94J10sIFsnY29tYm9ib3gnLCAnbGlzdGJveCddLCBbJ2xhYmVsJywgZmFsc2VdXSk7XG5cbi8qKlxuICogQWRkcyBiYXNlIHNjcmVlbiByZWFkZXIgcHJvcHMgdG8gdGhlIHJlZmVyZW5jZSBhbmQgZmxvYXRpbmcgZWxlbWVudHMgZm9yIGFcbiAqIGdpdmVuIGZsb2F0aW5nIGVsZW1lbnQgYHJvbGVgLlxuICogQHNlZSBodHRwczovL2Zsb2F0aW5nLXVpLmNvbS9kb2NzL3VzZVJvbGVcbiAqL1xuZnVuY3Rpb24gdXNlUm9sZShjb250ZXh0LCBwcm9wcykge1xuICB2YXIgX2NvbXBvbmVudFJvbGVUb0FyaWFSO1xuICBpZiAocHJvcHMgPT09IHZvaWQgMCkge1xuICAgIHByb3BzID0ge307XG4gIH1cbiAgY29uc3Qge1xuICAgIG9wZW4sXG4gICAgZmxvYXRpbmdJZFxuICB9ID0gY29udGV4dDtcbiAgY29uc3Qge1xuICAgIGVuYWJsZWQgPSB0cnVlLFxuICAgIHJvbGUgPSAnZGlhbG9nJ1xuICB9ID0gcHJvcHM7XG4gIGNvbnN0IGFyaWFSb2xlID0gKF9jb21wb25lbnRSb2xlVG9BcmlhUiA9IGNvbXBvbmVudFJvbGVUb0FyaWFSb2xlTWFwLmdldChyb2xlKSkgIT0gbnVsbCA/IF9jb21wb25lbnRSb2xlVG9BcmlhUiA6IHJvbGU7XG4gIGNvbnN0IHJlZmVyZW5jZUlkID0gdXNlSWQoKTtcbiAgY29uc3QgcGFyZW50SWQgPSB1c2VGbG9hdGluZ1BhcmVudE5vZGVJZCgpO1xuICBjb25zdCBpc05lc3RlZCA9IHBhcmVudElkICE9IG51bGw7XG4gIHJldHVybiBSZWFjdC51c2VNZW1vKCgpID0+IHtcbiAgICBpZiAoIWVuYWJsZWQpIHJldHVybiB7fTtcbiAgICBjb25zdCBmbG9hdGluZ1Byb3BzID0ge1xuICAgICAgaWQ6IGZsb2F0aW5nSWQsXG4gICAgICAuLi4oYXJpYVJvbGUgJiYge1xuICAgICAgICByb2xlOiBhcmlhUm9sZVxuICAgICAgfSlcbiAgICB9O1xuICAgIGlmIChhcmlhUm9sZSA9PT0gJ3Rvb2x0aXAnIHx8IHJvbGUgPT09ICdsYWJlbCcpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHJlZmVyZW5jZToge1xuICAgICAgICAgIFtcImFyaWEtXCIgKyAocm9sZSA9PT0gJ2xhYmVsJyA/ICdsYWJlbGxlZGJ5JyA6ICdkZXNjcmliZWRieScpXTogb3BlbiA/IGZsb2F0aW5nSWQgOiB1bmRlZmluZWRcbiAgICAgICAgfSxcbiAgICAgICAgZmxvYXRpbmc6IGZsb2F0aW5nUHJvcHNcbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICByZWZlcmVuY2U6IHtcbiAgICAgICAgJ2FyaWEtZXhwYW5kZWQnOiBvcGVuID8gJ3RydWUnIDogJ2ZhbHNlJyxcbiAgICAgICAgJ2FyaWEtaGFzcG9wdXAnOiBhcmlhUm9sZSA9PT0gJ2FsZXJ0ZGlhbG9nJyA/ICdkaWFsb2cnIDogYXJpYVJvbGUsXG4gICAgICAgICdhcmlhLWNvbnRyb2xzJzogb3BlbiA/IGZsb2F0aW5nSWQgOiB1bmRlZmluZWQsXG4gICAgICAgIC4uLihhcmlhUm9sZSA9PT0gJ2xpc3Rib3gnICYmIHtcbiAgICAgICAgICByb2xlOiAnY29tYm9ib3gnXG4gICAgICAgIH0pLFxuICAgICAgICAuLi4oYXJpYVJvbGUgPT09ICdtZW51JyAmJiB7XG4gICAgICAgICAgaWQ6IHJlZmVyZW5jZUlkXG4gICAgICAgIH0pLFxuICAgICAgICAuLi4oYXJpYVJvbGUgPT09ICdtZW51JyAmJiBpc05lc3RlZCAmJiB7XG4gICAgICAgICAgcm9sZTogJ21lbnVpdGVtJ1xuICAgICAgICB9KSxcbiAgICAgICAgLi4uKHJvbGUgPT09ICdzZWxlY3QnICYmIHtcbiAgICAgICAgICAnYXJpYS1hdXRvY29tcGxldGUnOiAnbm9uZSdcbiAgICAgICAgfSksXG4gICAgICAgIC4uLihyb2xlID09PSAnY29tYm9ib3gnICYmIHtcbiAgICAgICAgICAnYXJpYS1hdXRvY29tcGxldGUnOiAnbGlzdCdcbiAgICAgICAgfSlcbiAgICAgIH0sXG4gICAgICBmbG9hdGluZzoge1xuICAgICAgICAuLi5mbG9hdGluZ1Byb3BzLFxuICAgICAgICAuLi4oYXJpYVJvbGUgPT09ICdtZW51JyAmJiB7XG4gICAgICAgICAgJ2FyaWEtbGFiZWxsZWRieSc6IHJlZmVyZW5jZUlkXG4gICAgICAgIH0pXG4gICAgICB9LFxuICAgICAgaXRlbShfcmVmKSB7XG4gICAgICAgIGxldCB7XG4gICAgICAgICAgYWN0aXZlLFxuICAgICAgICAgIHNlbGVjdGVkXG4gICAgICAgIH0gPSBfcmVmO1xuICAgICAgICBjb25zdCBjb21tb25Qcm9wcyA9IHtcbiAgICAgICAgICByb2xlOiAnb3B0aW9uJyxcbiAgICAgICAgICAuLi4oYWN0aXZlICYmIHtcbiAgICAgICAgICAgIGlkOiBmbG9hdGluZ0lkICsgXCItb3B0aW9uXCJcbiAgICAgICAgICB9KVxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIEZvciBgbWVudWAsIHdlIGFyZSB1bmFibGUgdG8gdGVsbCBpZiB0aGUgaXRlbSBpcyBhIGBtZW51aXRlbXJhZGlvYFxuICAgICAgICAvLyBvciBgbWVudWl0ZW1jaGVja2JveGAuIEZvciBiYWNrd2FyZHMtY29tcGF0aWJpbGl0eSByZWFzb25zLCBhbHNvXG4gICAgICAgIC8vIGF2b2lkIGRlZmF1bHRpbmcgdG8gYG1lbnVpdGVtYCBhcyBpdCBtYXkgb3ZlcndyaXRlIGN1c3RvbSByb2xlIHByb3BzLlxuICAgICAgICBzd2l0Y2ggKHJvbGUpIHtcbiAgICAgICAgICBjYXNlICdzZWxlY3QnOlxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgLi4uY29tbW9uUHJvcHMsXG4gICAgICAgICAgICAgICdhcmlhLXNlbGVjdGVkJzogYWN0aXZlICYmIHNlbGVjdGVkXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIGNhc2UgJ2NvbWJvYm94JzpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAuLi5jb21tb25Qcm9wcyxcbiAgICAgICAgICAgICAgICAuLi4oYWN0aXZlICYmIHtcbiAgICAgICAgICAgICAgICAgICdhcmlhLXNlbGVjdGVkJzogdHJ1ZVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgfVxuICAgIH07XG4gIH0sIFtlbmFibGVkLCByb2xlLCBhcmlhUm9sZSwgb3BlbiwgZmxvYXRpbmdJZCwgcmVmZXJlbmNlSWQsIGlzTmVzdGVkXSk7XG59XG5cbi8vIENvbnZlcnRzIGEgSlMgc3R5bGUga2V5IGxpa2UgYGJhY2tncm91bmRDb2xvcmAgdG8gYSBDU1MgdHJhbnNpdGlvbi1wcm9wZXJ0eVxuLy8gbGlrZSBgYmFja2dyb3VuZC1jb2xvcmAuXG5jb25zdCBjYW1lbENhc2VUb0tlYmFiQ2FzZSA9IHN0ciA9PiBzdHIucmVwbGFjZSgvW0EtWl0rKD8hW2Etel0pfFtBLVpdL2csICgkLCBvZnMpID0+IChvZnMgPyAnLScgOiAnJykgKyAkLnRvTG93ZXJDYXNlKCkpO1xuZnVuY3Rpb24gZXhlY1dpdGhBcmdzT3JSZXR1cm4odmFsdWVPckZuLCBhcmdzKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWVPckZuID09PSAnZnVuY3Rpb24nID8gdmFsdWVPckZuKGFyZ3MpIDogdmFsdWVPckZuO1xufVxuZnVuY3Rpb24gdXNlRGVsYXlVbm1vdW50KG9wZW4sIGR1cmF0aW9uTXMpIHtcbiAgY29uc3QgW2lzTW91bnRlZCwgc2V0SXNNb3VudGVkXSA9IFJlYWN0LnVzZVN0YXRlKG9wZW4pO1xuICBpZiAob3BlbiAmJiAhaXNNb3VudGVkKSB7XG4gICAgc2V0SXNNb3VudGVkKHRydWUpO1xuICB9XG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKCFvcGVuKSB7XG4gICAgICBjb25zdCB0aW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiBzZXRJc01vdW50ZWQoZmFsc2UpLCBkdXJhdGlvbk1zKTtcbiAgICAgIHJldHVybiAoKSA9PiBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgfVxuICB9LCBbb3BlbiwgZHVyYXRpb25Nc10pO1xuICByZXR1cm4gaXNNb3VudGVkO1xufVxuLyoqXG4gKiBQcm92aWRlcyBhIHN0YXR1cyBzdHJpbmcgdG8gYXBwbHkgQ1NTIHRyYW5zaXRpb25zIHRvIGEgZmxvYXRpbmcgZWxlbWVudCxcbiAqIGNvcnJlY3RseSBoYW5kbGluZyBwbGFjZW1lbnQtYXdhcmUgdHJhbnNpdGlvbnMuXG4gKiBAc2VlIGh0dHBzOi8vZmxvYXRpbmctdWkuY29tL2RvY3MvdXNlVHJhbnNpdGlvbiN1c2V0cmFuc2l0aW9uc3RhdHVzXG4gKi9cbmZ1bmN0aW9uIHVzZVRyYW5zaXRpb25TdGF0dXMoY29udGV4dCwgcHJvcHMpIHtcbiAgaWYgKHByb3BzID09PSB2b2lkIDApIHtcbiAgICBwcm9wcyA9IHt9O1xuICB9XG4gIGNvbnN0IHtcbiAgICBvcGVuLFxuICAgIGVsZW1lbnRzOiB7XG4gICAgICBmbG9hdGluZ1xuICAgIH1cbiAgfSA9IGNvbnRleHQ7XG4gIGNvbnN0IHtcbiAgICBkdXJhdGlvbiA9IDI1MFxuICB9ID0gcHJvcHM7XG4gIGNvbnN0IGlzTnVtYmVyRHVyYXRpb24gPSB0eXBlb2YgZHVyYXRpb24gPT09ICdudW1iZXInO1xuICBjb25zdCBjbG9zZUR1cmF0aW9uID0gKGlzTnVtYmVyRHVyYXRpb24gPyBkdXJhdGlvbiA6IGR1cmF0aW9uLmNsb3NlKSB8fCAwO1xuICBjb25zdCBbaW5pdGlhdGVkLCBzZXRJbml0aWF0ZWRdID0gUmVhY3QudXNlU3RhdGUoZmFsc2UpO1xuICBjb25zdCBbc3RhdHVzLCBzZXRTdGF0dXNdID0gUmVhY3QudXNlU3RhdGUoJ3VubW91bnRlZCcpO1xuICBjb25zdCBpc01vdW50ZWQgPSB1c2VEZWxheVVubW91bnQob3BlbiwgY2xvc2VEdXJhdGlvbik7XG5cbiAgLy8gYGluaXRpYXRlZGAgY2hlY2sgcHJldmVudHMgdGhpcyBgc2V0U3RhdGVgIGNhbGwgZnJvbSBicmVha2luZ1xuICAvLyA8RmxvYXRpbmdQb3J0YWwgLz4uIFRoaXMgY2FsbCBpcyBuZWNlc3NhcnkgdG8gZW5zdXJlIHN1YnNlcXVlbnQgb3BlbnNcbiAgLy8gYWZ0ZXIgdGhlIGluaXRpYWwgb25lIGFsbG93cyB0aGUgY29ycmVjdCBzaWRlIGFuaW1hdGlvbiB0byBwbGF5IHdoZW4gdGhlXG4gIC8vIHBsYWNlbWVudCBoYXMgY2hhbmdlZC5cbiAgaW5kZXgoKCkgPT4ge1xuICAgIGlmIChpbml0aWF0ZWQgJiYgIWlzTW91bnRlZCkge1xuICAgICAgc2V0U3RhdHVzKCd1bm1vdW50ZWQnKTtcbiAgICB9XG4gIH0sIFtpbml0aWF0ZWQsIGlzTW91bnRlZF0pO1xuICBpbmRleCgoKSA9PiB7XG4gICAgaWYgKCFmbG9hdGluZykgcmV0dXJuO1xuICAgIGlmIChvcGVuKSB7XG4gICAgICBzZXRTdGF0dXMoJ2luaXRpYWwnKTtcbiAgICAgIGNvbnN0IGZyYW1lID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgICAgc2V0U3RhdHVzKCdvcGVuJyk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKGZyYW1lKTtcbiAgICAgIH07XG4gICAgfVxuICAgIHNldEluaXRpYXRlZCh0cnVlKTtcbiAgICBzZXRTdGF0dXMoJ2Nsb3NlJyk7XG4gIH0sIFtvcGVuLCBmbG9hdGluZ10pO1xuICByZXR1cm4ge1xuICAgIGlzTW91bnRlZCxcbiAgICBzdGF0dXNcbiAgfTtcbn1cbi8qKlxuICogUHJvdmlkZXMgc3R5bGVzIHRvIGFwcGx5IENTUyB0cmFuc2l0aW9ucyB0byBhIGZsb2F0aW5nIGVsZW1lbnQsIGNvcnJlY3RseVxuICogaGFuZGxpbmcgcGxhY2VtZW50LWF3YXJlIHRyYW5zaXRpb25zLiBXcmFwcGVyIGFyb3VuZCBgdXNlVHJhbnNpdGlvblN0YXR1c2AuXG4gKiBAc2VlIGh0dHBzOi8vZmxvYXRpbmctdWkuY29tL2RvY3MvdXNlVHJhbnNpdGlvbiN1c2V0cmFuc2l0aW9uc3R5bGVzXG4gKi9cbmZ1bmN0aW9uIHVzZVRyYW5zaXRpb25TdHlsZXMoY29udGV4dCwgcHJvcHMpIHtcbiAgaWYgKHByb3BzID09PSB2b2lkIDApIHtcbiAgICBwcm9wcyA9IHt9O1xuICB9XG4gIGNvbnN0IHtcbiAgICBpbml0aWFsOiB1bnN0YWJsZV9pbml0aWFsID0ge1xuICAgICAgb3BhY2l0eTogMFxuICAgIH0sXG4gICAgb3BlbjogdW5zdGFibGVfb3BlbixcbiAgICBjbG9zZTogdW5zdGFibGVfY2xvc2UsXG4gICAgY29tbW9uOiB1bnN0YWJsZV9jb21tb24sXG4gICAgZHVyYXRpb24gPSAyNTBcbiAgfSA9IHByb3BzO1xuICBjb25zdCBwbGFjZW1lbnQgPSBjb250ZXh0LnBsYWNlbWVudDtcbiAgY29uc3Qgc2lkZSA9IHBsYWNlbWVudC5zcGxpdCgnLScpWzBdO1xuICBjb25zdCBmbkFyZ3MgPSBSZWFjdC51c2VNZW1vKCgpID0+ICh7XG4gICAgc2lkZSxcbiAgICBwbGFjZW1lbnRcbiAgfSksIFtzaWRlLCBwbGFjZW1lbnRdKTtcbiAgY29uc3QgaXNOdW1iZXJEdXJhdGlvbiA9IHR5cGVvZiBkdXJhdGlvbiA9PT0gJ251bWJlcic7XG4gIGNvbnN0IG9wZW5EdXJhdGlvbiA9IChpc051bWJlckR1cmF0aW9uID8gZHVyYXRpb24gOiBkdXJhdGlvbi5vcGVuKSB8fCAwO1xuICBjb25zdCBjbG9zZUR1cmF0aW9uID0gKGlzTnVtYmVyRHVyYXRpb24gPyBkdXJhdGlvbiA6IGR1cmF0aW9uLmNsb3NlKSB8fCAwO1xuICBjb25zdCBbc3R5bGVzLCBzZXRTdHlsZXNdID0gUmVhY3QudXNlU3RhdGUoKCkgPT4gKHtcbiAgICAuLi5leGVjV2l0aEFyZ3NPclJldHVybih1bnN0YWJsZV9jb21tb24sIGZuQXJncyksXG4gICAgLi4uZXhlY1dpdGhBcmdzT3JSZXR1cm4odW5zdGFibGVfaW5pdGlhbCwgZm5BcmdzKVxuICB9KSk7XG4gIGNvbnN0IHtcbiAgICBpc01vdW50ZWQsXG4gICAgc3RhdHVzXG4gIH0gPSB1c2VUcmFuc2l0aW9uU3RhdHVzKGNvbnRleHQsIHtcbiAgICBkdXJhdGlvblxuICB9KTtcbiAgY29uc3QgaW5pdGlhbFJlZiA9IHVzZUxhdGVzdFJlZih1bnN0YWJsZV9pbml0aWFsKTtcbiAgY29uc3Qgb3BlblJlZiA9IHVzZUxhdGVzdFJlZih1bnN0YWJsZV9vcGVuKTtcbiAgY29uc3QgY2xvc2VSZWYgPSB1c2VMYXRlc3RSZWYodW5zdGFibGVfY2xvc2UpO1xuICBjb25zdCBjb21tb25SZWYgPSB1c2VMYXRlc3RSZWYodW5zdGFibGVfY29tbW9uKTtcbiAgaW5kZXgoKCkgPT4ge1xuICAgIGNvbnN0IGluaXRpYWxTdHlsZXMgPSBleGVjV2l0aEFyZ3NPclJldHVybihpbml0aWFsUmVmLmN1cnJlbnQsIGZuQXJncyk7XG4gICAgY29uc3QgY2xvc2VTdHlsZXMgPSBleGVjV2l0aEFyZ3NPclJldHVybihjbG9zZVJlZi5jdXJyZW50LCBmbkFyZ3MpO1xuICAgIGNvbnN0IGNvbW1vblN0eWxlcyA9IGV4ZWNXaXRoQXJnc09yUmV0dXJuKGNvbW1vblJlZi5jdXJyZW50LCBmbkFyZ3MpO1xuICAgIGNvbnN0IG9wZW5TdHlsZXMgPSBleGVjV2l0aEFyZ3NPclJldHVybihvcGVuUmVmLmN1cnJlbnQsIGZuQXJncykgfHwgT2JqZWN0LmtleXMoaW5pdGlhbFN0eWxlcykucmVkdWNlKChhY2MsIGtleSkgPT4ge1xuICAgICAgYWNjW2tleV0gPSAnJztcbiAgICAgIHJldHVybiBhY2M7XG4gICAgfSwge30pO1xuICAgIGlmIChzdGF0dXMgPT09ICdpbml0aWFsJykge1xuICAgICAgc2V0U3R5bGVzKHN0eWxlcyA9PiAoe1xuICAgICAgICB0cmFuc2l0aW9uUHJvcGVydHk6IHN0eWxlcy50cmFuc2l0aW9uUHJvcGVydHksXG4gICAgICAgIC4uLmNvbW1vblN0eWxlcyxcbiAgICAgICAgLi4uaW5pdGlhbFN0eWxlc1xuICAgICAgfSkpO1xuICAgIH1cbiAgICBpZiAoc3RhdHVzID09PSAnb3BlbicpIHtcbiAgICAgIHNldFN0eWxlcyh7XG4gICAgICAgIHRyYW5zaXRpb25Qcm9wZXJ0eTogT2JqZWN0LmtleXMob3BlblN0eWxlcykubWFwKGNhbWVsQ2FzZVRvS2ViYWJDYXNlKS5qb2luKCcsJyksXG4gICAgICAgIHRyYW5zaXRpb25EdXJhdGlvbjogb3BlbkR1cmF0aW9uICsgXCJtc1wiLFxuICAgICAgICAuLi5jb21tb25TdHlsZXMsXG4gICAgICAgIC4uLm9wZW5TdHlsZXNcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoc3RhdHVzID09PSAnY2xvc2UnKSB7XG4gICAgICBjb25zdCBzdHlsZXMgPSBjbG9zZVN0eWxlcyB8fCBpbml0aWFsU3R5bGVzO1xuICAgICAgc2V0U3R5bGVzKHtcbiAgICAgICAgdHJhbnNpdGlvblByb3BlcnR5OiBPYmplY3Qua2V5cyhzdHlsZXMpLm1hcChjYW1lbENhc2VUb0tlYmFiQ2FzZSkuam9pbignLCcpLFxuICAgICAgICB0cmFuc2l0aW9uRHVyYXRpb246IGNsb3NlRHVyYXRpb24gKyBcIm1zXCIsXG4gICAgICAgIC4uLmNvbW1vblN0eWxlcyxcbiAgICAgICAgLi4uc3R5bGVzXG4gICAgICB9KTtcbiAgICB9XG4gIH0sIFtjbG9zZUR1cmF0aW9uLCBjbG9zZVJlZiwgaW5pdGlhbFJlZiwgb3BlblJlZiwgY29tbW9uUmVmLCBvcGVuRHVyYXRpb24sIHN0YXR1cywgZm5BcmdzXSk7XG4gIHJldHVybiB7XG4gICAgaXNNb3VudGVkLFxuICAgIHN0eWxlc1xuICB9O1xufVxuXG4vKipcbiAqIFByb3ZpZGVzIGEgbWF0Y2hpbmcgY2FsbGJhY2sgdGhhdCBjYW4gYmUgdXNlZCB0byBmb2N1cyBhbiBpdGVtIGFzIHRoZSB1c2VyXG4gKiB0eXBlcywgb2Z0ZW4gdXNlZCBpbiB0YW5kZW0gd2l0aCBgdXNlTGlzdE5hdmlnYXRpb24oKWAuXG4gKiBAc2VlIGh0dHBzOi8vZmxvYXRpbmctdWkuY29tL2RvY3MvdXNlVHlwZWFoZWFkXG4gKi9cbmZ1bmN0aW9uIHVzZVR5cGVhaGVhZChjb250ZXh0LCBwcm9wcykge1xuICB2YXIgX3JlZjtcbiAgY29uc3Qge1xuICAgIG9wZW4sXG4gICAgZGF0YVJlZlxuICB9ID0gY29udGV4dDtcbiAgY29uc3Qge1xuICAgIGxpc3RSZWYsXG4gICAgYWN0aXZlSW5kZXgsXG4gICAgb25NYXRjaDogdW5zdGFibGVfb25NYXRjaCxcbiAgICBvblR5cGluZ0NoYW5nZTogdW5zdGFibGVfb25UeXBpbmdDaGFuZ2UsXG4gICAgZW5hYmxlZCA9IHRydWUsXG4gICAgZmluZE1hdGNoID0gbnVsbCxcbiAgICByZXNldE1zID0gNzUwLFxuICAgIGlnbm9yZUtleXMgPSBbXSxcbiAgICBzZWxlY3RlZEluZGV4ID0gbnVsbFxuICB9ID0gcHJvcHM7XG4gIGNvbnN0IHRpbWVvdXRJZFJlZiA9IFJlYWN0LnVzZVJlZigpO1xuICBjb25zdCBzdHJpbmdSZWYgPSBSZWFjdC51c2VSZWYoJycpO1xuICBjb25zdCBwcmV2SW5kZXhSZWYgPSBSZWFjdC51c2VSZWYoKF9yZWYgPSBzZWxlY3RlZEluZGV4ICE9IG51bGwgPyBzZWxlY3RlZEluZGV4IDogYWN0aXZlSW5kZXgpICE9IG51bGwgPyBfcmVmIDogLTEpO1xuICBjb25zdCBtYXRjaEluZGV4UmVmID0gUmVhY3QudXNlUmVmKG51bGwpO1xuICBjb25zdCBvbk1hdGNoID0gdXNlRWZmZWN0RXZlbnQodW5zdGFibGVfb25NYXRjaCk7XG4gIGNvbnN0IG9uVHlwaW5nQ2hhbmdlID0gdXNlRWZmZWN0RXZlbnQodW5zdGFibGVfb25UeXBpbmdDaGFuZ2UpO1xuICBjb25zdCBmaW5kTWF0Y2hSZWYgPSB1c2VMYXRlc3RSZWYoZmluZE1hdGNoKTtcbiAgY29uc3QgaWdub3JlS2V5c1JlZiA9IHVzZUxhdGVzdFJlZihpZ25vcmVLZXlzKTtcbiAgaW5kZXgoKCkgPT4ge1xuICAgIGlmIChvcGVuKSB7XG4gICAgICBjbGVhclRpbWVvdXQodGltZW91dElkUmVmLmN1cnJlbnQpO1xuICAgICAgbWF0Y2hJbmRleFJlZi5jdXJyZW50ID0gbnVsbDtcbiAgICAgIHN0cmluZ1JlZi5jdXJyZW50ID0gJyc7XG4gICAgfVxuICB9LCBbb3Blbl0pO1xuICBpbmRleCgoKSA9PiB7XG4gICAgLy8gU3luYyBhcnJvdyBrZXkgbmF2aWdhdGlvbiBidXQgbm90IHR5cGVhaGVhZCBuYXZpZ2F0aW9uLlxuICAgIGlmIChvcGVuICYmIHN0cmluZ1JlZi5jdXJyZW50ID09PSAnJykge1xuICAgICAgdmFyIF9yZWYyO1xuICAgICAgcHJldkluZGV4UmVmLmN1cnJlbnQgPSAoX3JlZjIgPSBzZWxlY3RlZEluZGV4ICE9IG51bGwgPyBzZWxlY3RlZEluZGV4IDogYWN0aXZlSW5kZXgpICE9IG51bGwgPyBfcmVmMiA6IC0xO1xuICAgIH1cbiAgfSwgW29wZW4sIHNlbGVjdGVkSW5kZXgsIGFjdGl2ZUluZGV4XSk7XG4gIHJldHVybiBSZWFjdC51c2VNZW1vKCgpID0+IHtcbiAgICBpZiAoIWVuYWJsZWQpIHtcbiAgICAgIHJldHVybiB7fTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc2V0VHlwaW5nQ2hhbmdlKHZhbHVlKSB7XG4gICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgaWYgKCFkYXRhUmVmLmN1cnJlbnQudHlwaW5nKSB7XG4gICAgICAgICAgZGF0YVJlZi5jdXJyZW50LnR5cGluZyA9IHZhbHVlO1xuICAgICAgICAgIG9uVHlwaW5nQ2hhbmdlKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGRhdGFSZWYuY3VycmVudC50eXBpbmcpIHtcbiAgICAgICAgICBkYXRhUmVmLmN1cnJlbnQudHlwaW5nID0gdmFsdWU7XG4gICAgICAgICAgb25UeXBpbmdDaGFuZ2UodmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldE1hdGNoaW5nSW5kZXgobGlzdCwgb3JkZXJlZExpc3QsIHN0cmluZykge1xuICAgICAgY29uc3Qgc3RyID0gZmluZE1hdGNoUmVmLmN1cnJlbnQgPyBmaW5kTWF0Y2hSZWYuY3VycmVudChvcmRlcmVkTGlzdCwgc3RyaW5nKSA6IG9yZGVyZWRMaXN0LmZpbmQodGV4dCA9PiAodGV4dCA9PSBudWxsID8gdm9pZCAwIDogdGV4dC50b0xvY2FsZUxvd2VyQ2FzZSgpLmluZGV4T2Yoc3RyaW5nLnRvTG9jYWxlTG93ZXJDYXNlKCkpKSA9PT0gMCk7XG4gICAgICByZXR1cm4gc3RyID8gbGlzdC5pbmRleE9mKHN0cikgOiAtMTtcbiAgICB9XG4gICAgZnVuY3Rpb24gb25LZXlEb3duKGV2ZW50KSB7XG4gICAgICBjb25zdCBsaXN0Q29udGVudCA9IGxpc3RSZWYuY3VycmVudDtcbiAgICAgIGlmIChzdHJpbmdSZWYuY3VycmVudC5sZW5ndGggPiAwICYmIHN0cmluZ1JlZi5jdXJyZW50WzBdICE9PSAnICcpIHtcbiAgICAgICAgaWYgKGdldE1hdGNoaW5nSW5kZXgobGlzdENvbnRlbnQsIGxpc3RDb250ZW50LCBzdHJpbmdSZWYuY3VycmVudCkgPT09IC0xKSB7XG4gICAgICAgICAgc2V0VHlwaW5nQ2hhbmdlKGZhbHNlKTtcbiAgICAgICAgfSBlbHNlIGlmIChldmVudC5rZXkgPT09ICcgJykge1xuICAgICAgICAgIHN0b3BFdmVudChldmVudCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChsaXN0Q29udGVudCA9PSBudWxsIHx8IGlnbm9yZUtleXNSZWYuY3VycmVudC5pbmNsdWRlcyhldmVudC5rZXkpIHx8XG4gICAgICAvLyBDaGFyYWN0ZXIga2V5LlxuICAgICAgZXZlbnQua2V5Lmxlbmd0aCAhPT0gMSB8fFxuICAgICAgLy8gTW9kaWZpZXIga2V5LlxuICAgICAgZXZlbnQuY3RybEtleSB8fCBldmVudC5tZXRhS2V5IHx8IGV2ZW50LmFsdEtleSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAob3BlbiAmJiBldmVudC5rZXkgIT09ICcgJykge1xuICAgICAgICBzdG9wRXZlbnQoZXZlbnQpO1xuICAgICAgICBzZXRUeXBpbmdDaGFuZ2UodHJ1ZSk7XG4gICAgICB9XG5cbiAgICAgIC8vIEJhaWwgb3V0IGlmIHRoZSBsaXN0IGNvbnRhaW5zIGEgd29yZCBsaWtlIFwibGxhbWFcIiBvciBcImFhcm9uXCIuIFRPRE86XG4gICAgICAvLyBhbGxvdyBpdCBpbiB0aGlzIGNhc2UsIHRvby5cbiAgICAgIGNvbnN0IGFsbG93UmFwaWRTdWNjZXNzaW9uT2ZGaXJzdExldHRlciA9IGxpc3RDb250ZW50LmV2ZXJ5KHRleHQgPT4ge1xuICAgICAgICB2YXIgX3RleHQkLCBfdGV4dCQyO1xuICAgICAgICByZXR1cm4gdGV4dCA/ICgoX3RleHQkID0gdGV4dFswXSkgPT0gbnVsbCA/IHZvaWQgMCA6IF90ZXh0JC50b0xvY2FsZUxvd2VyQ2FzZSgpKSAhPT0gKChfdGV4dCQyID0gdGV4dFsxXSkgPT0gbnVsbCA/IHZvaWQgMCA6IF90ZXh0JDIudG9Mb2NhbGVMb3dlckNhc2UoKSkgOiB0cnVlO1xuICAgICAgfSk7XG5cbiAgICAgIC8vIEFsbG93cyB0aGUgdXNlciB0byBjeWNsZSB0aHJvdWdoIGl0ZW1zIHRoYXQgc3RhcnQgd2l0aCB0aGUgc2FtZSBsZXR0ZXJcbiAgICAgIC8vIGluIHJhcGlkIHN1Y2Nlc3Npb24uXG4gICAgICBpZiAoYWxsb3dSYXBpZFN1Y2Nlc3Npb25PZkZpcnN0TGV0dGVyICYmIHN0cmluZ1JlZi5jdXJyZW50ID09PSBldmVudC5rZXkpIHtcbiAgICAgICAgc3RyaW5nUmVmLmN1cnJlbnQgPSAnJztcbiAgICAgICAgcHJldkluZGV4UmVmLmN1cnJlbnQgPSBtYXRjaEluZGV4UmVmLmN1cnJlbnQ7XG4gICAgICB9XG4gICAgICBzdHJpbmdSZWYuY3VycmVudCArPSBldmVudC5rZXk7XG4gICAgICBjbGVhclRpbWVvdXQodGltZW91dElkUmVmLmN1cnJlbnQpO1xuICAgICAgdGltZW91dElkUmVmLmN1cnJlbnQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgc3RyaW5nUmVmLmN1cnJlbnQgPSAnJztcbiAgICAgICAgcHJldkluZGV4UmVmLmN1cnJlbnQgPSBtYXRjaEluZGV4UmVmLmN1cnJlbnQ7XG4gICAgICAgIHNldFR5cGluZ0NoYW5nZShmYWxzZSk7XG4gICAgICB9LCByZXNldE1zKTtcbiAgICAgIGNvbnN0IHByZXZJbmRleCA9IHByZXZJbmRleFJlZi5jdXJyZW50O1xuICAgICAgY29uc3QgaW5kZXggPSBnZXRNYXRjaGluZ0luZGV4KGxpc3RDb250ZW50LCBbLi4ubGlzdENvbnRlbnQuc2xpY2UoKHByZXZJbmRleCB8fCAwKSArIDEpLCAuLi5saXN0Q29udGVudC5zbGljZSgwLCAocHJldkluZGV4IHx8IDApICsgMSldLCBzdHJpbmdSZWYuY3VycmVudCk7XG4gICAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICAgIG9uTWF0Y2goaW5kZXgpO1xuICAgICAgICBtYXRjaEluZGV4UmVmLmN1cnJlbnQgPSBpbmRleDtcbiAgICAgIH0gZWxzZSBpZiAoZXZlbnQua2V5ICE9PSAnICcpIHtcbiAgICAgICAgc3RyaW5nUmVmLmN1cnJlbnQgPSAnJztcbiAgICAgICAgc2V0VHlwaW5nQ2hhbmdlKGZhbHNlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHJlZmVyZW5jZToge1xuICAgICAgICBvbktleURvd25cbiAgICAgIH0sXG4gICAgICBmbG9hdGluZzoge1xuICAgICAgICBvbktleURvd24sXG4gICAgICAgIG9uS2V5VXAoZXZlbnQpIHtcbiAgICAgICAgICBpZiAoZXZlbnQua2V5ID09PSAnICcpIHtcbiAgICAgICAgICAgIHNldFR5cGluZ0NoYW5nZShmYWxzZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgfSwgW2VuYWJsZWQsIG9wZW4sIGRhdGFSZWYsIGxpc3RSZWYsIHJlc2V0TXMsIGlnbm9yZUtleXNSZWYsIGZpbmRNYXRjaFJlZiwgb25NYXRjaCwgb25UeXBpbmdDaGFuZ2VdKTtcbn1cblxuZnVuY3Rpb24gZ2V0QXJnc1dpdGhDdXN0b21GbG9hdGluZ0hlaWdodChzdGF0ZSwgaGVpZ2h0KSB7XG4gIHJldHVybiB7XG4gICAgLi4uc3RhdGUsXG4gICAgcmVjdHM6IHtcbiAgICAgIC4uLnN0YXRlLnJlY3RzLFxuICAgICAgZmxvYXRpbmc6IHtcbiAgICAgICAgLi4uc3RhdGUucmVjdHMuZmxvYXRpbmcsXG4gICAgICAgIGhlaWdodFxuICAgICAgfVxuICAgIH1cbiAgfTtcbn1cbi8qKlxuICogUG9zaXRpb25zIHRoZSBmbG9hdGluZyBlbGVtZW50IHN1Y2ggdGhhdCBhbiBpbm5lciBlbGVtZW50IGluc2lkZVxuICogb2YgaXQgaXMgYW5jaG9yZWQgdG8gdGhlIHJlZmVyZW5jZSBlbGVtZW50LlxuICogQHNlZSBodHRwczovL2Zsb2F0aW5nLXVpLmNvbS9kb2NzL2lubmVyXG4gKi9cbmNvbnN0IGlubmVyID0gcHJvcHMgPT4gKHtcbiAgbmFtZTogJ2lubmVyJyxcbiAgb3B0aW9uczogcHJvcHMsXG4gIGFzeW5jIGZuKHN0YXRlKSB7XG4gICAgY29uc3Qge1xuICAgICAgbGlzdFJlZixcbiAgICAgIG92ZXJmbG93UmVmLFxuICAgICAgb25GYWxsYmFja0NoYW5nZSxcbiAgICAgIG9mZnNldDogaW5uZXJPZmZzZXQgPSAwLFxuICAgICAgaW5kZXggPSAwLFxuICAgICAgbWluSXRlbXNWaXNpYmxlID0gNCxcbiAgICAgIHJlZmVyZW5jZU92ZXJmbG93VGhyZXNob2xkID0gMCxcbiAgICAgIHNjcm9sbFJlZixcbiAgICAgIC4uLmRldGVjdE92ZXJmbG93T3B0aW9uc1xuICAgIH0gPSBwcm9wcztcbiAgICBjb25zdCB7XG4gICAgICByZWN0cyxcbiAgICAgIGVsZW1lbnRzOiB7XG4gICAgICAgIGZsb2F0aW5nXG4gICAgICB9XG4gICAgfSA9IHN0YXRlO1xuICAgIGNvbnN0IGl0ZW0gPSBsaXN0UmVmLmN1cnJlbnRbaW5kZXhdO1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgIGlmICghc3RhdGUucGxhY2VtZW50LnN0YXJ0c1dpdGgoJ2JvdHRvbScpKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihbJ0Zsb2F0aW5nIFVJOiBgcGxhY2VtZW50YCBzaWRlIG11c3QgYmUgXCJib3R0b21cIiB3aGVuIHVzaW5nIHRoZScsICdgaW5uZXJgIG1pZGRsZXdhcmUuJ10uam9pbignICcpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFpdGVtKSB7XG4gICAgICByZXR1cm4ge307XG4gICAgfVxuICAgIGNvbnN0IG5leHRBcmdzID0ge1xuICAgICAgLi4uc3RhdGUsXG4gICAgICAuLi4oYXdhaXQgb2Zmc2V0KC1pdGVtLm9mZnNldFRvcCAtIGZsb2F0aW5nLmNsaWVudFRvcCAtIHJlY3RzLnJlZmVyZW5jZS5oZWlnaHQgLyAyIC0gaXRlbS5vZmZzZXRIZWlnaHQgLyAyIC0gaW5uZXJPZmZzZXQpLmZuKHN0YXRlKSlcbiAgICB9O1xuICAgIGNvbnN0IGVsID0gKHNjcm9sbFJlZiA9PSBudWxsID8gdm9pZCAwIDogc2Nyb2xsUmVmLmN1cnJlbnQpIHx8IGZsb2F0aW5nO1xuICAgIGNvbnN0IG92ZXJmbG93ID0gYXdhaXQgZGV0ZWN0T3ZlcmZsb3coZ2V0QXJnc1dpdGhDdXN0b21GbG9hdGluZ0hlaWdodChuZXh0QXJncywgZWwuc2Nyb2xsSGVpZ2h0KSwgZGV0ZWN0T3ZlcmZsb3dPcHRpb25zKTtcbiAgICBjb25zdCByZWZPdmVyZmxvdyA9IGF3YWl0IGRldGVjdE92ZXJmbG93KG5leHRBcmdzLCB7XG4gICAgICAuLi5kZXRlY3RPdmVyZmxvd09wdGlvbnMsXG4gICAgICBlbGVtZW50Q29udGV4dDogJ3JlZmVyZW5jZSdcbiAgICB9KTtcbiAgICBjb25zdCBkaWZmWSA9IE1hdGgubWF4KDAsIG92ZXJmbG93LnRvcCk7XG4gICAgY29uc3QgbmV4dFkgPSBuZXh0QXJncy55ICsgZGlmZlk7XG4gICAgY29uc3QgbWF4SGVpZ2h0ID0gTWF0aC5tYXgoMCwgZWwuc2Nyb2xsSGVpZ2h0IC0gZGlmZlkgLSBNYXRoLm1heCgwLCBvdmVyZmxvdy5ib3R0b20pKTtcbiAgICBlbC5zdHlsZS5tYXhIZWlnaHQgPSBtYXhIZWlnaHQgKyBcInB4XCI7XG4gICAgZWwuc2Nyb2xsVG9wID0gZGlmZlk7XG5cbiAgICAvLyBUaGVyZSBpcyBub3QgZW5vdWdoIHNwYWNlLCBmYWxsYmFjayB0byBzdGFuZGFyZCBhbmNob3JlZCBwb3NpdGlvbmluZ1xuICAgIGlmIChvbkZhbGxiYWNrQ2hhbmdlKSB7XG4gICAgICBpZiAoZWwub2Zmc2V0SGVpZ2h0IDwgaXRlbS5vZmZzZXRIZWlnaHQgKiBNYXRoLm1pbihtaW5JdGVtc1Zpc2libGUsIGxpc3RSZWYuY3VycmVudC5sZW5ndGggLSAxKSAtIDEgfHwgcmVmT3ZlcmZsb3cudG9wID49IC1yZWZlcmVuY2VPdmVyZmxvd1RocmVzaG9sZCB8fCByZWZPdmVyZmxvdy5ib3R0b20gPj0gLXJlZmVyZW5jZU92ZXJmbG93VGhyZXNob2xkKSB7XG4gICAgICAgIGZsdXNoU3luYygoKSA9PiBvbkZhbGxiYWNrQ2hhbmdlKHRydWUpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZsdXNoU3luYygoKSA9PiBvbkZhbGxiYWNrQ2hhbmdlKGZhbHNlKSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChvdmVyZmxvd1JlZikge1xuICAgICAgb3ZlcmZsb3dSZWYuY3VycmVudCA9IGF3YWl0IGRldGVjdE92ZXJmbG93KGdldEFyZ3NXaXRoQ3VzdG9tRmxvYXRpbmdIZWlnaHQoe1xuICAgICAgICAuLi5uZXh0QXJncyxcbiAgICAgICAgeTogbmV4dFlcbiAgICAgIH0sIGVsLm9mZnNldEhlaWdodCksIGRldGVjdE92ZXJmbG93T3B0aW9ucyk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICB5OiBuZXh0WVxuICAgIH07XG4gIH1cbn0pO1xuLyoqXG4gKiBDaGFuZ2VzIHRoZSBgaW5uZXJgIG1pZGRsZXdhcmUncyBgb2Zmc2V0YCB1cG9uIGEgYHdoZWVsYCBldmVudCB0b1xuICogZXhwYW5kIHRoZSBmbG9hdGluZyBlbGVtZW50J3MgaGVpZ2h0LCByZXZlYWxpbmcgbW9yZSBsaXN0IGl0ZW1zLlxuICogQHNlZSBodHRwczovL2Zsb2F0aW5nLXVpLmNvbS9kb2NzL2lubmVyXG4gKi9cbmZ1bmN0aW9uIHVzZUlubmVyT2Zmc2V0KGNvbnRleHQsIHByb3BzKSB7XG4gIGNvbnN0IHtcbiAgICBvcGVuLFxuICAgIGVsZW1lbnRzXG4gIH0gPSBjb250ZXh0O1xuICBjb25zdCB7XG4gICAgZW5hYmxlZCA9IHRydWUsXG4gICAgb3ZlcmZsb3dSZWYsXG4gICAgc2Nyb2xsUmVmLFxuICAgIG9uQ2hhbmdlOiB1bnN0YWJsZV9vbkNoYW5nZVxuICB9ID0gcHJvcHM7XG4gIGNvbnN0IG9uQ2hhbmdlID0gdXNlRWZmZWN0RXZlbnQodW5zdGFibGVfb25DaGFuZ2UpO1xuICBjb25zdCBjb250cm9sbGVkU2Nyb2xsaW5nUmVmID0gUmVhY3QudXNlUmVmKGZhbHNlKTtcbiAgY29uc3QgcHJldlNjcm9sbFRvcFJlZiA9IFJlYWN0LnVzZVJlZihudWxsKTtcbiAgY29uc3QgaW5pdGlhbE92ZXJmbG93UmVmID0gUmVhY3QudXNlUmVmKG51bGwpO1xuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmICghZW5hYmxlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBmdW5jdGlvbiBvbldoZWVsKGUpIHtcbiAgICAgIGlmIChlLmN0cmxLZXkgfHwgIWVsIHx8IG92ZXJmbG93UmVmLmN1cnJlbnQgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBkWSA9IGUuZGVsdGFZO1xuICAgICAgY29uc3QgaXNBdFRvcCA9IG92ZXJmbG93UmVmLmN1cnJlbnQudG9wID49IC0wLjU7XG4gICAgICBjb25zdCBpc0F0Qm90dG9tID0gb3ZlcmZsb3dSZWYuY3VycmVudC5ib3R0b20gPj0gLTAuNTtcbiAgICAgIGNvbnN0IHJlbWFpbmluZ1Njcm9sbCA9IGVsLnNjcm9sbEhlaWdodCAtIGVsLmNsaWVudEhlaWdodDtcbiAgICAgIGNvbnN0IHNpZ24gPSBkWSA8IDAgPyAtMSA6IDE7XG4gICAgICBjb25zdCBtZXRob2QgPSBkWSA8IDAgPyAnbWF4JyA6ICdtaW4nO1xuICAgICAgaWYgKGVsLnNjcm9sbEhlaWdodCA8PSBlbC5jbGllbnRIZWlnaHQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKCFpc0F0VG9wICYmIGRZID4gMCB8fCAhaXNBdEJvdHRvbSAmJiBkWSA8IDApIHtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBmbHVzaFN5bmMoKCkgPT4ge1xuICAgICAgICAgIG9uQ2hhbmdlKGQgPT4gZCArIE1hdGhbbWV0aG9kXShkWSwgcmVtYWluaW5nU2Nyb2xsICogc2lnbikpO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSBpZiAoL2ZpcmVmb3gvaS50ZXN0KGdldFVzZXJBZ2VudCgpKSkge1xuICAgICAgICAvLyBOZWVkZWQgdG8gcHJvcGFnYXRlIHNjcm9sbGluZyBkdXJpbmcgbW9tZW50dW0gc2Nyb2xsaW5nIHBoYXNlIG9uY2VcbiAgICAgICAgLy8gaXQgZ2V0cyBsaW1pdGVkIGJ5IHRoZSBib3VuZGFyeS4gVVggaW1wcm92ZW1lbnQsIG5vdCBjcml0aWNhbC5cbiAgICAgICAgZWwuc2Nyb2xsVG9wICs9IGRZO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBlbCA9IChzY3JvbGxSZWYgPT0gbnVsbCA/IHZvaWQgMCA6IHNjcm9sbFJlZi5jdXJyZW50KSB8fCBlbGVtZW50cy5mbG9hdGluZztcbiAgICBpZiAob3BlbiAmJiBlbCkge1xuICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcignd2hlZWwnLCBvbldoZWVsKTtcblxuICAgICAgLy8gV2FpdCBmb3IgdGhlIHBvc2l0aW9uIHRvIGJlIHJlYWR5LlxuICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgICAgcHJldlNjcm9sbFRvcFJlZi5jdXJyZW50ID0gZWwuc2Nyb2xsVG9wO1xuICAgICAgICBpZiAob3ZlcmZsb3dSZWYuY3VycmVudCAhPSBudWxsKSB7XG4gICAgICAgICAgaW5pdGlhbE92ZXJmbG93UmVmLmN1cnJlbnQgPSB7XG4gICAgICAgICAgICAuLi5vdmVyZmxvd1JlZi5jdXJyZW50XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICBwcmV2U2Nyb2xsVG9wUmVmLmN1cnJlbnQgPSBudWxsO1xuICAgICAgICBpbml0aWFsT3ZlcmZsb3dSZWYuY3VycmVudCA9IG51bGw7XG4gICAgICAgIGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3doZWVsJywgb25XaGVlbCk7XG4gICAgICB9O1xuICAgIH1cbiAgfSwgW2VuYWJsZWQsIG9wZW4sIGVsZW1lbnRzLmZsb2F0aW5nLCBvdmVyZmxvd1JlZiwgc2Nyb2xsUmVmLCBvbkNoYW5nZV0pO1xuICByZXR1cm4gUmVhY3QudXNlTWVtbygoKSA9PiB7XG4gICAgaWYgKCFlbmFibGVkKSB7XG4gICAgICByZXR1cm4ge307XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBmbG9hdGluZzoge1xuICAgICAgICBvbktleURvd24oKSB7XG4gICAgICAgICAgY29udHJvbGxlZFNjcm9sbGluZ1JlZi5jdXJyZW50ID0gdHJ1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgb25XaGVlbCgpIHtcbiAgICAgICAgICBjb250cm9sbGVkU2Nyb2xsaW5nUmVmLmN1cnJlbnQgPSBmYWxzZTtcbiAgICAgICAgfSxcbiAgICAgICAgb25Qb2ludGVyTW92ZSgpIHtcbiAgICAgICAgICBjb250cm9sbGVkU2Nyb2xsaW5nUmVmLmN1cnJlbnQgPSBmYWxzZTtcbiAgICAgICAgfSxcbiAgICAgICAgb25TY3JvbGwoKSB7XG4gICAgICAgICAgY29uc3QgZWwgPSAoc2Nyb2xsUmVmID09IG51bGwgPyB2b2lkIDAgOiBzY3JvbGxSZWYuY3VycmVudCkgfHwgZWxlbWVudHMuZmxvYXRpbmc7XG4gICAgICAgICAgaWYgKCFvdmVyZmxvd1JlZi5jdXJyZW50IHx8ICFlbCB8fCAhY29udHJvbGxlZFNjcm9sbGluZ1JlZi5jdXJyZW50KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChwcmV2U2Nyb2xsVG9wUmVmLmN1cnJlbnQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnN0IHNjcm9sbERpZmYgPSBlbC5zY3JvbGxUb3AgLSBwcmV2U2Nyb2xsVG9wUmVmLmN1cnJlbnQ7XG4gICAgICAgICAgICBpZiAob3ZlcmZsb3dSZWYuY3VycmVudC5ib3R0b20gPCAtMC41ICYmIHNjcm9sbERpZmYgPCAtMSB8fCBvdmVyZmxvd1JlZi5jdXJyZW50LnRvcCA8IC0wLjUgJiYgc2Nyb2xsRGlmZiA+IDEpIHtcbiAgICAgICAgICAgICAgZmx1c2hTeW5jKCgpID0+IG9uQ2hhbmdlKGQgPT4gZCArIHNjcm9sbERpZmYpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBbRmlyZWZveF0gV2FpdCBmb3IgdGhlIGhlaWdodCBjaGFuZ2UgdG8gaGF2ZSBiZWVuIGFwcGxpZWQuXG4gICAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgICAgICAgIHByZXZTY3JvbGxUb3BSZWYuY3VycmVudCA9IGVsLnNjcm9sbFRvcDtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gIH0sIFtlbmFibGVkLCBvdmVyZmxvd1JlZiwgZWxlbWVudHMuZmxvYXRpbmcsIHNjcm9sbFJlZiwgb25DaGFuZ2VdKTtcbn1cblxuZnVuY3Rpb24gaXNQb2ludEluUG9seWdvbihwb2ludCwgcG9seWdvbikge1xuICBjb25zdCBbeCwgeV0gPSBwb2ludDtcbiAgbGV0IGlzSW5zaWRlID0gZmFsc2U7XG4gIGNvbnN0IGxlbmd0aCA9IHBvbHlnb24ubGVuZ3RoO1xuICBmb3IgKGxldCBpID0gMCwgaiA9IGxlbmd0aCAtIDE7IGkgPCBsZW5ndGg7IGogPSBpKyspIHtcbiAgICBjb25zdCBbeGksIHlpXSA9IHBvbHlnb25baV0gfHwgWzAsIDBdO1xuICAgIGNvbnN0IFt4aiwgeWpdID0gcG9seWdvbltqXSB8fCBbMCwgMF07XG4gICAgY29uc3QgaW50ZXJzZWN0ID0geWkgPj0geSAhPT0geWogPj0geSAmJiB4IDw9ICh4aiAtIHhpKSAqICh5IC0geWkpIC8gKHlqIC0geWkpICsgeGk7XG4gICAgaWYgKGludGVyc2VjdCkge1xuICAgICAgaXNJbnNpZGUgPSAhaXNJbnNpZGU7XG4gICAgfVxuICB9XG4gIHJldHVybiBpc0luc2lkZTtcbn1cbmZ1bmN0aW9uIGlzSW5zaWRlKHBvaW50LCByZWN0KSB7XG4gIHJldHVybiBwb2ludFswXSA+PSByZWN0LnggJiYgcG9pbnRbMF0gPD0gcmVjdC54ICsgcmVjdC53aWR0aCAmJiBwb2ludFsxXSA+PSByZWN0LnkgJiYgcG9pbnRbMV0gPD0gcmVjdC55ICsgcmVjdC5oZWlnaHQ7XG59XG4vKipcbiAqIEdlbmVyYXRlcyBhIHNhZmUgcG9seWdvbiBhcmVhIHRoYXQgdGhlIHVzZXIgY2FuIHRyYXZlcnNlIHdpdGhvdXQgY2xvc2luZyB0aGVcbiAqIGZsb2F0aW5nIGVsZW1lbnQgb25jZSBsZWF2aW5nIHRoZSByZWZlcmVuY2UgZWxlbWVudC5cbiAqIEBzZWUgaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy91c2VIb3ZlciNzYWZlcG9seWdvblxuICovXG5mdW5jdGlvbiBzYWZlUG9seWdvbihvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICBvcHRpb25zID0ge307XG4gIH1cbiAgY29uc3Qge1xuICAgIGJ1ZmZlciA9IDAuNSxcbiAgICBibG9ja1BvaW50ZXJFdmVudHMgPSBmYWxzZSxcbiAgICByZXF1aXJlSW50ZW50ID0gdHJ1ZVxuICB9ID0gb3B0aW9ucztcbiAgbGV0IHRpbWVvdXRJZDtcbiAgbGV0IGhhc0xhbmRlZCA9IGZhbHNlO1xuICBsZXQgbGFzdFggPSBudWxsO1xuICBsZXQgbGFzdFkgPSBudWxsO1xuICBsZXQgbGFzdEN1cnNvclRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgZnVuY3Rpb24gZ2V0Q3Vyc29yU3BlZWQoeCwgeSkge1xuICAgIGNvbnN0IGN1cnJlbnRUaW1lID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgY29uc3QgZWxhcHNlZFRpbWUgPSBjdXJyZW50VGltZSAtIGxhc3RDdXJzb3JUaW1lO1xuICAgIGlmIChsYXN0WCA9PT0gbnVsbCB8fCBsYXN0WSA9PT0gbnVsbCB8fCBlbGFwc2VkVGltZSA9PT0gMCkge1xuICAgICAgbGFzdFggPSB4O1xuICAgICAgbGFzdFkgPSB5O1xuICAgICAgbGFzdEN1cnNvclRpbWUgPSBjdXJyZW50VGltZTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCBkZWx0YVggPSB4IC0gbGFzdFg7XG4gICAgY29uc3QgZGVsdGFZID0geSAtIGxhc3RZO1xuICAgIGNvbnN0IGRpc3RhbmNlID0gTWF0aC5zcXJ0KGRlbHRhWCAqIGRlbHRhWCArIGRlbHRhWSAqIGRlbHRhWSk7XG4gICAgY29uc3Qgc3BlZWQgPSBkaXN0YW5jZSAvIGVsYXBzZWRUaW1lOyAvLyBweCAvIG1zXG5cbiAgICBsYXN0WCA9IHg7XG4gICAgbGFzdFkgPSB5O1xuICAgIGxhc3RDdXJzb3JUaW1lID0gY3VycmVudFRpbWU7XG4gICAgcmV0dXJuIHNwZWVkO1xuICB9XG4gIGNvbnN0IGZuID0gX3JlZiA9PiB7XG4gICAgbGV0IHtcbiAgICAgIHgsXG4gICAgICB5LFxuICAgICAgcGxhY2VtZW50LFxuICAgICAgZWxlbWVudHMsXG4gICAgICBvbkNsb3NlLFxuICAgICAgbm9kZUlkLFxuICAgICAgdHJlZVxuICAgIH0gPSBfcmVmO1xuICAgIHJldHVybiBmdW5jdGlvbiBvbk1vdXNlTW92ZShldmVudCkge1xuICAgICAgZnVuY3Rpb24gY2xvc2UoKSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0SWQpO1xuICAgICAgICBvbkNsb3NlKCk7XG4gICAgICB9XG4gICAgICBjbGVhclRpbWVvdXQodGltZW91dElkKTtcbiAgICAgIGlmICghZWxlbWVudHMuZG9tUmVmZXJlbmNlIHx8ICFlbGVtZW50cy5mbG9hdGluZyB8fCBwbGFjZW1lbnQgPT0gbnVsbCB8fCB4ID09IG51bGwgfHwgeSA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHtcbiAgICAgICAgY2xpZW50WCxcbiAgICAgICAgY2xpZW50WVxuICAgICAgfSA9IGV2ZW50O1xuICAgICAgY29uc3QgY2xpZW50UG9pbnQgPSBbY2xpZW50WCwgY2xpZW50WV07XG4gICAgICBjb25zdCB0YXJnZXQgPSBnZXRUYXJnZXQoZXZlbnQpO1xuICAgICAgY29uc3QgaXNMZWF2ZSA9IGV2ZW50LnR5cGUgPT09ICdtb3VzZWxlYXZlJztcbiAgICAgIGNvbnN0IGlzT3ZlckZsb2F0aW5nRWwgPSBjb250YWlucyhlbGVtZW50cy5mbG9hdGluZywgdGFyZ2V0KTtcbiAgICAgIGNvbnN0IGlzT3ZlclJlZmVyZW5jZUVsID0gY29udGFpbnMoZWxlbWVudHMuZG9tUmVmZXJlbmNlLCB0YXJnZXQpO1xuICAgICAgY29uc3QgcmVmUmVjdCA9IGVsZW1lbnRzLmRvbVJlZmVyZW5jZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIGNvbnN0IHJlY3QgPSBlbGVtZW50cy5mbG9hdGluZy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIGNvbnN0IHNpZGUgPSBwbGFjZW1lbnQuc3BsaXQoJy0nKVswXTtcbiAgICAgIGNvbnN0IGN1cnNvckxlYXZlRnJvbVJpZ2h0ID0geCA+IHJlY3QucmlnaHQgLSByZWN0LndpZHRoIC8gMjtcbiAgICAgIGNvbnN0IGN1cnNvckxlYXZlRnJvbUJvdHRvbSA9IHkgPiByZWN0LmJvdHRvbSAtIHJlY3QuaGVpZ2h0IC8gMjtcbiAgICAgIGNvbnN0IGlzT3ZlclJlZmVyZW5jZVJlY3QgPSBpc0luc2lkZShjbGllbnRQb2ludCwgcmVmUmVjdCk7XG4gICAgICBjb25zdCBpc0Zsb2F0aW5nV2lkZXIgPSByZWN0LndpZHRoID4gcmVmUmVjdC53aWR0aDtcbiAgICAgIGNvbnN0IGlzRmxvYXRpbmdUYWxsZXIgPSByZWN0LmhlaWdodCA+IHJlZlJlY3QuaGVpZ2h0O1xuICAgICAgY29uc3QgbGVmdCA9IChpc0Zsb2F0aW5nV2lkZXIgPyByZWZSZWN0IDogcmVjdCkubGVmdDtcbiAgICAgIGNvbnN0IHJpZ2h0ID0gKGlzRmxvYXRpbmdXaWRlciA/IHJlZlJlY3QgOiByZWN0KS5yaWdodDtcbiAgICAgIGNvbnN0IHRvcCA9IChpc0Zsb2F0aW5nVGFsbGVyID8gcmVmUmVjdCA6IHJlY3QpLnRvcDtcbiAgICAgIGNvbnN0IGJvdHRvbSA9IChpc0Zsb2F0aW5nVGFsbGVyID8gcmVmUmVjdCA6IHJlY3QpLmJvdHRvbTtcbiAgICAgIGlmIChpc092ZXJGbG9hdGluZ0VsKSB7XG4gICAgICAgIGhhc0xhbmRlZCA9IHRydWU7XG4gICAgICAgIGlmICghaXNMZWF2ZSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGlzT3ZlclJlZmVyZW5jZUVsKSB7XG4gICAgICAgIGhhc0xhbmRlZCA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgaWYgKGlzT3ZlclJlZmVyZW5jZUVsICYmICFpc0xlYXZlKSB7XG4gICAgICAgIGhhc0xhbmRlZCA9IHRydWU7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gUHJldmVudCBvdmVybGFwcGluZyBmbG9hdGluZyBlbGVtZW50IGZyb20gYmVpbmcgc3R1Y2sgaW4gYW4gb3Blbi1jbG9zZVxuICAgICAgLy8gbG9vcDogaHR0cHM6Ly9naXRodWIuY29tL2Zsb2F0aW5nLXVpL2Zsb2F0aW5nLXVpL2lzc3Vlcy8xOTEwXG4gICAgICBpZiAoaXNMZWF2ZSAmJiBpc0VsZW1lbnQoZXZlbnQucmVsYXRlZFRhcmdldCkgJiYgY29udGFpbnMoZWxlbWVudHMuZmxvYXRpbmcsIGV2ZW50LnJlbGF0ZWRUYXJnZXQpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gSWYgYW55IG5lc3RlZCBjaGlsZCBpcyBvcGVuLCBhYm9ydC5cbiAgICAgIGlmICh0cmVlICYmIGdldENoaWxkcmVuKHRyZWUubm9kZXNSZWYuY3VycmVudCwgbm9kZUlkKS5zb21lKF9yZWYyID0+IHtcbiAgICAgICAgbGV0IHtcbiAgICAgICAgICBjb250ZXh0XG4gICAgICAgIH0gPSBfcmVmMjtcbiAgICAgICAgcmV0dXJuIGNvbnRleHQgPT0gbnVsbCA/IHZvaWQgMCA6IGNvbnRleHQub3BlbjtcbiAgICAgIH0pKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gSWYgdGhlIHBvaW50ZXIgaXMgbGVhdmluZyBmcm9tIHRoZSBvcHBvc2l0ZSBzaWRlLCB0aGUgXCJidWZmZXJcIiBsb2dpY1xuICAgICAgLy8gY3JlYXRlcyBhIHBvaW50IHdoZXJlIHRoZSBmbG9hdGluZyBlbGVtZW50IHJlbWFpbnMgb3BlbiwgYnV0IHNob3VsZCBiZVxuICAgICAgLy8gaWdub3JlZC5cbiAgICAgIC8vIEEgY29uc3RhbnQgb2YgMSBoYW5kbGVzIGZsb2F0aW5nIHBvaW50IHJvdW5kaW5nIGVycm9ycy5cbiAgICAgIGlmIChzaWRlID09PSAndG9wJyAmJiB5ID49IHJlZlJlY3QuYm90dG9tIC0gMSB8fCBzaWRlID09PSAnYm90dG9tJyAmJiB5IDw9IHJlZlJlY3QudG9wICsgMSB8fCBzaWRlID09PSAnbGVmdCcgJiYgeCA+PSByZWZSZWN0LnJpZ2h0IC0gMSB8fCBzaWRlID09PSAncmlnaHQnICYmIHggPD0gcmVmUmVjdC5sZWZ0ICsgMSkge1xuICAgICAgICByZXR1cm4gY2xvc2UoKTtcbiAgICAgIH1cblxuICAgICAgLy8gSWdub3JlIHdoZW4gdGhlIGN1cnNvciBpcyB3aXRoaW4gdGhlIHJlY3Rhbmd1bGFyIHRyb3VnaCBiZXR3ZWVuIHRoZVxuICAgICAgLy8gdHdvIGVsZW1lbnRzLiBTaW5jZSB0aGUgdHJpYW5nbGUgaXMgY3JlYXRlZCBmcm9tIHRoZSBjdXJzb3IgcG9pbnQsXG4gICAgICAvLyB3aGljaCBjYW4gc3RhcnQgYmV5b25kIHRoZSByZWYgZWxlbWVudCdzIGVkZ2UsIHRyYXZlcnNpbmcgYmFjayBhbmRcbiAgICAgIC8vIGZvcnRoIGZyb20gdGhlIHJlZiB0byB0aGUgZmxvYXRpbmcgZWxlbWVudCBjYW4gY2F1c2UgaXQgdG8gY2xvc2UuIFRoaXNcbiAgICAgIC8vIGVuc3VyZXMgaXQgYWx3YXlzIHJlbWFpbnMgb3BlbiBpbiB0aGF0IGNhc2UuXG4gICAgICBsZXQgcmVjdFBvbHkgPSBbXTtcbiAgICAgIHN3aXRjaCAoc2lkZSkge1xuICAgICAgICBjYXNlICd0b3AnOlxuICAgICAgICAgIHJlY3RQb2x5ID0gW1tsZWZ0LCByZWZSZWN0LnRvcCArIDFdLCBbbGVmdCwgcmVjdC5ib3R0b20gLSAxXSwgW3JpZ2h0LCByZWN0LmJvdHRvbSAtIDFdLCBbcmlnaHQsIHJlZlJlY3QudG9wICsgMV1dO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdib3R0b20nOlxuICAgICAgICAgIHJlY3RQb2x5ID0gW1tsZWZ0LCByZWN0LnRvcCArIDFdLCBbbGVmdCwgcmVmUmVjdC5ib3R0b20gLSAxXSwgW3JpZ2h0LCByZWZSZWN0LmJvdHRvbSAtIDFdLCBbcmlnaHQsIHJlY3QudG9wICsgMV1dO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdsZWZ0JzpcbiAgICAgICAgICByZWN0UG9seSA9IFtbcmVjdC5yaWdodCAtIDEsIGJvdHRvbV0sIFtyZWN0LnJpZ2h0IC0gMSwgdG9wXSwgW3JlZlJlY3QubGVmdCArIDEsIHRvcF0sIFtyZWZSZWN0LmxlZnQgKyAxLCBib3R0b21dXTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAncmlnaHQnOlxuICAgICAgICAgIHJlY3RQb2x5ID0gW1tyZWZSZWN0LnJpZ2h0IC0gMSwgYm90dG9tXSwgW3JlZlJlY3QucmlnaHQgLSAxLCB0b3BdLCBbcmVjdC5sZWZ0ICsgMSwgdG9wXSwgW3JlY3QubGVmdCArIDEsIGJvdHRvbV1dO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gZ2V0UG9seWdvbihfcmVmMykge1xuICAgICAgICBsZXQgW3gsIHldID0gX3JlZjM7XG4gICAgICAgIHN3aXRjaCAoc2lkZSkge1xuICAgICAgICAgIGNhc2UgJ3RvcCc6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGNvbnN0IGN1cnNvclBvaW50T25lID0gW2lzRmxvYXRpbmdXaWRlciA/IHggKyBidWZmZXIgLyAyIDogY3Vyc29yTGVhdmVGcm9tUmlnaHQgPyB4ICsgYnVmZmVyICogNCA6IHggLSBidWZmZXIgKiA0LCB5ICsgYnVmZmVyICsgMV07XG4gICAgICAgICAgICAgIGNvbnN0IGN1cnNvclBvaW50VHdvID0gW2lzRmxvYXRpbmdXaWRlciA/IHggLSBidWZmZXIgLyAyIDogY3Vyc29yTGVhdmVGcm9tUmlnaHQgPyB4ICsgYnVmZmVyICogNCA6IHggLSBidWZmZXIgKiA0LCB5ICsgYnVmZmVyICsgMV07XG4gICAgICAgICAgICAgIGNvbnN0IGNvbW1vblBvaW50cyA9IFtbcmVjdC5sZWZ0LCBjdXJzb3JMZWF2ZUZyb21SaWdodCA/IHJlY3QuYm90dG9tIC0gYnVmZmVyIDogaXNGbG9hdGluZ1dpZGVyID8gcmVjdC5ib3R0b20gLSBidWZmZXIgOiByZWN0LnRvcF0sIFtyZWN0LnJpZ2h0LCBjdXJzb3JMZWF2ZUZyb21SaWdodCA/IGlzRmxvYXRpbmdXaWRlciA/IHJlY3QuYm90dG9tIC0gYnVmZmVyIDogcmVjdC50b3AgOiByZWN0LmJvdHRvbSAtIGJ1ZmZlcl1dO1xuICAgICAgICAgICAgICByZXR1cm4gW2N1cnNvclBvaW50T25lLCBjdXJzb3JQb2ludFR3bywgLi4uY29tbW9uUG9pbnRzXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlICdib3R0b20nOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBjb25zdCBjdXJzb3JQb2ludE9uZSA9IFtpc0Zsb2F0aW5nV2lkZXIgPyB4ICsgYnVmZmVyIC8gMiA6IGN1cnNvckxlYXZlRnJvbVJpZ2h0ID8geCArIGJ1ZmZlciAqIDQgOiB4IC0gYnVmZmVyICogNCwgeSAtIGJ1ZmZlcl07XG4gICAgICAgICAgICAgIGNvbnN0IGN1cnNvclBvaW50VHdvID0gW2lzRmxvYXRpbmdXaWRlciA/IHggLSBidWZmZXIgLyAyIDogY3Vyc29yTGVhdmVGcm9tUmlnaHQgPyB4ICsgYnVmZmVyICogNCA6IHggLSBidWZmZXIgKiA0LCB5IC0gYnVmZmVyXTtcbiAgICAgICAgICAgICAgY29uc3QgY29tbW9uUG9pbnRzID0gW1tyZWN0LmxlZnQsIGN1cnNvckxlYXZlRnJvbVJpZ2h0ID8gcmVjdC50b3AgKyBidWZmZXIgOiBpc0Zsb2F0aW5nV2lkZXIgPyByZWN0LnRvcCArIGJ1ZmZlciA6IHJlY3QuYm90dG9tXSwgW3JlY3QucmlnaHQsIGN1cnNvckxlYXZlRnJvbVJpZ2h0ID8gaXNGbG9hdGluZ1dpZGVyID8gcmVjdC50b3AgKyBidWZmZXIgOiByZWN0LmJvdHRvbSA6IHJlY3QudG9wICsgYnVmZmVyXV07XG4gICAgICAgICAgICAgIHJldHVybiBbY3Vyc29yUG9pbnRPbmUsIGN1cnNvclBvaW50VHdvLCAuLi5jb21tb25Qb2ludHNdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgJ2xlZnQnOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBjb25zdCBjdXJzb3JQb2ludE9uZSA9IFt4ICsgYnVmZmVyICsgMSwgaXNGbG9hdGluZ1RhbGxlciA/IHkgKyBidWZmZXIgLyAyIDogY3Vyc29yTGVhdmVGcm9tQm90dG9tID8geSArIGJ1ZmZlciAqIDQgOiB5IC0gYnVmZmVyICogNF07XG4gICAgICAgICAgICAgIGNvbnN0IGN1cnNvclBvaW50VHdvID0gW3ggKyBidWZmZXIgKyAxLCBpc0Zsb2F0aW5nVGFsbGVyID8geSAtIGJ1ZmZlciAvIDIgOiBjdXJzb3JMZWF2ZUZyb21Cb3R0b20gPyB5ICsgYnVmZmVyICogNCA6IHkgLSBidWZmZXIgKiA0XTtcbiAgICAgICAgICAgICAgY29uc3QgY29tbW9uUG9pbnRzID0gW1tjdXJzb3JMZWF2ZUZyb21Cb3R0b20gPyByZWN0LnJpZ2h0IC0gYnVmZmVyIDogaXNGbG9hdGluZ1RhbGxlciA/IHJlY3QucmlnaHQgLSBidWZmZXIgOiByZWN0LmxlZnQsIHJlY3QudG9wXSwgW2N1cnNvckxlYXZlRnJvbUJvdHRvbSA/IGlzRmxvYXRpbmdUYWxsZXIgPyByZWN0LnJpZ2h0IC0gYnVmZmVyIDogcmVjdC5sZWZ0IDogcmVjdC5yaWdodCAtIGJ1ZmZlciwgcmVjdC5ib3R0b21dXTtcbiAgICAgICAgICAgICAgcmV0dXJuIFsuLi5jb21tb25Qb2ludHMsIGN1cnNvclBvaW50T25lLCBjdXJzb3JQb2ludFR3b107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSAncmlnaHQnOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBjb25zdCBjdXJzb3JQb2ludE9uZSA9IFt4IC0gYnVmZmVyLCBpc0Zsb2F0aW5nVGFsbGVyID8geSArIGJ1ZmZlciAvIDIgOiBjdXJzb3JMZWF2ZUZyb21Cb3R0b20gPyB5ICsgYnVmZmVyICogNCA6IHkgLSBidWZmZXIgKiA0XTtcbiAgICAgICAgICAgICAgY29uc3QgY3Vyc29yUG9pbnRUd28gPSBbeCAtIGJ1ZmZlciwgaXNGbG9hdGluZ1RhbGxlciA/IHkgLSBidWZmZXIgLyAyIDogY3Vyc29yTGVhdmVGcm9tQm90dG9tID8geSArIGJ1ZmZlciAqIDQgOiB5IC0gYnVmZmVyICogNF07XG4gICAgICAgICAgICAgIGNvbnN0IGNvbW1vblBvaW50cyA9IFtbY3Vyc29yTGVhdmVGcm9tQm90dG9tID8gcmVjdC5sZWZ0ICsgYnVmZmVyIDogaXNGbG9hdGluZ1RhbGxlciA/IHJlY3QubGVmdCArIGJ1ZmZlciA6IHJlY3QucmlnaHQsIHJlY3QudG9wXSwgW2N1cnNvckxlYXZlRnJvbUJvdHRvbSA/IGlzRmxvYXRpbmdUYWxsZXIgPyByZWN0LmxlZnQgKyBidWZmZXIgOiByZWN0LnJpZ2h0IDogcmVjdC5sZWZ0ICsgYnVmZmVyLCByZWN0LmJvdHRvbV1dO1xuICAgICAgICAgICAgICByZXR1cm4gW2N1cnNvclBvaW50T25lLCBjdXJzb3JQb2ludFR3bywgLi4uY29tbW9uUG9pbnRzXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGlzUG9pbnRJblBvbHlnb24oW2NsaWVudFgsIGNsaWVudFldLCByZWN0UG9seSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGhhc0xhbmRlZCAmJiAhaXNPdmVyUmVmZXJlbmNlUmVjdCkge1xuICAgICAgICByZXR1cm4gY2xvc2UoKTtcbiAgICAgIH1cbiAgICAgIGlmICghaXNMZWF2ZSAmJiByZXF1aXJlSW50ZW50KSB7XG4gICAgICAgIGNvbnN0IGN1cnNvclNwZWVkID0gZ2V0Q3Vyc29yU3BlZWQoZXZlbnQuY2xpZW50WCwgZXZlbnQuY2xpZW50WSk7XG4gICAgICAgIGNvbnN0IGN1cnNvclNwZWVkVGhyZXNob2xkID0gMC4xO1xuICAgICAgICBpZiAoY3Vyc29yU3BlZWQgIT09IG51bGwgJiYgY3Vyc29yU3BlZWQgPCBjdXJzb3JTcGVlZFRocmVzaG9sZCkge1xuICAgICAgICAgIHJldHVybiBjbG9zZSgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoIWlzUG9pbnRJblBvbHlnb24oW2NsaWVudFgsIGNsaWVudFldLCBnZXRQb2x5Z29uKFt4LCB5XSkpKSB7XG4gICAgICAgIGNsb3NlKCk7XG4gICAgICB9IGVsc2UgaWYgKCFoYXNMYW5kZWQgJiYgcmVxdWlyZUludGVudCkge1xuICAgICAgICB0aW1lb3V0SWQgPSB3aW5kb3cuc2V0VGltZW91dChjbG9zZSwgNDApO1xuICAgICAgfVxuICAgIH07XG4gIH07XG4gIGZuLl9fb3B0aW9ucyA9IHtcbiAgICBibG9ja1BvaW50ZXJFdmVudHNcbiAgfTtcbiAgcmV0dXJuIGZuO1xufVxuXG5leHBvcnQgeyBDb21wb3NpdGUsIENvbXBvc2l0ZUl0ZW0sIEZsb2F0aW5nQXJyb3csIEZsb2F0aW5nRGVsYXlHcm91cCwgRmxvYXRpbmdGb2N1c01hbmFnZXIsIEZsb2F0aW5nTGlzdCwgRmxvYXRpbmdOb2RlLCBGbG9hdGluZ092ZXJsYXksIEZsb2F0aW5nUG9ydGFsLCBGbG9hdGluZ1RyZWUsIGlubmVyLCBzYWZlUG9seWdvbiwgdXNlQ2xpY2ssIHVzZUNsaWVudFBvaW50LCB1c2VEZWxheUdyb3VwLCB1c2VEZWxheUdyb3VwQ29udGV4dCwgdXNlRGlzbWlzcywgdXNlRmxvYXRpbmcsIHVzZUZsb2F0aW5nTm9kZUlkLCB1c2VGbG9hdGluZ1BhcmVudE5vZGVJZCwgdXNlRmxvYXRpbmdQb3J0YWxOb2RlLCB1c2VGbG9hdGluZ1RyZWUsIHVzZUZvY3VzLCB1c2VIb3ZlciwgdXNlSWQsIHVzZUlubmVyT2Zmc2V0LCB1c2VJbnRlcmFjdGlvbnMsIHVzZUxpc3RJdGVtLCB1c2VMaXN0TmF2aWdhdGlvbiwgdXNlTWVyZ2VSZWZzLCB1c2VSb2xlLCB1c2VUcmFuc2l0aW9uU3RhdHVzLCB1c2VUcmFuc2l0aW9uU3R5bGVzLCB1c2VUeXBlYWhlYWQgfTtcbiJdLCJuYW1lcyI6WyJSZWFjdCIsInVzZUxheW91dEVmZmVjdCIsInVzZUVmZmVjdCIsInVzZVJlZiIsInN0b3BFdmVudCIsImdldERvY3VtZW50IiwiaXNNb3VzZUxpa2VQb2ludGVyVHlwZSIsImNvbnRhaW5zIiwiYWN0aXZlRWxlbWVudCIsImlzU2FmYXJpIiwiaXNUeXBlYWJsZUNvbWJvYm94IiwiaXNWaXJ0dWFsQ2xpY2siLCJpc1ZpcnR1YWxQb2ludGVyRXZlbnQiLCJnZXRUYXJnZXQiLCJnZXRQbGF0Zm9ybSIsImlzVHlwZWFibGVFbGVtZW50IiwiaXNSZWFjdEV2ZW50IiwiaXNSb290RWxlbWVudCIsImlzRXZlbnRUYXJnZXRXaXRoaW4iLCJpc01hYyIsImdldFVzZXJBZ2VudCIsImZsb29yIiwicGxhdGZvcm0iLCJnZXRPdmVyZmxvd0FuY2VzdG9ycyIsInVzZUZsb2F0aW5nIiwidXNlRmxvYXRpbmckMSIsIm9mZnNldCIsImRldGVjdE92ZXJmbG93IiwiYXJyb3ciLCJhdXRvUGxhY2VtZW50IiwiYXV0b1VwZGF0ZSIsImNvbXB1dGVQb3NpdGlvbiIsImZsaXAiLCJoaWRlIiwiaW5saW5lIiwibGltaXRTaGlmdCIsInNoaWZ0Iiwic2l6ZSIsImlzRWxlbWVudCIsImlzSFRNTEVsZW1lbnQiLCJnZXROb2RlTmFtZSIsImdldFdpbmRvdyIsImlzTGFzdFRyYXZlcnNhYmxlTm9kZSIsImdldFBhcmVudE5vZGUiLCJnZXRDb21wdXRlZFN0eWxlIiwidGFiYmFibGUiLCJjcmVhdGVQb3J0YWwiLCJmbHVzaFN5bmMiLCJ1c2VNZXJnZVJlZnMiLCJyZWZzIiwidXNlTWVtbyIsImV2ZXJ5IiwicmVmIiwidmFsdWUiLCJmb3JFYWNoIiwiY3VycmVudCIsInVzZUluc2VydGlvbkVmZmVjdCIsInRvU3RyaW5nIiwidXNlU2FmZUluc2VydGlvbkVmZmVjdCIsImZuIiwidXNlRWZmZWN0RXZlbnQiLCJjYWxsYmFjayIsInByb2Nlc3MiLCJFcnJvciIsInVzZUNhbGxiYWNrIiwiX2xlbiIsImFyZ3VtZW50cyIsImxlbmd0aCIsImFyZ3MiLCJBcnJheSIsIl9rZXkiLCJBUlJPV19VUCIsIkFSUk9XX0RPV04iLCJBUlJPV19MRUZUIiwiQVJST1dfUklHSFQiLCJpc0RpZmZlcmVudFJvdyIsImluZGV4IiwiY29scyIsInByZXZSb3ciLCJNYXRoIiwiaXNJbmRleE91dE9mQm91bmRzIiwibGlzdFJlZiIsImdldE1pbkluZGV4IiwiZGlzYWJsZWRJbmRpY2VzIiwiZmluZE5vbkRpc2FibGVkSW5kZXgiLCJnZXRNYXhJbmRleCIsImRlY3JlbWVudCIsInN0YXJ0aW5nSW5kZXgiLCJfdGVtcCIsImFtb3VudCIsImxpc3QiLCJpc0Rpc2FibGVkSW5kZXgiLCJpbmNsdWRlcyIsImVsZW1lbnQiLCJoYXNBdHRyaWJ1dGUiLCJnZXRBdHRyaWJ1dGUiLCJnZXRHcmlkTmF2aWdhdGVkSW5kZXgiLCJlbGVtZW50c1JlZiIsIl9yZWYiLCJldmVudCIsIm9yaWVudGF0aW9uIiwibG9vcCIsIm1pbkluZGV4IiwibWF4SW5kZXgiLCJwcmV2SW5kZXgiLCJzdG9wIiwibmV4dEluZGV4Iiwia2V5IiwiY29sIiwibWF4Q29sIiwibGFzdFJvdyIsImJ1aWxkQ2VsbE1hcCIsInNpemVzIiwiZGVuc2UiLCJjZWxsTWFwIiwic3RhcnRJbmRleCIsIl9yZWYyIiwid2lkdGgiLCJoZWlnaHQiLCJpdGVtUGxhY2VkIiwidGFyZ2V0Q2VsbHMiLCJpIiwiaiIsInB1c2giLCJjZWxsIiwiZ2V0Q2VsbEluZGV4T2ZDb3JuZXIiLCJjb3JuZXIiLCJmaXJzdENlbGxJbmRleCIsImluZGV4T2YiLCJsYXN0SW5kZXhPZiIsImdldENlbGxJbmRpY2VzIiwiaW5kaWNlcyIsImZsYXRNYXAiLCJjZWxsSW5kZXgiLCJyYWZJZCIsImVucXVldWVGb2N1cyIsImVsIiwib3B0aW9ucyIsInByZXZlbnRTY3JvbGwiLCJjYW5jZWxQcmV2aW91cyIsInN5bmMiLCJjYW5jZWxBbmltYXRpb25GcmFtZSIsImV4ZWMiLCJmb2N1cyIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsImRvY3VtZW50Iiwic29ydEJ5RG9jdW1lbnRQb3NpdGlvbiIsImEiLCJiIiwicG9zaXRpb24iLCJjb21wYXJlRG9jdW1lbnRQb3NpdGlvbiIsIk5vZGUiLCJET0NVTUVOVF9QT1NJVElPTl9GT0xMT1dJTkciLCJET0NVTUVOVF9QT1NJVElPTl9DT05UQUlORURfQlkiLCJET0NVTUVOVF9QT1NJVElPTl9QUkVDRURJTkciLCJET0NVTUVOVF9QT1NJVElPTl9DT05UQUlOUyIsImFyZU1hcHNFcXVhbCIsIm1hcDEiLCJtYXAyIiwiZW50cmllcyIsImdldCIsIkZsb2F0aW5nTGlzdENvbnRleHQiLCJjcmVhdGVDb250ZXh0IiwicmVnaXN0ZXIiLCJ1bnJlZ2lzdGVyIiwibWFwIiwiTWFwIiwiRmxvYXRpbmdMaXN0IiwiY2hpbGRyZW4iLCJsYWJlbHNSZWYiLCJzZXRNYXAiLCJ1c2VTdGF0ZSIsIm5vZGUiLCJwcmV2TWFwIiwic2V0IiwiZGVsZXRlIiwibmV3TWFwIiwibm9kZXMiLCJmcm9tIiwia2V5cyIsInNvcnQiLCJjcmVhdGVFbGVtZW50IiwiUHJvdmlkZXIiLCJ1c2VMaXN0SXRlbSIsImxhYmVsIiwiaW5kZXgkMSIsInNldEluZGV4IiwiY29tcG9uZW50UmVmIiwidXNlQ29udGV4dCIsIl9ub2RlJHRleHRDb250ZW50IiwiaXNMYWJlbERlZmluZWQiLCJ1bmRlZmluZWQiLCJ0ZXh0Q29udGVudCIsInJlbmRlckpzeCIsInJlbmRlciIsImNvbXB1dGVkUHJvcHMiLCJjbG9uZUVsZW1lbnQiLCJDb21wb3NpdGVDb250ZXh0IiwiYWN0aXZlSW5kZXgiLCJvbk5hdmlnYXRlIiwiaG9yaXpvbnRhbEtleXMiLCJ2ZXJ0aWNhbEtleXMiLCJhbGxLZXlzIiwiQ29tcG9zaXRlIiwiZm9yd2FyZFJlZiIsImZvcndhcmRlZFJlZiIsImV4dGVybmFsQWN0aXZlSW5kZXgiLCJleHRlcm5hbFNldEFjdGl2ZUluZGV4IiwiaXRlbVNpemVzIiwicHJvcHMiLCJpbnRlcm5hbEFjdGl2ZUluZGV4IiwiaW50ZXJuYWxTZXRBY3RpdmVJbmRleCIsInJlbmRlckVsZW1lbnRQcm9wcyIsImNvbnRleHRWYWx1ZSIsImlzR3JpZCIsImhhbmRsZUtleURvd24iLCJtaW5HcmlkSW5kZXgiLCJmaW5kSW5kZXgiLCJtYXhHcmlkSW5kZXgiLCJyZWR1Y2UiLCJmb3VuZEluZGV4IiwiaXRlbUluZGV4IiwidG9FbmRLZXlzIiwiaG9yaXpvbnRhbCIsInZlcnRpY2FsIiwiYm90aCIsInRvU3RhcnRLZXlzIiwicHJldmVudGVkS2V5cyIsInN0b3BQcm9wYWdhdGlvbiIsInByZXZlbnREZWZhdWx0IiwicXVldWVNaWNyb3Rhc2siLCJvbktleURvd24iLCJlIiwiQ29tcG9zaXRlSXRlbSIsIm1lcmdlZFJlZiIsImlzQWN0aXZlIiwidGFiSW5kZXgiLCJvbkZvY3VzIiwiX2V4dGVuZHMiLCJPYmplY3QiLCJhc3NpZ24iLCJiaW5kIiwidGFyZ2V0Iiwic291cmNlIiwicHJvdG90eXBlIiwiaGFzT3duUHJvcGVydHkiLCJjYWxsIiwiYXBwbHkiLCJzZXJ2ZXJIYW5kb2ZmQ29tcGxldGUiLCJjb3VudCIsImdlbklkIiwidXNlRmxvYXRpbmdJZCIsImlkIiwic2V0SWQiLCJ1c2VSZWFjdElkIiwidXNlSWQiLCJGbG9hdGluZ0Fycm93IiwiY29udGV4dCIsInBsYWNlbWVudCIsImVsZW1lbnRzIiwiZmxvYXRpbmciLCJtaWRkbGV3YXJlRGF0YSIsInRpcFJhZGl1cyIsInN0cm9rZVdpZHRoIiwic3RhdGljT2Zmc2V0Iiwic3Ryb2tlIiwiZCIsInN0eWxlIiwidHJhbnNmb3JtIiwicmVzdFN0eWxlIiwicmVzdCIsImNvbnNvbGUiLCJ3YXJuIiwiY2xpcFBhdGhJZCIsImhhbGZTdHJva2VXaWR0aCIsInN2Z1giLCJzdmdZIiwic2lkZSIsImFsaWdubWVudCIsInNwbGl0IiwiaXNSVEwiLCJpc0N1c3RvbVNoYXBlIiwiaXNWZXJ0aWNhbFNpZGUiLCJ5T2Zmc2V0UHJvcCIsInhPZmZzZXRQcm9wIiwiYXJyb3dYIiwieCIsImFycm93WSIsInkiLCJkVmFsdWUiLCJyb3RhdGlvbiIsInRvcCIsImxlZnQiLCJib3R0b20iLCJyaWdodCIsInZpZXdCb3giLCJwb2ludGVyRXZlbnRzIiwiY2xpcFBhdGgiLCJmaWxsIiwiY3JlYXRlUHViU3ViIiwiZW1pdCIsImRhdGEiLCJfbWFwJGdldCIsImhhbmRsZXIiLCJvbiIsImxpc3RlbmVyIiwib2ZmIiwiX21hcCRnZXQyIiwiZmlsdGVyIiwibCIsIkZsb2F0aW5nTm9kZUNvbnRleHQiLCJGbG9hdGluZ1RyZWVDb250ZXh0IiwidXNlRmxvYXRpbmdQYXJlbnROb2RlSWQiLCJfUmVhY3QkdXNlQ29udGV4dCIsInVzZUZsb2F0aW5nVHJlZSIsInVzZUZsb2F0aW5nTm9kZUlkIiwiY3VzdG9tUGFyZW50SWQiLCJ0cmVlIiwicmVhY3RQYXJlbnRJZCIsInBhcmVudElkIiwiYWRkTm9kZSIsInJlbW92ZU5vZGUiLCJGbG9hdGluZ05vZGUiLCJGbG9hdGluZ1RyZWUiLCJub2Rlc1JlZiIsIm4iLCJldmVudHMiLCJjcmVhdGVBdHRyaWJ1dGUiLCJuYW1lIiwidXNlTGF0ZXN0UmVmIiwic2FmZVBvbHlnb25JZGVudGlmaWVyIiwiZ2V0RGVsYXkiLCJwcm9wIiwicG9pbnRlclR5cGUiLCJ1c2VIb3ZlciIsIm9wZW4iLCJvbk9wZW5DaGFuZ2UiLCJkYXRhUmVmIiwiZG9tUmVmZXJlbmNlIiwiZW5hYmxlZCIsImRlbGF5IiwiaGFuZGxlQ2xvc2UiLCJtb3VzZU9ubHkiLCJyZXN0TXMiLCJtb3ZlIiwiaGFuZGxlQ2xvc2VSZWYiLCJkZWxheVJlZiIsInBvaW50ZXJUeXBlUmVmIiwidGltZW91dFJlZiIsImhhbmRsZXJSZWYiLCJyZXN0VGltZW91dFJlZiIsImJsb2NrTW91c2VNb3ZlUmVmIiwicGVyZm9ybWVkUG9pbnRlckV2ZW50c011dGF0aW9uUmVmIiwidW5iaW5kTW91c2VNb3ZlUmVmIiwiaXNIb3Zlck9wZW4iLCJfZGF0YVJlZiRjdXJyZW50JG9wZW4iLCJ0eXBlIiwib3BlbkV2ZW50IiwiY2xlYXJUaW1lb3V0Iiwib25MZWF2ZSIsImh0bWwiLCJkb2N1bWVudEVsZW1lbnQiLCJhZGRFdmVudExpc3RlbmVyIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsImNsb3NlV2l0aERlbGF5IiwicnVuRWxzZUJyYW5jaCIsInJlYXNvbiIsImNsb3NlRGVsYXkiLCJzZXRUaW1lb3V0IiwiY2xlYW51cE1vdXNlTW92ZUhhbmRsZXIiLCJjbGVhclBvaW50ZXJFdmVudHMiLCJib2R5IiwicmVtb3ZlQXR0cmlidXRlIiwiaXNDbGlja0xpa2VPcGVuRXZlbnQiLCJvbk1vdXNlRW50ZXIiLCJvcGVuRGVsYXkiLCJvbk1vdXNlTGVhdmUiLCJkb2MiLCJjbGllbnRYIiwiY2xpZW50WSIsIm9uQ2xvc2UiLCJzaG91bGRDbG9zZSIsInJlbGF0ZWRUYXJnZXQiLCJvblNjcm9sbE1vdXNlTGVhdmUiLCJvbmNlIiwiX2hhbmRsZUNsb3NlUmVmJGN1cnJlIiwiX19vcHRpb25zIiwiYmxvY2tQb2ludGVyRXZlbnRzIiwic2V0QXR0cmlidXRlIiwiX3RyZWUkbm9kZXNSZWYkY3VycmVuIiwicGFyZW50RmxvYXRpbmciLCJmaW5kIiwic2V0UG9pbnRlclJlZiIsInJlZmVyZW5jZSIsIm9uUG9pbnRlckRvd24iLCJvblBvaW50ZXJFbnRlciIsIm9uTW91c2VNb3ZlIiwibmF0aXZlRXZlbnQiLCJGbG9hdGluZ0RlbGF5R3JvdXBDb250ZXh0IiwiaW5pdGlhbERlbGF5IiwidGltZW91dE1zIiwiY3VycmVudElkIiwic2V0Q3VycmVudElkIiwic2V0U3RhdGUiLCJpc0luc3RhbnRQaGFzZSIsInVzZURlbGF5R3JvdXBDb250ZXh0IiwiRmxvYXRpbmdEZWxheUdyb3VwIiwic3RhdGUiLCJ1c2VSZWR1Y2VyIiwicHJldiIsIm5leHQiLCJpbml0aWFsQ3VycmVudElkUmVmIiwidXNlRGVsYXlHcm91cCIsIl9yZWYzIiwiY2xvc2UiLCJ1bnNldCIsInRpbWVvdXQiLCJ3aW5kb3ciLCJnZXRBbmNlc3RvcnMiLCJfbm9kZXMkZmluZCIsImFsbEFuY2VzdG9ycyIsImN1cnJlbnRQYXJlbnRJZCIsImN1cnJlbnROb2RlIiwiY29uY2F0IiwiZ2V0Q2hpbGRyZW4iLCJhbGxDaGlsZHJlbiIsIl9ub2RlJGNvbnRleHQiLCJjdXJyZW50Q2hpbGRyZW4iLCJfY3VycmVudENoaWxkcmVuIiwic29tZSIsIl9ub2RlJGNvbnRleHQyIiwiZ2V0RGVlcGVzdE5vZGUiLCJkZWVwZXN0Tm9kZUlkIiwibWF4RGVwdGgiLCJmaW5kRGVlcGVzdCIsIm5vZGVJZCIsImRlcHRoIiwiY2hpbGQiLCJjb3VudGVyTWFwIiwiV2Vha01hcCIsInVuY29udHJvbGxlZEVsZW1lbnRzU2V0IiwiV2Vha1NldCIsIm1hcmtlck1hcCIsImxvY2tDb3VudCIsInN1cHBvcnRzSW5lcnQiLCJIVE1MRWxlbWVudCIsInVud3JhcEhvc3QiLCJob3N0IiwicGFyZW50Tm9kZSIsImNvcnJlY3RFbGVtZW50cyIsInBhcmVudCIsInRhcmdldHMiLCJjb3JyZWN0ZWRUYXJnZXQiLCJhcHBseUF0dHJpYnV0ZVRvT3RoZXJzIiwidW5jb3JyZWN0ZWRBdm9pZEVsZW1lbnRzIiwiYXJpYUhpZGRlbiIsImluZXJ0IiwibWFya2VyTmFtZSIsImNvbnRyb2xBdHRyaWJ1dGUiLCJhdm9pZEVsZW1lbnRzIiwiZWxlbWVudHNUb0tlZXAiLCJTZXQiLCJlbGVtZW50c1RvU3RvcCIsImhpZGRlbkVsZW1lbnRzIiwibWFya2VyQ291bnRlciIsImtlZXAiLCJkZWVwIiwiY2xlYXIiLCJoYXMiLCJhZGQiLCJhdHRyIiwiYWxyZWFkeUhpZGRlbiIsImNvdW50ZXJWYWx1ZSIsIm1hcmtlclZhbHVlIiwibWFya090aGVycyIsInF1ZXJ5U2VsZWN0b3JBbGwiLCJnZXRUYWJiYWJsZU9wdGlvbnMiLCJnZXRTaGFkb3dSb290IiwiZGlzcGxheUNoZWNrIiwiUmVzaXplT2JzZXJ2ZXIiLCJnZXRUYWJiYWJsZUluIiwiY29udGFpbmVyIiwiZGlyZWN0aW9uIiwiYWxsVGFiYmFibGUiLCJyZXZlcnNlIiwibmV4dFRhYmJhYmxlRWxlbWVudHMiLCJzbGljZSIsImdldE5leHRUYWJiYWJsZSIsImdldFByZXZpb3VzVGFiYmFibGUiLCJpc091dHNpZGVFdmVudCIsImNvbnRhaW5lckVsZW1lbnQiLCJjdXJyZW50VGFyZ2V0IiwiZGlzYWJsZUZvY3VzSW5zaWRlIiwidGFiYmFibGVFbGVtZW50cyIsImRhdGFzZXQiLCJ0YWJpbmRleCIsImVuYWJsZUZvY3VzSW5zaWRlIiwiSElEREVOX1NUWUxFUyIsImJvcmRlciIsImNsaXAiLCJtYXJnaW4iLCJvdmVyZmxvdyIsInBhZGRpbmciLCJ3aGl0ZVNwYWNlIiwidGltZW91dElkIiwic2V0QWN0aXZlRWxlbWVudE9uVGFiIiwiRm9jdXNHdWFyZCIsInJvbGUiLCJzZXRSb2xlIiwicmVzdFByb3BzIiwiUG9ydGFsQ29udGV4dCIsInVzZUZsb2F0aW5nUG9ydGFsTm9kZSIsInJvb3QiLCJwb3J0YWxOb2RlIiwic2V0UG9ydGFsTm9kZSIsInVuaXF1ZUlkIiwicG9ydGFsQ29udGV4dCIsInVzZVBvcnRhbENvbnRleHQiLCJwb3J0YWxOb2RlUmVmIiwicmVtb3ZlIiwiZXhpc3RpbmdJZFJvb3QiLCJnZXRFbGVtZW50QnlJZCIsInN1YlJvb3QiLCJhcHBlbmRDaGlsZCIsImlkV3JhcHBlciIsIkZsb2F0aW5nUG9ydGFsIiwicHJlc2VydmVUYWJPcmRlciIsImZvY3VzTWFuYWdlclN0YXRlIiwic2V0Rm9jdXNNYW5hZ2VyU3RhdGUiLCJiZWZvcmVPdXRzaWRlUmVmIiwiYWZ0ZXJPdXRzaWRlUmVmIiwiYmVmb3JlSW5zaWRlUmVmIiwiYWZ0ZXJJbnNpZGVSZWYiLCJzaG91bGRSZW5kZXJHdWFyZHMiLCJtb2RhbCIsImZvY3VzaW5nIiwibWFuYWdlRm9jdXMiLCJfYmVmb3JlSW5zaWRlUmVmJGN1cnIiLCJwcmV2VGFiYmFibGUiLCJfYWZ0ZXJJbnNpZGVSZWYkY3VycmUiLCJuZXh0VGFiYmFibGUiLCJjbG9zZU9uRm9jdXNPdXQiLCJMSVNUX0xJTUlUIiwicHJldmlvdXNseUZvY3VzZWRFbGVtZW50cyIsImFkZFByZXZpb3VzbHlGb2N1c2VkRWxlbWVudCIsImlzQ29ubmVjdGVkIiwiZ2V0UHJldmlvdXNseUZvY3VzZWRFbGVtZW50IiwiVmlzdWFsbHlIaWRkZW5EaXNtaXNzIiwiRmxvYXRpbmdGb2N1c01hbmFnZXIiLCJkaXNhYmxlZCIsIm9yZGVyIiwiZ3VhcmRzIiwiX2d1YXJkcyIsImluaXRpYWxGb2N1cyIsInJldHVybkZvY3VzIiwidmlzdWFsbHlIaWRkZW5EaXNtaXNzIiwiaWdub3JlSW5pdGlhbEZvY3VzIiwiaXNVbnRyYXBwZWRUeXBlYWJsZUNvbWJvYm94Iiwib3JkZXJSZWYiLCJpbml0aWFsRm9jdXNSZWYiLCJyZXR1cm5Gb2N1c1JlZiIsInN0YXJ0RGlzbWlzc0J1dHRvblJlZiIsImVuZERpc21pc3NCdXR0b25SZWYiLCJwcmV2ZW50UmV0dXJuRm9jdXNSZWYiLCJpc1BvaW50ZXJEb3duUmVmIiwiaXNJbnNpZGVQb3J0YWwiLCJnZXRUYWJiYWJsZUNvbnRlbnQiLCJnZXRUYWJiYWJsZUVsZW1lbnRzIiwiY29udGVudCIsIkJvb2xlYW4iLCJmbGF0IiwiZWxzIiwic2hpZnRLZXkiLCJoYW5kbGVQb2ludGVyRG93biIsImhhbmRsZUZvY3VzT3V0c2lkZSIsIm1vdmVkVG9VbnJlbGF0ZWROb2RlIiwiX25vZGUkY29udGV4dDMiLCJfbm9kZSRjb250ZXh0NCIsIl9wb3J0YWxDb250ZXh0JHBvcnRhbCIsInBvcnRhbE5vZGVzIiwiaW5zaWRlRWxlbWVudHMiLCJjbGVhbnVwIiwicHJldmlvdXNseUZvY3VzZWRFbGVtZW50IiwiZm9jdXNhYmxlRWxlbWVudHMiLCJpbml0aWFsRm9jdXNWYWx1ZSIsImVsVG9Gb2N1cyIsImZvY3VzQWxyZWFkeUluc2lkZUZsb2F0aW5nRWwiLCJwcmV2ZW50UmV0dXJuRm9jdXNTY3JvbGwiLCJjb250ZXh0RGF0YSIsIm5lc3RlZCIsImFjdGl2ZUVsIiwiaXNGb2N1c0luc2lkZUZsb2F0aW5nVHJlZSIsIl9ub2RlJGNvbnRleHQ1Iiwic2hvdWxkRm9jdXNSZWZlcmVuY2UiLCJyZXR1cm5FbGVtZW50IiwiTXV0YXRpb25PYnNlcnZlciIsImhhbmRsZU11dGF0aW9uIiwib2JzZXJ2ZXIiLCJvYnNlcnZlIiwiY2hpbGRMaXN0Iiwic3VidHJlZSIsImF0dHJpYnV0ZXMiLCJkaXNjb25uZWN0IiwicmVuZGVyRGlzbWlzc0J1dHRvbiIsImxvY2F0aW9uIiwib25DbGljayIsIkZyYWdtZW50IiwiX3BvcnRhbENvbnRleHQkYmVmb3JlIiwiX3BvcnRhbENvbnRleHQkYWZ0ZXJPIiwiYWN0aXZlTG9ja3MiLCJGbG9hdGluZ092ZXJsYXkiLCJsb2NrU2Nyb2xsIiwibG9ja0lkIiwiaXNJT1MiLCJ0ZXN0IiwiYm9keVN0eWxlIiwic2Nyb2xsYmFyWCIsInJvdW5kIiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0Iiwic2Nyb2xsTGVmdCIsInBhZGRpbmdQcm9wIiwic2Nyb2xsYmFyV2lkdGgiLCJpbm5lcldpZHRoIiwiY2xpZW50V2lkdGgiLCJzY3JvbGxYIiwicGFyc2VGbG9hdCIsInBhZ2VYT2Zmc2V0Iiwic2Nyb2xsWSIsInBhZ2VZT2Zmc2V0IiwiX3dpbmRvdyR2aXN1YWxWaWV3cG9yIiwiX3dpbmRvdyR2aXN1YWxWaWV3cG9yMiIsIm9mZnNldExlZnQiLCJ2aXN1YWxWaWV3cG9ydCIsIm9mZnNldFRvcCIsInNjcm9sbFRvIiwiaXNCdXR0b25UYXJnZXQiLCJ0YWdOYW1lIiwiaXNTcGFjZUlnbm9yZWQiLCJ1c2VDbGljayIsImV2ZW50T3B0aW9uIiwidG9nZ2xlIiwiaWdub3JlTW91c2UiLCJrZXlib2FyZEhhbmRsZXJzIiwiZGlkS2V5RG93blJlZiIsIm9uTW91c2VEb3duIiwiYnV0dG9uIiwiZGVmYXVsdFByZXZlbnRlZCIsIm9uS2V5VXAiLCJjcmVhdGVWaXJ0dWFsRWxlbWVudCIsImRvbVJlZiIsIm9mZnNldFgiLCJvZmZzZXRZIiwiaXNBdXRvVXBkYXRlRXZlbnQiLCJjb250ZXh0RWxlbWVudCIsIl9kb21SZWYkY3VycmVudCIsIl9kYXRhJGRhdGFSZWYkY3VycmVudCIsImRvbVJlY3QiLCJpc1hBeGlzIiwiYXhpcyIsImlzWUF4aXMiLCJjYW5UcmFja0N1cnNvck9uQXV0b1VwZGF0ZSIsImlzTW91c2VCYXNlZEV2ZW50IiwidXNlQ2xpZW50UG9pbnQiLCJpbml0aWFsUmVmIiwiY2xlYW51cExpc3RlbmVyUmVmIiwic2V0UG9pbnRlclR5cGUiLCJyZWFjdGl2ZSIsInNldFJlYWN0aXZlIiwic2V0UmVmZXJlbmNlIiwic2V0UG9zaXRpb25SZWZlcmVuY2UiLCJoYW5kbGVSZWZlcmVuY2VFbnRlck9yTW92ZSIsIm9wZW5DaGVjayIsImFkZExpc3RlbmVyIiwid2luIiwiaGFuZGxlTW91c2VNb3ZlIiwic2V0UG9pbnRlclR5cGVSZWYiLCJidWJibGVIYW5kbGVyS2V5cyIsInBvaW50ZXJkb3duIiwibW91c2Vkb3duIiwiY2xpY2siLCJjYXB0dXJlSGFuZGxlcktleXMiLCJub3JtYWxpemVQcm9wIiwibm9ybWFsaXphYmxlIiwiX25vcm1hbGl6YWJsZSRlc2NhcGVLIiwiX25vcm1hbGl6YWJsZSRvdXRzaWRlIiwiZXNjYXBlS2V5Iiwib3V0c2lkZVByZXNzIiwidXNlRGlzbWlzcyIsInVuc3RhYmxlX291dHNpZGVQcmVzcyIsIm91dHNpZGVQcmVzc0V2ZW50IiwicmVmZXJlbmNlUHJlc3MiLCJyZWZlcmVuY2VQcmVzc0V2ZW50IiwiYW5jZXN0b3JTY3JvbGwiLCJidWJibGVzIiwiY2FwdHVyZSIsIm91dHNpZGVQcmVzc0ZuIiwiaW5zaWRlUmVhY3RUcmVlUmVmIiwiZW5kZWRPclN0YXJ0ZWRJbnNpZGVSZWYiLCJlc2NhcGVLZXlCdWJibGVzIiwib3V0c2lkZVByZXNzQnViYmxlcyIsImVzY2FwZUtleUNhcHR1cmUiLCJvdXRzaWRlUHJlc3NDYXB0dXJlIiwiY2xvc2VPbkVzY2FwZUtleURvd24iLCJzaG91bGREaXNtaXNzIiwiX2NoaWxkJGNvbnRleHQiLCJfX2VzY2FwZUtleUJ1YmJsZXMiLCJjbG9zZU9uRXNjYXBlS2V5RG93bkNhcHR1cmUiLCJfZ2V0VGFyZ2V0MiIsIl9nZXRUYXJnZXQiLCJjbG9zZU9uUHJlc3NPdXRzaWRlIiwiaW5zaWRlUmVhY3RUcmVlIiwiZW5kZWRPclN0YXJ0ZWRJbnNpZGUiLCJpbmVydFNlbGVjdG9yIiwibWFya2VycyIsInRhcmdldFJvb3RBbmNlc3RvciIsIm5leHRQYXJlbnQiLCJtYXJrZXIiLCJjYW5TY3JvbGxYIiwic2Nyb2xsV2lkdGgiLCJjYW5TY3JvbGxZIiwiY2xpZW50SGVpZ2h0Iiwic2Nyb2xsSGVpZ2h0IiwieENvbmQiLCJvZmZzZXRXaWR0aCIsInRhcmdldElzSW5zaWRlQ2hpbGRyZW4iLCJfY2hpbGQkY29udGV4dDIiLCJfX291dHNpZGVQcmVzc0J1YmJsZXMiLCJjbG9zZU9uUHJlc3NPdXRzaWRlQ2FwdHVyZSIsIl9nZXRUYXJnZXQ0IiwiX2dldFRhcmdldDMiLCJvblNjcm9sbCIsImFuY2VzdG9ycyIsImFuY2VzdG9yIiwiX2RvYyRkZWZhdWx0VmlldyIsImRlZmF1bHRWaWV3IiwicGFzc2l2ZSIsIm9uTW91c2VVcCIsImRldk1lc3NhZ2VTZXQiLCJfb3B0aW9ucyRlbGVtZW50czIiLCJ1bnN0YWJsZV9vbk9wZW5DaGFuZ2UiLCJfb3B0aW9ucyRlbGVtZW50cyIsImVyciIsIl9kZXZNZXNzYWdlU2V0IiwiX2Rldk1lc3NhZ2VTZXQyIiwiZXJyb3IiLCJfZG9tUmVmZXJlbmNlIiwic2V0RG9tUmVmZXJlbmNlIiwiZG9tUmVmZXJlbmNlUmVmIiwiZmxvYXRpbmdJZCIsInBvc2l0aW9uUmVmZXJlbmNlIiwidXNlRm9jdXMiLCJ2aXNpYmxlT25seSIsImJsb2NrRm9jdXNSZWYiLCJrZXlib2FyZE1vZGFsaXR5UmVmIiwib25CbHVyIiwibWF0Y2hlcyIsIm1vdmVkVG9Gb2N1c0d1YXJkIiwib3duZXJEb2N1bWVudCIsIkFDVElWRV9LRVkiLCJTRUxFQ1RFRF9LRVkiLCJtZXJnZVByb3BzIiwidXNlclByb3BzIiwicHJvcHNMaXN0IiwiZWxlbWVudEtleSIsImlzSXRlbSIsImRvbVVzZXJQcm9wcyIsIl8iLCJfXyIsInZhbGlkUHJvcHMiLCJwcm9wc09yR2V0UHJvcHMiLCJhY2MiLCJ2YWwiLCJ1c2VJbnRlcmFjdGlvbnMiLCJkZXBzIiwiZ2V0UmVmZXJlbmNlUHJvcHMiLCJnZXRGbG9hdGluZ1Byb3BzIiwiZ2V0SXRlbVByb3BzIiwiaXRlbSIsImlzUHJldmVudFNjcm9sbFN1cHBvcnRlZCIsImRvU3dpdGNoIiwiaXNNYWluT3JpZW50YXRpb25LZXkiLCJpc01haW5PcmllbnRhdGlvblRvRW5kS2V5IiwicnRsIiwiaXNDcm9zc09yaWVudGF0aW9uT3BlbktleSIsImlzQ3Jvc3NPcmllbnRhdGlvbkNsb3NlS2V5IiwidXNlTGlzdE5hdmlnYXRpb24iLCJ1bnN0YWJsZV9vbk5hdmlnYXRlIiwic2VsZWN0ZWRJbmRleCIsImFsbG93RXNjYXBlIiwidmlydHVhbCIsImZvY3VzSXRlbU9uT3BlbiIsImZvY3VzSXRlbU9uSG92ZXIiLCJvcGVuT25BcnJvd0tleURvd24iLCJzY3JvbGxJdGVtSW50b1ZpZXciLCJ2aXJ0dWFsSXRlbVJlZiIsImpvaW4iLCJmb2N1c0l0ZW1Pbk9wZW5SZWYiLCJpbmRleFJlZiIsImtleVJlZiIsImlzUG9pbnRlck1vZGFsaXR5UmVmIiwicHJldmlvdXNPbk5hdmlnYXRlUmVmIiwicHJldmlvdXNNb3VudGVkUmVmIiwiZm9yY2VTeW5jRm9jdXMiLCJmb3JjZVNjcm9sbEludG9WaWV3UmVmIiwiZGlzYWJsZWRJbmRpY2VzUmVmIiwibGF0ZXN0T3BlblJlZiIsInNjcm9sbEl0ZW1JbnRvVmlld1JlZiIsImFjdGl2ZUlkIiwic2V0QWN0aXZlSWQiLCJ2aXJ0dWFsSWQiLCJzZXRWaXJ0dWFsSWQiLCJmb2N1c0l0ZW0iLCJmb3JjZVNjcm9sbEludG9WaWV3Iiwic2Nyb2xsSW50b1ZpZXdPcHRpb25zIiwic2hvdWxkU2Nyb2xsSW50b1ZpZXciLCJzY3JvbGxJbnRvVmlldyIsImJsb2NrIiwicnVucyIsIndhaXRGb3JMaXN0UG9wdWxhdGVkIiwic2NoZWR1bGVyIiwidHJlZUNvbnRhaW5zQWN0aXZlRWwiLCJoYW5kbGVWaXJ0dWFsRm9jdXMiLCJoYXNBY3RpdmVJbmRleCIsInN5bmNDdXJyZW50VGFyZ2V0Iiwib25Qb2ludGVyTGVhdmUiLCJfcmVmNCIsImN1cnJlbnRJbmRleCIsIm1pbiIsIm1heCIsImNoZWNrVmlydHVhbE1vdXNlIiwiY2hlY2tWaXJ0dWFsUG9pbnRlciIsImFyaWFBY3RpdmVEZXNjZW5kYW50UHJvcCIsImFjdGl2ZUl0ZW0iLCJpc0Fycm93S2V5IiwiaXNDcm9zc09wZW5LZXkiLCJpc0Nyb3NzQ2xvc2VLZXkiLCJpc01haW5LZXkiLCJpc05hdmlnYXRpb25LZXkiLCJ0cmltIiwicm9vdE5vZGUiLCJkZWVwZXN0Tm9kZSIsImV2ZW50T2JqZWN0IiwiS2V5Ym9hcmRFdmVudCIsIl9kZWVwZXN0Tm9kZSRjb250ZXh0IiwiX2RlZXBlc3ROb2RlJGNvbnRleHQyIiwiaXNDdXJyZW50VGFyZ2V0IiwiZGlzcGF0Y2hJdGVtIiwiZGlzcGF0Y2hFdmVudCIsIl9kZWVwZXN0Tm9kZSRjb250ZXh0JCIsIm9uUG9pbnRlck1vdmUiLCJjb21wb25lbnRSb2xlVG9BcmlhUm9sZU1hcCIsInVzZVJvbGUiLCJfY29tcG9uZW50Um9sZVRvQXJpYVIiLCJhcmlhUm9sZSIsInJlZmVyZW5jZUlkIiwiaXNOZXN0ZWQiLCJmbG9hdGluZ1Byb3BzIiwiYWN0aXZlIiwic2VsZWN0ZWQiLCJjb21tb25Qcm9wcyIsImNhbWVsQ2FzZVRvS2ViYWJDYXNlIiwic3RyIiwicmVwbGFjZSIsIiQiLCJvZnMiLCJ0b0xvd2VyQ2FzZSIsImV4ZWNXaXRoQXJnc09yUmV0dXJuIiwidmFsdWVPckZuIiwidXNlRGVsYXlVbm1vdW50IiwiZHVyYXRpb25NcyIsImlzTW91bnRlZCIsInNldElzTW91bnRlZCIsInVzZVRyYW5zaXRpb25TdGF0dXMiLCJkdXJhdGlvbiIsImlzTnVtYmVyRHVyYXRpb24iLCJjbG9zZUR1cmF0aW9uIiwiaW5pdGlhdGVkIiwic2V0SW5pdGlhdGVkIiwic3RhdHVzIiwic2V0U3RhdHVzIiwiZnJhbWUiLCJ1c2VUcmFuc2l0aW9uU3R5bGVzIiwiaW5pdGlhbCIsInVuc3RhYmxlX2luaXRpYWwiLCJvcGFjaXR5IiwidW5zdGFibGVfb3BlbiIsInVuc3RhYmxlX2Nsb3NlIiwiY29tbW9uIiwidW5zdGFibGVfY29tbW9uIiwiZm5BcmdzIiwib3BlbkR1cmF0aW9uIiwic3R5bGVzIiwic2V0U3R5bGVzIiwib3BlblJlZiIsImNsb3NlUmVmIiwiY29tbW9uUmVmIiwiaW5pdGlhbFN0eWxlcyIsImNsb3NlU3R5bGVzIiwiY29tbW9uU3R5bGVzIiwib3BlblN0eWxlcyIsInRyYW5zaXRpb25Qcm9wZXJ0eSIsInRyYW5zaXRpb25EdXJhdGlvbiIsInVzZVR5cGVhaGVhZCIsIm9uTWF0Y2giLCJ1bnN0YWJsZV9vbk1hdGNoIiwib25UeXBpbmdDaGFuZ2UiLCJ1bnN0YWJsZV9vblR5cGluZ0NoYW5nZSIsImZpbmRNYXRjaCIsInJlc2V0TXMiLCJpZ25vcmVLZXlzIiwidGltZW91dElkUmVmIiwic3RyaW5nUmVmIiwicHJldkluZGV4UmVmIiwibWF0Y2hJbmRleFJlZiIsImZpbmRNYXRjaFJlZiIsImlnbm9yZUtleXNSZWYiLCJzZXRUeXBpbmdDaGFuZ2UiLCJ0eXBpbmciLCJnZXRNYXRjaGluZ0luZGV4Iiwib3JkZXJlZExpc3QiLCJzdHJpbmciLCJ0ZXh0IiwidG9Mb2NhbGVMb3dlckNhc2UiLCJsaXN0Q29udGVudCIsImN0cmxLZXkiLCJtZXRhS2V5IiwiYWx0S2V5IiwiYWxsb3dSYXBpZFN1Y2Nlc3Npb25PZkZpcnN0TGV0dGVyIiwiX3RleHQkIiwiX3RleHQkMiIsImdldEFyZ3NXaXRoQ3VzdG9tRmxvYXRpbmdIZWlnaHQiLCJyZWN0cyIsImlubmVyIiwib3ZlcmZsb3dSZWYiLCJvbkZhbGxiYWNrQ2hhbmdlIiwiaW5uZXJPZmZzZXQiLCJtaW5JdGVtc1Zpc2libGUiLCJyZWZlcmVuY2VPdmVyZmxvd1RocmVzaG9sZCIsInNjcm9sbFJlZiIsImRldGVjdE92ZXJmbG93T3B0aW9ucyIsInN0YXJ0c1dpdGgiLCJuZXh0QXJncyIsImNsaWVudFRvcCIsIm9mZnNldEhlaWdodCIsInJlZk92ZXJmbG93IiwiZWxlbWVudENvbnRleHQiLCJkaWZmWSIsIm5leHRZIiwibWF4SGVpZ2h0Iiwic2Nyb2xsVG9wIiwidXNlSW5uZXJPZmZzZXQiLCJvbkNoYW5nZSIsInVuc3RhYmxlX29uQ2hhbmdlIiwiY29udHJvbGxlZFNjcm9sbGluZ1JlZiIsInByZXZTY3JvbGxUb3BSZWYiLCJpbml0aWFsT3ZlcmZsb3dSZWYiLCJvbldoZWVsIiwiZFkiLCJkZWx0YVkiLCJpc0F0VG9wIiwiaXNBdEJvdHRvbSIsInJlbWFpbmluZ1Njcm9sbCIsInNpZ24iLCJtZXRob2QiLCJzY3JvbGxEaWZmIiwiaXNQb2ludEluUG9seWdvbiIsInBvaW50IiwicG9seWdvbiIsImlzSW5zaWRlIiwieGkiLCJ5aSIsInhqIiwieWoiLCJpbnRlcnNlY3QiLCJyZWN0Iiwic2FmZVBvbHlnb24iLCJidWZmZXIiLCJyZXF1aXJlSW50ZW50IiwiaGFzTGFuZGVkIiwibGFzdFgiLCJsYXN0WSIsImxhc3RDdXJzb3JUaW1lIiwicGVyZm9ybWFuY2UiLCJub3ciLCJnZXRDdXJzb3JTcGVlZCIsImN1cnJlbnRUaW1lIiwiZWxhcHNlZFRpbWUiLCJkZWx0YVgiLCJkaXN0YW5jZSIsInNxcnQiLCJzcGVlZCIsImNsaWVudFBvaW50IiwiaXNMZWF2ZSIsImlzT3ZlckZsb2F0aW5nRWwiLCJpc092ZXJSZWZlcmVuY2VFbCIsInJlZlJlY3QiLCJjdXJzb3JMZWF2ZUZyb21SaWdodCIsImN1cnNvckxlYXZlRnJvbUJvdHRvbSIsImlzT3ZlclJlZmVyZW5jZVJlY3QiLCJpc0Zsb2F0aW5nV2lkZXIiLCJpc0Zsb2F0aW5nVGFsbGVyIiwicmVjdFBvbHkiLCJnZXRQb2x5Z29uIiwiY3Vyc29yUG9pbnRPbmUiLCJjdXJzb3JQb2ludFR3byIsImNvbW1vblBvaW50cyIsImN1cnNvclNwZWVkIiwiY3Vyc29yU3BlZWRUaHJlc2hvbGQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@floating-ui/react/dist/floating-ui.react.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@floating-ui/react/dist/floating-ui.react.utils.mjs":
/*!**************************************************************************!*\
  !*** ./node_modules/@floating-ui/react/dist/floating-ui.react.utils.mjs ***!
  \**************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   TYPEABLE_SELECTOR: () => (/* binding */ TYPEABLE_SELECTOR),\n/* harmony export */   activeElement: () => (/* binding */ activeElement),\n/* harmony export */   contains: () => (/* binding */ contains),\n/* harmony export */   getDocument: () => (/* binding */ getDocument),\n/* harmony export */   getPlatform: () => (/* binding */ getPlatform),\n/* harmony export */   getTarget: () => (/* binding */ getTarget),\n/* harmony export */   getUserAgent: () => (/* binding */ getUserAgent),\n/* harmony export */   isAndroid: () => (/* binding */ isAndroid),\n/* harmony export */   isEventTargetWithin: () => (/* binding */ isEventTargetWithin),\n/* harmony export */   isJSDOM: () => (/* binding */ isJSDOM),\n/* harmony export */   isMac: () => (/* binding */ isMac),\n/* harmony export */   isMouseLikePointerType: () => (/* binding */ isMouseLikePointerType),\n/* harmony export */   isReactEvent: () => (/* binding */ isReactEvent),\n/* harmony export */   isRootElement: () => (/* binding */ isRootElement),\n/* harmony export */   isSafari: () => (/* binding */ isSafari),\n/* harmony export */   isTypeableCombobox: () => (/* binding */ isTypeableCombobox),\n/* harmony export */   isTypeableElement: () => (/* binding */ isTypeableElement),\n/* harmony export */   isVirtualClick: () => (/* binding */ isVirtualClick),\n/* harmony export */   isVirtualPointerEvent: () => (/* binding */ isVirtualPointerEvent),\n/* harmony export */   stopEvent: () => (/* binding */ stopEvent)\n/* harmony export */ });\n/* harmony import */ var _floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @floating-ui/utils/dom */ \"(ssr)/./node_modules/@floating-ui/utils/dist/floating-ui.utils.dom.mjs\");\n\nfunction activeElement(doc) {\n    let activeElement = doc.activeElement;\n    while(((_activeElement = activeElement) == null || (_activeElement = _activeElement.shadowRoot) == null ? void 0 : _activeElement.activeElement) != null){\n        var _activeElement;\n        activeElement = activeElement.shadowRoot.activeElement;\n    }\n    return activeElement;\n}\nfunction contains(parent, child) {\n    if (!parent || !child) {\n        return false;\n    }\n    const rootNode = child.getRootNode == null ? void 0 : child.getRootNode();\n    // First, attempt with faster native method\n    if (parent.contains(child)) {\n        return true;\n    }\n    // then fallback to custom implementation with Shadow DOM support\n    if (rootNode && (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.isShadowRoot)(rootNode)) {\n        let next = child;\n        while(next){\n            if (parent === next) {\n                return true;\n            }\n            // @ts-ignore\n            next = next.parentNode || next.host;\n        }\n    }\n    // Give up, the result is false\n    return false;\n}\n// Avoid Chrome DevTools blue warning.\nfunction getPlatform() {\n    const uaData = navigator.userAgentData;\n    if (uaData != null && uaData.platform) {\n        return uaData.platform;\n    }\n    return navigator.platform;\n}\nfunction getUserAgent() {\n    const uaData = navigator.userAgentData;\n    if (uaData && Array.isArray(uaData.brands)) {\n        return uaData.brands.map((_ref)=>{\n            let { brand, version } = _ref;\n            return brand + \"/\" + version;\n        }).join(\" \");\n    }\n    return navigator.userAgent;\n}\n// License: https://github.com/adobe/react-spectrum/blob/b35d5c02fe900badccd0cf1a8f23bb593419f238/packages/@react-aria/utils/src/isVirtualEvent.ts\nfunction isVirtualClick(event) {\n    // FIXME: Firefox is now emitting a deprecation warning for `mozInputSource`.\n    // Try to find a workaround for this. `react-aria` source still has the check.\n    if (event.mozInputSource === 0 && event.isTrusted) {\n        return true;\n    }\n    if (isAndroid() && event.pointerType) {\n        return event.type === \"click\" && event.buttons === 1;\n    }\n    return event.detail === 0 && !event.pointerType;\n}\nfunction isVirtualPointerEvent(event) {\n    if (isJSDOM()) return false;\n    return !isAndroid() && event.width === 0 && event.height === 0 || isAndroid() && event.width === 1 && event.height === 1 && event.pressure === 0 && event.detail === 0 && event.pointerType === \"mouse\" || // iOS VoiceOver returns 0.333â€¢ for width/height.\n    event.width < 1 && event.height < 1 && event.pressure === 0 && event.detail === 0 && event.pointerType === \"touch\";\n}\nfunction isSafari() {\n    // Chrome DevTools does not complain about navigator.vendor\n    return /apple/i.test(navigator.vendor);\n}\nfunction isAndroid() {\n    const re = /android/i;\n    return re.test(getPlatform()) || re.test(getUserAgent());\n}\nfunction isMac() {\n    return getPlatform().toLowerCase().startsWith(\"mac\") && !navigator.maxTouchPoints;\n}\nfunction isJSDOM() {\n    return getUserAgent().includes(\"jsdom/\");\n}\nfunction isMouseLikePointerType(pointerType, strict) {\n    // On some Linux machines with Chromium, mouse inputs return a `pointerType`\n    // of \"pen\": https://github.com/floating-ui/floating-ui/issues/2015\n    const values = [\n        \"mouse\",\n        \"pen\"\n    ];\n    if (!strict) {\n        values.push(\"\", undefined);\n    }\n    return values.includes(pointerType);\n}\nfunction isReactEvent(event) {\n    return \"nativeEvent\" in event;\n}\nfunction isRootElement(element) {\n    return element.matches(\"html,body\");\n}\nfunction getDocument(node) {\n    return (node == null ? void 0 : node.ownerDocument) || document;\n}\nfunction isEventTargetWithin(event, node) {\n    if (node == null) {\n        return false;\n    }\n    if (\"composedPath\" in event) {\n        return event.composedPath().includes(node);\n    }\n    // TS thinks `event` is of type never as it assumes all browsers support composedPath, but browsers without shadow dom don't\n    const e = event;\n    return e.target != null && node.contains(e.target);\n}\nfunction getTarget(event) {\n    if (\"composedPath\" in event) {\n        return event.composedPath()[0];\n    }\n    // TS thinks `event` is of type never as it assumes all browsers support\n    // `composedPath()`, but browsers without shadow DOM don't.\n    return event.target;\n}\nconst TYPEABLE_SELECTOR = \"input:not([type='hidden']):not([disabled]),\" + \"[contenteditable]:not([contenteditable='false']),textarea:not([disabled])\";\nfunction isTypeableElement(element) {\n    return (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.isHTMLElement)(element) && element.matches(TYPEABLE_SELECTOR);\n}\nfunction stopEvent(event) {\n    event.preventDefault();\n    event.stopPropagation();\n}\nfunction isTypeableCombobox(element) {\n    if (!element) return false;\n    return element.getAttribute(\"role\") === \"combobox\" && isTypeableElement(element);\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGZsb2F0aW5nLXVpL3JlYWN0L2Rpc3QvZmxvYXRpbmctdWkucmVhY3QudXRpbHMubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFxRTtBQUVyRSxTQUFTRSxjQUFjQyxHQUFHO0lBQ3hCLElBQUlELGdCQUFnQkMsSUFBSUQsYUFBYTtJQUNyQyxNQUFPLENBQUMsQ0FBQ0UsaUJBQWlCRixhQUFZLEtBQU0sUUFBUSxDQUFDRSxpQkFBaUJBLGVBQWVDLFVBQVUsS0FBSyxPQUFPLEtBQUssSUFBSUQsZUFBZUYsYUFBYSxLQUFLLEtBQU07UUFDekosSUFBSUU7UUFDSkYsZ0JBQWdCQSxjQUFjRyxVQUFVLENBQUNILGFBQWE7SUFDeEQ7SUFDQSxPQUFPQTtBQUNUO0FBQ0EsU0FBU0ksU0FBU0MsTUFBTSxFQUFFQyxLQUFLO0lBQzdCLElBQUksQ0FBQ0QsVUFBVSxDQUFDQyxPQUFPO1FBQ3JCLE9BQU87SUFDVDtJQUNBLE1BQU1DLFdBQVdELE1BQU1FLFdBQVcsSUFBSSxPQUFPLEtBQUssSUFBSUYsTUFBTUUsV0FBVztJQUV2RSwyQ0FBMkM7SUFDM0MsSUFBSUgsT0FBT0QsUUFBUSxDQUFDRSxRQUFRO1FBQzFCLE9BQU87SUFDVDtJQUVBLGlFQUFpRTtJQUNqRSxJQUFJQyxZQUFZVCxvRUFBWUEsQ0FBQ1MsV0FBVztRQUN0QyxJQUFJRSxPQUFPSDtRQUNYLE1BQU9HLEtBQU07WUFDWCxJQUFJSixXQUFXSSxNQUFNO2dCQUNuQixPQUFPO1lBQ1Q7WUFDQSxhQUFhO1lBQ2JBLE9BQU9BLEtBQUtDLFVBQVUsSUFBSUQsS0FBS0UsSUFBSTtRQUNyQztJQUNGO0lBRUEsK0JBQStCO0lBQy9CLE9BQU87QUFDVDtBQUNBLHNDQUFzQztBQUN0QyxTQUFTQztJQUNQLE1BQU1DLFNBQVNDLFVBQVVDLGFBQWE7SUFDdEMsSUFBSUYsVUFBVSxRQUFRQSxPQUFPRyxRQUFRLEVBQUU7UUFDckMsT0FBT0gsT0FBT0csUUFB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USxDQUFDNkQsRUFBRUMsTUFBTTtBQUNuRDtBQUNBLFNBQVNDLFVBQVV2QyxLQUFLO0lBQ3RCLElBQUksa0JBQWtCQSxPQUFPO1FBQzNCLE9BQU9BLE1BQU1vQyxZQUFZLEVBQUUsQ0FBQyxFQUFFO0lBQ2hDO0lBRUEsd0VBQXdFO0lBQ3hFLDJEQUEyRDtJQUMzRCxPQUFPcEMsTUFBTXNDLE1BQU07QUFDckI7QUFDQSxNQUFNRSxvQkFBb0IsZ0RBQWdEO0FBQzFFLFNBQVNDLGtCQUFrQlosT0FBTztJQUNoQyxPQUFPMUQscUVBQWFBLENBQUMwRCxZQUFZQSxRQUFRQyxPQUFPLENBQUNVO0FBQ25EO0FBQ0EsU0FBU0UsVUFBVTFDLEtBQUs7SUFDdEJBLE1BQU0yQyxjQUFjO0lBQ3BCM0MsTUFBTTRDLGVBQWU7QUFDdkI7QUFDQSxTQUFTQyxtQkFBbUJoQixPQUFPO0lBQ2pDLElBQUksQ0FBQ0EsU0FBUyxPQUFPO0lBQ3JCLE9BQU9BLFFBQVFpQixZQUFZLENBQUMsWUFBWSxjQUFjTCxrQkFBa0JaO0FBQzFFO0FBRWlUIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vb3Blbi1wcm8tbmV4dC8uL25vZGVfbW9kdWxlcy9AZmxvYXRpbmctdWkvcmVhY3QvZGlzdC9mbG9hdGluZy11aS5yZWFjdC51dGlscy5tanM/MGVjNSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBpc1NoYWRvd1Jvb3QsIGlzSFRNTEVsZW1lbnQgfSBmcm9tICdAZmxvYXRpbmctdWkvdXRpbHMvZG9tJztcblxuZnVuY3Rpb24gYWN0aXZlRWxlbWVudChkb2MpIHtcbiAgbGV0IGFjdGl2ZUVsZW1lbnQgPSBkb2MuYWN0aXZlRWxlbWVudDtcbiAgd2hpbGUgKCgoX2FjdGl2ZUVsZW1lbnQgPSBhY3RpdmVFbGVtZW50KSA9PSBudWxsIHx8IChfYWN0aXZlRWxlbWVudCA9IF9hY3RpdmVFbGVtZW50LnNoYWRvd1Jvb3QpID09IG51bGwgPyB2b2lkIDAgOiBfYWN0aXZlRWxlbWVudC5hY3RpdmVFbGVtZW50KSAhPSBudWxsKSB7XG4gICAgdmFyIF9hY3RpdmVFbGVtZW50O1xuICAgIGFjdGl2ZUVsZW1lbnQgPSBhY3RpdmVFbGVtZW50LnNoYWRvd1Jvb3QuYWN0aXZlRWxlbWVudDtcbiAgfVxuICByZXR1cm4gYWN0aXZlRWxlbWVudDtcbn1cbmZ1bmN0aW9uIGNvbnRhaW5zKHBhcmVudCwgY2hpbGQpIHtcbiAgaWYgKCFwYXJlbnQgfHwgIWNoaWxkKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IHJvb3ROb2RlID0gY2hpbGQuZ2V0Um9vdE5vZGUgPT0gbnVsbCA/IHZvaWQgMCA6IGNoaWxkLmdldFJvb3ROb2RlKCk7XG5cbiAgLy8gRmlyc3QsIGF0dGVtcHQgd2l0aCBmYXN0ZXIgbmF0aXZlIG1ldGhvZFxuICBpZiAocGFyZW50LmNvbnRhaW5zKGNoaWxkKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLy8gdGhlbiBmYWxsYmFjayB0byBjdXN0b20gaW1wbGVtZW50YXRpb24gd2l0aCBTaGFkb3cgRE9NIHN1cHBvcnRcbiAgaWYgKHJvb3ROb2RlICYmIGlzU2hhZG93Um9vdChyb290Tm9kZSkpIHtcbiAgICBsZXQgbmV4dCA9IGNoaWxkO1xuICAgIHdoaWxlIChuZXh0KSB7XG4gICAgICBpZiAocGFyZW50ID09PSBuZXh0KSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgbmV4dCA9IG5leHQucGFyZW50Tm9kZSB8fCBuZXh0Lmhvc3Q7XG4gICAgfVxuICB9XG5cbiAgLy8gR2l2ZSB1cCwgdGhlIHJlc3VsdCBpcyBmYWxzZVxuICByZXR1cm4gZmFsc2U7XG59XG4vLyBBdm9pZCBDaHJvbWUgRGV2VG9vbHMgYmx1ZSB3YXJuaW5nLlxuZnVuY3Rpb24gZ2V0UGxhdGZvcm0oKSB7XG4gIGNvbnN0IHVhRGF0YSA9IG5hdmlnYXRvci51c2VyQWdlbnREYXRhO1xuICBpZiAodWFEYXRhICE9IG51bGwgJiYgdWFEYXRhLnBsYXRmb3JtKSB7XG4gICAgcmV0dXJuIHVhRGF0YS5wbGF0Zm9ybTtcbiAgfVxuICByZXR1cm4gbmF2aWdhdG9yLnBsYXRmb3JtO1xufVxuZnVuY3Rpb24gZ2V0VXNlckFnZW50KCkge1xuICBjb25zdCB1YURhdGEgPSBuYXZpZ2F0b3IudXNlckFnZW50RGF0YTtcbiAgaWYgKHVhRGF0YSAmJiBBcnJheS5pc0FycmF5KHVhRGF0YS5icmFuZHMpKSB7XG4gICAgcmV0dXJuIHVhRGF0YS5icmFuZHMubWFwKF9yZWYgPT4ge1xuICAgICAgbGV0IHtcbiAgICAgICAgYnJhbmQsXG4gICAgICAgIHZlcnNpb25cbiAgICAgIH0gPSBfcmVmO1xuICAgICAgcmV0dXJuIGJyYW5kICsgXCIvXCIgKyB2ZXJzaW9uO1xuICAgIH0pLmpvaW4oJyAnKTtcbiAgfVxuICByZXR1cm4gbmF2aWdhdG9yLnVzZXJBZ2VudDtcbn1cblxuLy8gTGljZW5zZTogaHR0cHM6Ly9naXRodWIuY29tL2Fkb2JlL3JlYWN0LXNwZWN0cnVtL2Jsb2IvYjM1ZDVjMDJmZTkwMGJhZGNjZDBjZjFhOGYyM2JiNTkzNDE5ZjIzOC9wYWNrYWdlcy9AcmVhY3QtYXJpYS91dGlscy9zcmMvaXNWaXJ0dWFsRXZlbnQudHNcbmZ1bmN0aW9uIGlzVmlydHVhbENsaWNrKGV2ZW50KSB7XG4gIC8vIEZJWE1FOiBGaXJlZm94IGlzIG5vdyBlbWl0dGluZyBhIGRlcHJlY2F0aW9uIHdhcm5pbmcgZm9yIGBtb3pJbnB1dFNvdXJjZWAuXG4gIC8vIFRyeSB0byBmaW5kIGEgd29ya2Fyb3VuZCBmb3IgdGhpcy4gYHJlYWN0LWFyaWFgIHNvdXJjZSBzdGlsbCBoYXMgdGhlIGNoZWNrLlxuICBpZiAoZXZlbnQubW96SW5wdXRTb3VyY2UgPT09IDAgJiYgZXZlbnQuaXNUcnVzdGVkKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKGlzQW5kcm9pZCgpICYmIGV2ZW50LnBvaW50ZXJUeXBlKSB7XG4gICAgcmV0dXJuIGV2ZW50LnR5cGUgPT09ICdjbGljaycgJiYgZXZlbnQuYnV0dG9ucyA9PT0gMTtcbiAgfVxuICByZXR1cm4gZXZlbnQuZGV0YWlsID09PSAwICYmICFldmVudC5wb2ludGVyVHlwZTtcbn1cbmZ1bmN0aW9uIGlzVmlydHVhbFBvaW50ZXJFdmVudChldmVudCkge1xuICBpZiAoaXNKU0RPTSgpKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiAhaXNBbmRyb2lkKCkgJiYgZXZlbnQud2lkdGggPT09IDAgJiYgZXZlbnQuaGVpZ2h0ID09PSAwIHx8IGlzQW5kcm9pZCgpICYmIGV2ZW50LndpZHRoID09PSAxICYmIGV2ZW50LmhlaWdodCA9PT0gMSAmJiBldmVudC5wcmVzc3VyZSA9PT0gMCAmJiBldmVudC5kZXRhaWwgPT09IDAgJiYgZXZlbnQucG9pbnRlclR5cGUgPT09ICdtb3VzZScgfHxcbiAgLy8gaU9TIFZvaWNlT3ZlciByZXR1cm5zIDAuMzMz4oCiIGZvciB3aWR0aC9oZWlnaHQuXG4gIGV2ZW50LndpZHRoIDwgMSAmJiBldmVudC5oZWlnaHQgPCAxICYmIGV2ZW50LnByZXNzdXJlID09PSAwICYmIGV2ZW50LmRldGFpbCA9PT0gMCAmJiBldmVudC5wb2ludGVyVHlwZSA9PT0gJ3RvdWNoJztcbn1cbmZ1bmN0aW9uIGlzU2FmYXJpKCkge1xuICAvLyBDaHJvbWUgRGV2VG9vbHMgZG9lcyBub3QgY29tcGxhaW4gYWJvdXQgbmF2aWdhdG9yLnZlbmRvclxuICByZXR1cm4gL2FwcGxlL2kudGVzdChuYXZpZ2F0b3IudmVuZG9yKTtcbn1cbmZ1bmN0aW9uIGlzQW5kcm9pZCgpIHtcbiAgY29uc3QgcmUgPSAvYW5kcm9pZC9pO1xuICByZXR1cm4gcmUudGVzdChnZXRQbGF0Zm9ybSgpKSB8fCByZS50ZXN0KGdldFVzZXJBZ2VudCgpKTtcbn1cbmZ1bmN0aW9uIGlzTWFjKCkge1xuICByZXR1cm4gZ2V0UGxhdGZvcm0oKS50b0xvd2VyQ2FzZSgpLnN0YXJ0c1dpdGgoJ21hYycpICYmICFuYXZpZ2F0b3IubWF4VG91Y2hQb2ludHM7XG59XG5mdW5jdGlvbiBpc0pTRE9NKCkge1xuICByZXR1cm4gZ2V0VXNlckFnZW50KCkuaW5jbHVkZXMoJ2pzZG9tLycpO1xufVxuZnVuY3Rpb24gaXNNb3VzZUxpa2VQb2ludGVyVHlwZShwb2ludGVyVHlwZSwgc3RyaWN0KSB7XG4gIC8vIE9uIHNvbWUgTGludXggbWFjaGluZXMgd2l0aCBDaHJvbWl1bSwgbW91c2UgaW5wdXRzIHJldHVybiBhIGBwb2ludGVyVHlwZWBcbiAgLy8gb2YgXCJwZW5cIjogaHR0cHM6Ly9naXRodWIuY29tL2Zsb2F0aW5nLXVpL2Zsb2F0aW5nLXVpL2lzc3Vlcy8yMDE1XG4gIGNvbnN0IHZhbHVlcyA9IFsnbW91c2UnLCAncGVuJ107XG4gIGlmICghc3RyaWN0KSB7XG4gICAgdmFsdWVzLnB1c2goJycsIHVuZGVmaW5lZCk7XG4gIH1cbiAgcmV0dXJuIHZhbHVlcy5pbmNsdWRlcyhwb2ludGVyVHlwZSk7XG59XG5mdW5jdGlvbiBpc1JlYWN0RXZlbnQoZXZlbnQpIHtcbiAgcmV0dXJuICduYXRpdmVFdmVudCcgaW4gZXZlbnQ7XG59XG5mdW5jdGlvbiBpc1Jvb3RFbGVtZW50KGVsZW1lbnQpIHtcbiAgcmV0dXJuIGVsZW1lbnQubWF0Y2hlcygnaHRtbCxib2R5Jyk7XG59XG5mdW5jdGlvbiBnZXREb2N1bWVudChub2RlKSB7XG4gIHJldHVybiAobm9kZSA9PSBudWxsID8gdm9pZCAwIDogbm9kZS5vd25lckRvY3VtZW50KSB8fCBkb2N1bWVudDtcbn1cbmZ1bmN0aW9uIGlzRXZlbnRUYXJnZXRXaXRoaW4oZXZlbnQsIG5vZGUpIHtcbiAgaWYgKG5vZGUgPT0gbnVsbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoJ2NvbXBvc2VkUGF0aCcgaW4gZXZlbnQpIHtcbiAgICByZXR1cm4gZXZlbnQuY29tcG9zZWRQYXRoKCkuaW5jbHVkZXMobm9kZSk7XG4gIH1cblxuICAvLyBUUyB0aGlua3MgYGV2ZW50YCBpcyBvZiB0eXBlIG5ldmVyIGFzIGl0IGFzc3VtZXMgYWxsIGJyb3dzZXJzIHN1cHBvcnQgY29tcG9zZWRQYXRoLCBidXQgYnJvd3NlcnMgd2l0aG91dCBzaGFkb3cgZG9tIGRvbid0XG4gIGNvbnN0IGUgPSBldmVudDtcbiAgcmV0dXJuIGUudGFyZ2V0ICE9IG51bGwgJiYgbm9kZS5jb250YWlucyhlLnRhcmdldCk7XG59XG5mdW5jdGlvbiBnZXRUYXJnZXQoZXZlbnQpIHtcbiAgaWYgKCdjb21wb3NlZFBhdGgnIGluIGV2ZW50KSB7XG4gICAgcmV0dXJuIGV2ZW50LmNvbXBvc2VkUGF0aCgpWzBdO1xuICB9XG5cbiAgLy8gVFMgdGhpbmtzIGBldmVudGAgaXMgb2YgdHlwZSBuZXZlciBhcyBpdCBhc3N1bWVzIGFsbCBicm93c2VycyBzdXBwb3J0XG4gIC8vIGBjb21wb3NlZFBhdGgoKWAsIGJ1dCBicm93c2VycyB3aXRob3V0IHNoYWRvdyBET00gZG9uJ3QuXG4gIHJldHVybiBldmVudC50YXJnZXQ7XG59XG5jb25zdCBUWVBFQUJMRV9TRUxFQ1RPUiA9IFwiaW5wdXQ6bm90KFt0eXBlPSdoaWRkZW4nXSk6bm90KFtkaXNhYmxlZF0pLFwiICsgXCJbY29udGVudGVkaXRhYmxlXTpub3QoW2NvbnRlbnRlZGl0YWJsZT0nZmFsc2UnXSksdGV4dGFyZWE6bm90KFtkaXNhYmxlZF0pXCI7XG5mdW5jdGlvbiBpc1R5cGVhYmxlRWxlbWVudChlbGVtZW50KSB7XG4gIHJldHVybiBpc0hUTUxFbGVtZW50KGVsZW1lbnQpICYmIGVsZW1lbnQubWF0Y2hlcyhUWVBFQUJMRV9TRUxFQ1RPUik7XG59XG5mdW5jdGlvbiBzdG9wRXZlbnQoZXZlbnQpIHtcbiAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG59XG5mdW5jdGlvbiBpc1R5cGVhYmxlQ29tYm9ib3goZWxlbWVudCkge1xuICBpZiAoIWVsZW1lbnQpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdyb2xlJykgPT09ICdjb21ib2JveCcgJiYgaXNUeXBlYWJsZUVsZW1lbnQoZWxlbWVudCk7XG59XG5cbmV4cG9ydCB7IFRZUEVBQkxFX1NFTEVDVE9SLCBhY3RpdmVFbGVtZW50LCBjb250YWlucywgZ2V0RG9jdW1lbnQsIGdldFBsYXRmb3JtLCBnZXRUYXJnZXQsIGdldFVzZXJBZ2VudCwgaXNBbmRyb2lkLCBpc0V2ZW50VGFyZ2V0V2l0aGluLCBpc0pTRE9NLCBpc01hYywgaXNNb3VzZUxpa2VQb2ludGVyVHlwZSwgaXNSZWFjdEV2ZW50LCBpc1Jvb3RFbGVtZW50LCBpc1NhZmFyaSwgaXNUeXBlYWJsZUNvbWJvYm94LCBpc1R5cGVhYmxlRWxlbWVudCwgaXNWaXJ0dWFsQ2xpY2ssIGlzVmlydHVhbFBvaW50ZXJFdmVudCwgc3RvcEV2ZW50IH07XG4iXSwibmFtZXMiOlsiaXNTaGFkb3dSb290IiwiaXNIVE1MRWxlbWVudCIsImFjdGl2ZUVsZW1lbnQiLCJkb2MiLCJfYWN0aXZlRWxlbWVudCIsInNoYWRvd1Jvb3QiLCJjb250YWlucyIsInBhcmVudCIsImNoaWxkIiwicm9vdE5vZGUiLCJnZXRSb290Tm9kZSIsIm5leHQiLCJwYXJlbnROb2RlIiwiaG9zdCIsImdldFBsYXRmb3JtIiwidWFEYXRhIiwibmF2aWdhdG9yIiwidXNlckFnZW50RGF0YSIsInBsYXRmb3JtIiwiZ2V0VXNlckFnZW50IiwiQXJyYXkiLCJpc0FycmF5IiwiYnJhbmRzIiwibWFwIiwiX3JlZiIsImJyYW5kIiwidmVyc2lvbiIsImpvaW4iLCJ1c2VyQWdlbnQiLCJpc1ZpcnR1YWxDbGljayIsImV2ZW50IiwibW96SW5wdXRTb3VyY2UiLCJpc1RydXN0ZWQiLCJpc0FuZHJvaWQiLCJwb2ludGVyVHlwZSIsInR5cGUiLCJidXR0b25zIiwiZGV0YWlsIiwiaXNWaXJ0dWFsUG9pbnRlckV2ZW50IiwiaXNKU0RPTSIsIndpZHRoIiwiaGVpZ2h0IiwicHJlc3N1cmUiLCJpc1NhZmFyaSIsInRlc3QiLCJ2ZW5kb3IiLCJyZSIsImlzTWFjIiwidG9Mb3dlckNhc2UiLCJzdGFydHNXaXRoIiwibWF4VG91Y2hQb2ludHMiLCJpbmNsdWRlcyIsImlzTW91c2VMaWtlUG9pbnRlclR5cGUiLCJzdHJpY3QiLCJ2YWx1ZXMiLCJwdXNoIiwidW5kZWZpbmVkIiwiaXNSZWFjdEV2ZW50IiwiaXNSb290RWxlbWVudCIsImVsZW1lbnQiLCJtYXRjaGVzIiwiZ2V0RG9jdW1lbnQiLCJub2RlIiwib3duZXJEb2N1bWVudCIsImRvY3VtZW50IiwiaXNFdmVudFRhcmdldFdpdGhpbiIsImNvbXBvc2VkUGF0aCIsImUiLCJ0YXJnZXQiLCJnZXRUYXJnZXQiLCJUWVBFQUJMRV9TRUxFQ1RPUiIsImlzVHlwZWFibGVFbGVtZW50Iiwic3RvcEV2ZW50IiwicHJldmVudERlZmF1bHQiLCJzdG9wUHJvcGFnYXRpb24iLCJpc1R5cGVhYmxlQ29tYm9ib3giLCJnZXRBdHRyaWJ1dGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@floating-ui/react/dist/floating-ui.react.utils.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@floating-ui/utils/dist/floating-ui.utils.dom.mjs":
/*!************************************************************************!*\
  !*** ./node_modules/@floating-ui/utils/dist/floating-ui.utils.dom.mjs ***!
  \************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getComputedStyle: () => (/* binding */ getComputedStyle),\n/* harmony export */   getContainingBlock: () => (/* binding */ getContainingBlock),\n/* harmony export */   getDocumentElement: () => (/* binding */ getDocumentElement),\n/* harmony export */   getNearestOverflowAncestor: () => (/* binding */ getNearestOverflowAncestor),\n/* harmony export */   getNodeName: () => (/* binding */ getNodeName),\n/* harmony export */   getNodeScroll: () => (/* binding */ getNodeScroll),\n/* harmony export */   getOverflowAncestors: () => (/* binding */ getOverflowAncestors),\n/* harmony export */   getParentNode: () => (/* binding */ getParentNode),\n/* harmony export */   getWindow: () => (/* binding */ getWindow),\n/* harmony export */   isContainingBlock: () => (/* binding */ isContainingBlock),\n/* harmony export */   isElement: () => (/* binding */ isElement),\n/* harmony export */   isHTMLElement: () => (/* binding */ isHTMLElement),\n/* harmony export */   isLastTraversableNode: () => (/* binding */ isLastTraversableNode),\n/* harmony export */   isNode: () => (/* binding */ isNode),\n/* harmony export */   isOverflowElement: () => (/* binding */ isOverflowElement),\n/* harmony export */   isShadowRoot: () => (/* binding */ isShadowRoot),\n/* harmony export */   isTableElement: () => (/* binding */ isTableElement),\n/* harmony export */   isWebKit: () => (/* binding */ isWebKit)\n/* harmony export */ });\nfunction getNodeName(node) {\n    if (isNode(node)) {\n        return (node.nodeName || \"\").toLowerCase();\n    }\n    // Mocked nodes in testing environments may not be instances of Node. By\n    // returning `#document` an infinite loop won't occur.\n    // https://github.com/floating-ui/floating-ui/issues/2317\n    return \"#document\";\n}\nfunction getWindow(node) {\n    var _node$ownerDocument;\n    return (node == null || (_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.defaultView) || window;\n}\nfunction getDocumentElement(node) {\n    var _ref;\n    return (_ref = (isNode(node) ? node.ownerDocument : node.document) || window.document) == null ? void 0 : _ref.documentElement;\n}\nfunction isNode(value) {\n    return value instanceof Node || value instanceof getWindow(value).Node;\n}\nfunction isElement(value) {\n    return value instanceof Element || value instanceof getWindow(value).Element;\n}\nfunction isHTMLElement(value) {\n    return value instanceof HTMLElement || value instanceof getWindow(value).HTMLElement;\n}\nfunction isShadowRoot(value) {\n    // Browsers without `ShadowRoot` support.\n    if (typeof ShadowRoot === \"undefined\") {\n        return false;\n    }\n    return value instanceof ShadowRoot || value instanceof getWindow(value).ShadowRoot;\n}\nfunction isOverflowElement(element) {\n    const { overflow, overflowX, overflowY, display } = getComputedStyle(element);\n    return /auto|scroll|overlay|hidden|clip/.test(overflow + overflowY + overflowX) && ![\n        \"inline\",\n        \"contents\"\n    ].includes(display);\n}\nfunction isTableElement(element) {\n    return [\n        \"table\",\n        \"td\",\n        \"th\"\n    ].includes(getNodeName(element));\n}\nfunction isContainingBlock(element) {\n    const webkit = isWebKit();\n    const css = getComputedStyle(element);\n    // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block\n    return css.transform !== \"none\" || css.perspective !== \"none\" || (css.containerType ? css.containerType !== \"normal\" : false) || !webkit && (css.backdropFilter ? css.backdropFilter !== \"none\" : false) || !webkit && (css.filter ? css.filter !== \"none\" : false) || [\n        \"transform\",\n        \"perspective\",\n        \"filter\"\n    ].some((value)=>(css.willChange || \"\").includes(value)) || [\n        \"paint\",\n        \"layout\",\n        \"strict\",\n        \"content\"\n    ].some((value)=>(css.contain || \"\").includes(value));\n}\nfunction getContainingBlock(element) {\n    let currentNode = getParentNode(element);\n    while(isHTMLElement(currentNode) && !isLastTraversableNode(currentNode)){\n        if (isContainingBlock(currentNode)) {\n            return currentNode;\n        } else {\n            currentNode = getParentNode(currentNode);\n        }\n    }\n    return null;\n}\nfunction isWebKit() {\n    if (typeof CSS === \"undefined\" || !CSS.supports) return false;\n    return CSS.supports(\"-webkit-backdrop-filter\", \"none\");\n}\nfunction isLastTraversableNode(node) {\n    return [\n        \"html\",\n        \"body\",\n        \"#document\"\n    ].includes(getNodeName(node));\n}\nfunction getComputedStyle(element) {\n    return getWindow(element).getComputedStyle(element);\n}\nfunction getNodeScroll(element) {\n    if (isElement(element)) {\n        return {\n            scrollLeft: element.scrollLeft,\n            scrollTop: element.scrollTop\n        };\n    }\n    return {\n        scrollLeft: element.pageXOffset,\n        scrollTop: element.pageYOffset\n    };\n}\nfunction getParentNode(node) {\n    if (getNodeName(node) === \"html\") {\n        return node;\n    }\n    const result = // Step into the shadow DOM of the parent of a slotted node.\n    node.assignedSlot || // DOM Element detected.\n    node.parentNode || // ShadowRoot detected.\n    isShadowRoot(node) && node.host || // Fallback.\n    getDocumentElement(node);\n    return isShadowRoot(result) ? result.host : result;\n}\nfunction getNearestOverflowAncestor(node) {\n    const parentNode = getParentNode(node);\n    if (isLastTraversableNode(parentNode)) {\n        return node.ownerDocument ? node.ownerDocument.body : node.body;\n    }\n    if (isHTMLElement(parentNode) && isOverflowElement(parentNode)) {\n        return parentNode;\n    }\n    return getNearestOverflowAncestor(parentNode);\n}\nfunction getOverflowAncestors(node, list, traverseIframes) {\n    var _node$ownerDocument2;\n    if (list === void 0) {\n        list = [];\n    }\n    if (traverseIframes === void 0) {\n        traverseIframes = true;\n    }\n    const scrollableAncestor = getNearestOverflowAncestor(node);\n    const isBody = scrollableAncestor === ((_node$ownerDocument2 = node.ownerDocument) == null ? void 0 : _node$ownerDocument2.body);\n    const win = getWindow(scrollableAncestor);\n    if (isBody) {\n        return list.concat(win, win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : [], win.frameElement && traverseIframes ? getOverflowAncestors(win.frameElement) : []);\n    }\n    return list.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor, [], traverseIframes));\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGZsb2F0aW5nLXVpL3V0aWxzL2Rpc3QvZmxvYXRpbmctdWkudXRpbHMuZG9tLm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSxTQUFTQSxZQUFZQyxJQUFJO0lBQ3ZCLElBQUlDLE9BQU9ELE9BQU87UUFDaEIsT0FBTyxDQUFDQSxLQUFLRSxRQUFRLElBQUksRUFBQyxFQUFHQyxXQUFXO0lBQzFDO0lBQ0Esd0VBQXdFO0lBQ3hFLHNEQUFzRDtJQUN0RCx5REFBeUQ7SUFDekQsT0FBTztBQUNUO0FBQ0EsU0FBU0MsVUFBVUosSUFBSTtJQUNyQixJQUFJSztJQUNKLE9BQU8sQ0FBQ0wsUUFBUSxRQUFRLENBQUNLLHNCQUFzQkwsS0FBS00sYUFBYSxLQUFLLE9BQU8sS0FBSyxJQUFJRCxvQkFBb0JFLFdBQVcsS0FBS0M7QUFDNUg7QUFDQSxTQUFTQyxtQkFBbUJULElBQUk7SUFDOUIsSUFBSVU7SUFDSixPQUFPLENBQUNBLE9BQU8sQ0FBQ1QsT0FBT0QsUUFBUUEsS0FBS00sYUFBYSxHQUFHTixLQUFLVyxRQUFRLEtBQUtILE9BQU9HLFFBQVEsS0FBSyxPQUFPLEtBQUssSUFBSUQsS0FBS0UsZUFBZTtBQUNoSTtBQUNBLFNBQVNYLE9BQU9ZLEtBQUs7SUFDbkIsT0FBT0EsaUJBQWlCQyxRQUFRRCxpQkFBaUJULFVBQVVTLE9BQU9DLElBQUk7QUFDeEU7QUFDQSxTQUFTQyxVQUFVRixLQUFLO0lBQ3RCLE9BQU9BLGlCQUFpQkcsV0FBV0gsaUJBQWlCVCxVQUFVUyxPQUFPRyxPQUFPO0FBQzlFO0FBQ0EsU0FBU0MsY0FBY0osS0FBSztJQUMxQixPQUFPQSxpQkFBaUJLLGVBQWVMLGlCQUFpQlQsVUFBVVMsT0FBT0ssV0FBVztBQUN0RjtBQUNBLFNBQVNDLGFBQWFOLEtBQUs7SUFDekIseUNBQXlDO0lBQ3pDLElBQUksT0FBT08sZUFBZSxhQUFhO1FBQ3JDLE9BQU87SUFDVDtJQUNBLE9BQU9QLGlCQUFp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SUFDakMsSUFBSThDLHNCQUFzQlUsYUFBYTtRQUNyQyxPQUFPeEQsS0FBS00sYUFBYSxHQUFHTixLQUFLTSxhQUFhLENBQUNxRCxJQUFJLEdBQUczRCxLQUFLMkQsSUFBSTtJQUNqRTtJQUNBLElBQUkxQyxjQUFjdUMsZUFBZW5DLGtCQUFrQm1DLGFBQWE7UUFDOUQsT0FBT0E7SUFDVDtJQUNBLE9BQU9FLDJCQUEyQkY7QUFDcEM7QUFDQSxTQUFTSSxxQkFBcUI1RCxJQUFJLEVBQUU2RCxJQUFJLEVBQUVDLGVBQWU7SUFDdkQsSUFBSUM7SUFDSixJQUFJRixTQUFTLEtBQUssR0FBRztRQUNuQkEsT0FBTyxFQUFFO0lBQ1g7SUFDQSxJQUFJQyxvQkFBb0IsS0FBSyxHQUFHO1FBQzlCQSxrQkFBa0I7SUFDcEI7SUFDQSxNQUFNRSxxQkFBcUJOLDJCQUEyQjFEO0lBQ3RELE1BQU1pRSxTQUFTRCx1QkFBd0IsRUFBQ0QsdUJBQXVCL0QsS0FBS00sYUFBYSxLQUFLLE9BQU8sS0FBSyxJQUFJeUQscUJBQXFCSixJQUFJO0lBQy9ILE1BQU1PLE1BQU05RCxVQUFVNEQ7SUFDdEIsSUFBSUMsUUFBUTtRQUNWLE9BQU9KLEtBQUtNLE1BQU0sQ0FBQ0QsS0FBS0EsSUFBSUUsY0FBYyxJQUFJLEVBQUUsRUFBRS9DLGtCQUFrQjJDLHNCQUFzQkEscUJBQXFCLEVBQUUsRUFBRUUsSUFBSUcsWUFBWSxJQUFJUCxrQkFBa0JGLHFCQUFxQk0sSUFBSUcsWUFBWSxJQUFJLEVBQUU7SUFDdE07SUFDQSxPQUFPUixLQUFLTSxNQUFNLENBQUNILG9CQUFvQkoscUJBQXFCSSxvQkFBb0IsRUFBRSxFQUFFRjtBQUN0RjtBQUVtVCIsInNvdXJjZXMiOlsid2VicGFjazovL29wZW4tcHJvLW5leHQvLi9ub2RlX21vZHVsZXMvQGZsb2F0aW5nLXVpL3V0aWxzL2Rpc3QvZmxvYXRpbmctdWkudXRpbHMuZG9tLm1qcz8yNGVhIl0sInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIGdldE5vZGVOYW1lKG5vZGUpIHtcbiAgaWYgKGlzTm9kZShub2RlKSkge1xuICAgIHJldHVybiAobm9kZS5ub2RlTmFtZSB8fCAnJykudG9Mb3dlckNhc2UoKTtcbiAgfVxuICAvLyBNb2NrZWQgbm9kZXMgaW4gdGVzdGluZyBlbnZpcm9ubWVudHMgbWF5IG5vdCBiZSBpbnN0YW5jZXMgb2YgTm9kZS4gQnlcbiAgLy8gcmV0dXJuaW5nIGAjZG9jdW1lbnRgIGFuIGluZmluaXRlIGxvb3Agd29uJ3Qgb2NjdXIuXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mbG9hdGluZy11aS9mbG9hdGluZy11aS9pc3N1ZXMvMjMxN1xuICByZXR1cm4gJyNkb2N1bWVudCc7XG59XG5mdW5jdGlvbiBnZXRXaW5kb3cobm9kZSkge1xuICB2YXIgX25vZGUkb3duZXJEb2N1bWVudDtcbiAgcmV0dXJuIChub2RlID09IG51bGwgfHwgKF9ub2RlJG93bmVyRG9jdW1lbnQgPSBub2RlLm93bmVyRG9jdW1lbnQpID09IG51bGwgPyB2b2lkIDAgOiBfbm9kZSRvd25lckRvY3VtZW50LmRlZmF1bHRWaWV3KSB8fCB3aW5kb3c7XG59XG5mdW5jdGlvbiBnZXREb2N1bWVudEVsZW1lbnQobm9kZSkge1xuICB2YXIgX3JlZjtcbiAgcmV0dXJuIChfcmVmID0gKGlzTm9kZShub2RlKSA/IG5vZGUub3duZXJEb2N1bWVudCA6IG5vZGUuZG9jdW1lbnQpIHx8IHdpbmRvdy5kb2N1bWVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9yZWYuZG9jdW1lbnRFbGVtZW50O1xufVxuZnVuY3Rpb24gaXNOb2RlKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIE5vZGUgfHwgdmFsdWUgaW5zdGFuY2VvZiBnZXRXaW5kb3codmFsdWUpLk5vZGU7XG59XG5mdW5jdGlvbiBpc0VsZW1lbnQodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgRWxlbWVudCB8fCB2YWx1ZSBpbnN0YW5jZW9mIGdldFdpbmRvdyh2YWx1ZSkuRWxlbWVudDtcbn1cbmZ1bmN0aW9uIGlzSFRNTEVsZW1lbnQodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQgfHwgdmFsdWUgaW5zdGFuY2VvZiBnZXRXaW5kb3codmFsdWUpLkhUTUxFbGVtZW50O1xufVxuZnVuY3Rpb24gaXNTaGFkb3dSb290KHZhbHVlKSB7XG4gIC8vIEJyb3dzZXJzIHdpdGhvdXQgYFNoYWRvd1Jvb3RgIHN1cHBvcnQuXG4gIGlmICh0eXBlb2YgU2hhZG93Um9vdCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgU2hhZG93Um9vdCB8fCB2YWx1ZSBpbnN0YW5jZW9mIGdldFdpbmRvdyh2YWx1ZSkuU2hhZG93Um9vdDtcbn1cbmZ1bmN0aW9uIGlzT3ZlcmZsb3dFbGVtZW50KGVsZW1lbnQpIHtcbiAgY29uc3Qge1xuICAgIG92ZXJmbG93LFxuICAgIG92ZXJmbG93WCxcbiAgICBvdmVyZmxvd1ksXG4gICAgZGlzcGxheVxuICB9ID0gZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KTtcbiAgcmV0dXJuIC9hdXRvfHNjcm9sbHxvdmVybGF5fGhpZGRlbnxjbGlwLy50ZXN0KG92ZXJmbG93ICsgb3ZlcmZsb3dZICsgb3ZlcmZsb3dYKSAmJiAhWydpbmxpbmUnLCAnY29udGVudHMnXS5pbmNsdWRlcyhkaXNwbGF5KTtcbn1cbmZ1bmN0aW9uIGlzVGFibGVFbGVtZW50KGVsZW1lbnQpIHtcbiAgcmV0dXJuIFsndGFibGUnLCAndGQnLCAndGgnXS5pbmNsdWRlcyhnZXROb2RlTmFtZShlbGVtZW50KSk7XG59XG5mdW5jdGlvbiBpc0NvbnRhaW5pbmdCbG9jayhlbGVtZW50KSB7XG4gIGNvbnN0IHdlYmtpdCA9IGlzV2ViS2l0KCk7XG4gIGNvbnN0IGNzcyA9IGdldENvbXB1dGVkU3R5bGUoZWxlbWVudCk7XG5cbiAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQ1NTL0NvbnRhaW5pbmdfYmxvY2sjaWRlbnRpZnlpbmdfdGhlX2NvbnRhaW5pbmdfYmxvY2tcbiAgcmV0dXJuIGNzcy50cmFuc2Zvcm0gIT09ICdub25lJyB8fCBjc3MucGVyc3BlY3RpdmUgIT09ICdub25lJyB8fCAoY3NzLmNvbnRhaW5lclR5cGUgPyBjc3MuY29udGFpbmVyVHlwZSAhPT0gJ25vcm1hbCcgOiBmYWxzZSkgfHwgIXdlYmtpdCAmJiAoY3NzLmJhY2tkcm9wRmlsdGVyID8gY3NzLmJhY2tkcm9wRmlsdGVyICE9PSAnbm9uZScgOiBmYWxzZSkgfHwgIXdlYmtpdCAmJiAoY3NzLmZpbHRlciA/IGNzcy5maWx0ZXIgIT09ICdub25lJyA6IGZhbHNlKSB8fCBbJ3RyYW5zZm9ybScsICdwZXJzcGVjdGl2ZScsICdmaWx0ZXInXS5zb21lKHZhbHVlID0+IChjc3Mud2lsbENoYW5nZSB8fCAnJykuaW5jbHVkZXModmFsdWUpKSB8fCBbJ3BhaW50JywgJ2xheW91dCcsICdzdHJpY3QnLCAnY29udGVudCddLnNvbWUodmFsdWUgPT4gKGNzcy5jb250YWluIHx8ICcnKS5pbmNsdWRlcyh2YWx1ZSkpO1xufVxuZnVuY3Rpb24gZ2V0Q29udGFpbmluZ0Jsb2NrKGVsZW1lbnQpIHtcbiAgbGV0IGN1cnJlbnROb2RlID0gZ2V0UGFyZW50Tm9kZShlbGVtZW50KTtcbiAgd2hpbGUgKGlzSFRNTEVsZW1lbnQoY3VycmVudE5vZGUpICYmICFpc0xhc3RUcmF2ZXJzYWJsZU5vZGUoY3VycmVudE5vZGUpKSB7XG4gICAgaWYgKGlzQ29udGFpbmluZ0Jsb2NrKGN1cnJlbnROb2RlKSkge1xuICAgICAgcmV0dXJuIGN1cnJlbnROb2RlO1xuICAgIH0gZWxzZSB7XG4gICAgICBjdXJyZW50Tm9kZSA9IGdldFBhcmVudE5vZGUoY3VycmVudE5vZGUpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIGlzV2ViS2l0KCkge1xuICBpZiAodHlwZW9mIENTUyA9PT0gJ3VuZGVmaW5lZCcgfHwgIUNTUy5zdXBwb3J0cykgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gQ1NTLnN1cHBvcnRzKCctd2Via2l0LWJhY2tkcm9wLWZpbHRlcicsICdub25lJyk7XG59XG5mdW5jdGlvbiBpc0xhc3RUcmF2ZXJzYWJsZU5vZGUobm9kZSkge1xuICByZXR1cm4gWydodG1sJywgJ2JvZHknLCAnI2RvY3VtZW50J10uaW5jbHVkZXMoZ2V0Tm9kZU5hbWUobm9kZSkpO1xufVxuZnVuY3Rpb24gZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KSB7XG4gIHJldHVybiBnZXRXaW5kb3coZWxlbWVudCkuZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KTtcbn1cbmZ1bmN0aW9uIGdldE5vZGVTY3JvbGwoZWxlbWVudCkge1xuICBpZiAoaXNFbGVtZW50KGVsZW1lbnQpKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHNjcm9sbExlZnQ6IGVsZW1lbnQuc2Nyb2xsTGVmdCxcbiAgICAgIHNjcm9sbFRvcDogZWxlbWVudC5zY3JvbGxUb3BcbiAgICB9O1xuICB9XG4gIHJldHVybiB7XG4gICAgc2Nyb2xsTGVmdDogZWxlbWVudC5wYWdlWE9mZnNldCxcbiAgICBzY3JvbGxUb3A6IGVsZW1lbnQucGFnZVlPZmZzZXRcbiAgfTtcbn1cbmZ1bmN0aW9uIGdldFBhcmVudE5vZGUobm9kZSkge1xuICBpZiAoZ2V0Tm9kZU5hbWUobm9kZSkgPT09ICdodG1sJykge1xuICAgIHJldHVybiBub2RlO1xuICB9XG4gIGNvbnN0IHJlc3VsdCA9XG4gIC8vIFN0ZXAgaW50byB0aGUgc2hhZG93IERPTSBvZiB0aGUgcGFyZW50IG9mIGEgc2xvdHRlZCBub2RlLlxuICBub2RlLmFzc2lnbmVkU2xvdCB8fFxuICAvLyBET00gRWxlbWVudCBkZXRlY3RlZC5cbiAgbm9kZS5wYXJlbnROb2RlIHx8XG4gIC8vIFNoYWRvd1Jvb3QgZGV0ZWN0ZWQuXG4gIGlzU2hhZG93Um9vdChub2RlKSAmJiBub2RlLmhvc3QgfHxcbiAgLy8gRmFsbGJhY2suXG4gIGdldERvY3VtZW50RWxlbWVudChub2RlKTtcbiAgcmV0dXJuIGlzU2hhZG93Um9vdChyZXN1bHQpID8gcmVzdWx0Lmhvc3QgOiByZXN1bHQ7XG59XG5mdW5jdGlvbiBnZXROZWFyZXN0T3ZlcmZsb3dBbmNlc3Rvcihub2RlKSB7XG4gIGNvbnN0IHBhcmVudE5vZGUgPSBnZXRQYXJlbnROb2RlKG5vZGUpO1xuICBpZiAoaXNMYXN0VHJhdmVyc2FibGVOb2RlKHBhcmVudE5vZGUpKSB7XG4gICAgcmV0dXJuIG5vZGUub3duZXJEb2N1bWVudCA/IG5vZGUub3duZXJEb2N1bWVudC5ib2R5IDogbm9kZS5ib2R5O1xuICB9XG4gIGlmIChpc0hUTUxFbGVtZW50KHBhcmVudE5vZGUpICYmIGlzT3ZlcmZsb3dFbGVtZW50KHBhcmVudE5vZGUpKSB7XG4gICAgcmV0dXJuIHBhcmVudE5vZGU7XG4gIH1cbiAgcmV0dXJuIGdldE5lYXJlc3RPdmVyZmxvd0FuY2VzdG9yKHBhcmVudE5vZGUpO1xufVxuZnVuY3Rpb24gZ2V0T3ZlcmZsb3dBbmNlc3RvcnMobm9kZSwgbGlzdCwgdHJhdmVyc2VJZnJhbWVzKSB7XG4gIHZhciBfbm9kZSRvd25lckRvY3VtZW50MjtcbiAgaWYgKGxpc3QgPT09IHZvaWQgMCkge1xuICAgIGxpc3QgPSBbXTtcbiAgfVxuICBpZiAodHJhdmVyc2VJZnJhbWVzID09PSB2b2lkIDApIHtcbiAgICB0cmF2ZXJzZUlmcmFtZXMgPSB0cnVlO1xuICB9XG4gIGNvbnN0IHNjcm9sbGFibGVBbmNlc3RvciA9IGdldE5lYXJlc3RPdmVyZmxvd0FuY2VzdG9yKG5vZGUpO1xuICBjb25zdCBpc0JvZHkgPSBzY3JvbGxhYmxlQW5jZXN0b3IgPT09ICgoX25vZGUkb3duZXJEb2N1bWVudDIgPSBub2RlLm93bmVyRG9jdW1lbnQpID09IG51bGwgPyB2b2lkIDAgOiBfbm9kZSRvd25lckRvY3VtZW50Mi5ib2R5KTtcbiAgY29uc3Qgd2luID0gZ2V0V2luZG93KHNjcm9sbGFibGVBbmNlc3Rvcik7XG4gIGlmIChpc0JvZHkpIHtcbiAgICByZXR1cm4gbGlzdC5jb25jYXQod2luLCB3aW4udmlzdWFsVmlld3BvcnQgfHwgW10sIGlzT3ZlcmZsb3dFbGVtZW50KHNjcm9sbGFibGVBbmNlc3RvcikgPyBzY3JvbGxhYmxlQW5jZXN0b3IgOiBbXSwgd2luLmZyYW1lRWxlbWVudCAmJiB0cmF2ZXJzZUlmcmFtZXMgPyBnZXRPdmVyZmxvd0FuY2VzdG9ycyh3aW4uZnJhbWVFbGVtZW50KSA6IFtdKTtcbiAgfVxuICByZXR1cm4gbGlzdC5jb25jYXQoc2Nyb2xsYWJsZUFuY2VzdG9yLCBnZXRPdmVyZmxvd0FuY2VzdG9ycyhzY3JvbGxhYmxlQW5jZXN0b3IsIFtdLCB0cmF2ZXJzZUlmcmFtZXMpKTtcbn1cblxuZXhwb3J0IHsgZ2V0Q29tcHV0ZWRTdHlsZSwgZ2V0Q29udGFpbmluZ0Jsb2NrLCBnZXREb2N1bWVudEVsZW1lbnQsIGdldE5lYXJlc3RPdmVyZmxvd0FuY2VzdG9yLCBnZXROb2RlTmFtZSwgZ2V0Tm9kZVNjcm9sbCwgZ2V0T3ZlcmZsb3dBbmNlc3RvcnMsIGdldFBhcmVudE5vZGUsIGdldFdpbmRvdywgaXNDb250YWluaW5nQmxvY2ssIGlzRWxlbWVudCwgaXNIVE1MRWxlbWVudCwgaXNMYXN0VHJhdmVyc2FibGVOb2RlLCBpc05vZGUsIGlzT3ZlcmZsb3dFbGVtZW50LCBpc1NoYWRvd1Jvb3QsIGlzVGFibGVFbGVtZW50LCBpc1dlYktpdCB9O1xuIl0sIm5hbWVzIjpbImdldE5vZGVOYW1lIiwibm9kZSIsImlzTm9kZSIsIm5vZGVOYW1lIiwidG9Mb3dlckNhc2UiLCJnZXRXaW5kb3ciLCJfbm9kZSRvd25lckRvY3VtZW50Iiwib3duZXJEb2N1bWVudCIsImRlZmF1bHRWaWV3Iiwid2luZG93IiwiZ2V0RG9jdW1lbnRFbGVtZW50IiwiX3JlZiIsImRvY3VtZW50IiwiZG9jdW1lbnRFbGVtZW50IiwidmFsdWUiLCJOb2RlIiwiaXNFbGVtZW50IiwiRWxlbWVudCIsImlzSFRNTEVsZW1lbnQiLCJIVE1MRWxlbWVudCIsImlzU2hhZG93Um9vdCIsIlNoYWRvd1Jvb3QiLCJpc092ZXJmbG93RWxlbWVudCIsImVsZW1lbnQiLCJvdmVyZmxvdyIsIm92ZXJmbG93WCIsIm92ZXJmbG93WSIsImRpc3BsYXkiLCJnZXRDb21wdXRlZFN0eWxlIiwidGVzdCIsImluY2x1ZGVzIiwiaXNUYWJsZUVsZW1lbnQiLCJpc0NvbnRhaW5pbmdCbG9jayIsIndlYmtpdCIsImlzV2ViS2l0IiwiY3NzIiwidHJhbnNmb3JtIiwicGVyc3BlY3RpdmUiLCJjb250YWluZXJUeXBlIiwiYmFja2Ryb3BGaWx0ZXIiLCJmaWx0ZXIiLCJzb21lIiwid2lsbENoYW5nZSIsImNvbnRhaW4iLCJnZXRDb250YWluaW5nQmxvY2siLCJjdXJyZW50Tm9kZSIsImdldFBhcmVudE5vZGUiLCJpc0xhc3RUcmF2ZXJzYWJsZU5vZGUiLCJDU1MiLCJzdXBwb3J0cyIsImdldE5vZGVTY3JvbGwiLCJzY3JvbGxMZWZ0Iiwic2Nyb2xsVG9wIiwicGFnZVhPZmZzZXQiLCJwYWdlWU9mZnNldCIsInJlc3VsdCIsImFzc2lnbmVkU2xvdCIsInBhcmVudE5vZGUiLCJob3N0IiwiZ2V0TmVhcmVzdE92ZXJmbG93QW5jZXN0b3IiLCJib2R5IiwiZ2V0T3ZlcmZsb3dBbmNlc3RvcnMiLCJsaXN0IiwidHJhdmVyc2VJZnJhbWVzIiwiX25vZGUkb3duZXJEb2N1bWVudDIiLCJzY3JvbGxhYmxlQW5jZXN0b3IiLCJpc0JvZHkiLCJ3aW4iLCJjb25jYXQiLCJ2aXN1YWxWaWV3cG9ydCIsImZyYW1lRWxlbWVudCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@floating-ui/utils/dist/floating-ui.utils.dom.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@floating-ui/utils/dist/floating-ui.utils.mjs":
/*!********************************************************************!*\
  !*** ./node_modules/@floating-ui/utils/dist/floating-ui.utils.mjs ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   alignments: () => (/* binding */ alignments),\n/* harmony export */   clamp: () => (/* binding */ clamp),\n/* harmony export */   createCoords: () => (/* binding */ createCoords),\n/* harmony export */   evaluate: () => (/* binding */ evaluate),\n/* harmony export */   expandPaddingObject: () => (/* binding */ expandPaddingObject),\n/* harmony export */   floor: () => (/* binding */ floor),\n/* harmony export */   getAlignment: () => (/* binding */ getAlignment),\n/* harmony export */   getAlignmentAxis: () => (/* binding */ getAlignmentAxis),\n/* harmony export */   getAlignmentSides: () => (/* binding */ getAlignmentSides),\n/* harmony export */   getAxisLength: () => (/* binding */ getAxisLength),\n/* harmony export */   getExpandedPlacements: () => (/* binding */ getExpandedPlacements),\n/* harmony export */   getOppositeAlignmentPlacement: () => (/* binding */ getOppositeAlignmentPlacement),\n/* harmony export */   getOppositeAxis: () => (/* binding */ getOppositeAxis),\n/* harmony export */   getOppositeAxisPlacements: () => (/* binding */ getOppositeAxisPlacements),\n/* harmony export */   getOppositePlacement: () => (/* binding */ getOppositePlacement),\n/* harmony export */   getPaddingObject: () => (/* binding */ getPaddingObject),\n/* harmony export */   getSide: () => (/* binding */ getSide),\n/* harmony export */   getSideAxis: () => (/* binding */ getSideAxis),\n/* harmony export */   max: () => (/* binding */ max),\n/* harmony export */   min: () => (/* binding */ min),\n/* harmony export */   placements: () => (/* binding */ placements),\n/* harmony export */   rectToClientRect: () => (/* binding */ rectToClientRect),\n/* harmony export */   round: () => (/* binding */ round),\n/* harmony export */   sides: () => (/* binding */ sides)\n/* harmony export */ });\n/**\n * Custom positioning reference element.\n * @see https://floating-ui.com/docs/virtual-elements\n */ const sides = [\n    \"top\",\n    \"right\",\n    \"bottom\",\n    \"left\"\n];\nconst alignments = [\n    \"start\",\n    \"end\"\n];\nconst placements = /*#__PURE__*/ sides.reduce((acc, side)=>acc.concat(side, side + \"-\" + alignments[0], side + \"-\" + alignments[1]), []);\nconst min = Math.min;\nconst max = Math.max;\nconst round = Math.round;\nconst floor = Math.floor;\nconst createCoords = (v)=>({\n        x: v,\n        y: v\n    });\nconst oppositeSideMap = {\n    left: \"right\",\n    right: \"left\",\n    bottom: \"top\",\n    top: \"bottom\"\n};\nconst oppositeAlignmentMap = {\n    start: \"end\",\n    end: \"start\"\n};\nfunction clamp(start, value, end) {\n    return max(start, min(value, end));\n}\nfunction evaluate(value, param) {\n    return typeof value === \"function\" ? value(param) : value;\n}\nfunction getSide(placement) {\n    return placement.split(\"-\")[0];\n}\nfunction getAlignment(placement) {\n    return placement.split(\"-\")[1];\n}\nfunction getOppositeAxis(axis) {\n    return axis === \"x\" ? \"y\" : \"x\";\n}\nfunction getAxisLength(axis) {\n    return axis === \"y\" ? \"height\" : \"width\";\n}\nfunction getSideAxis(placement) {\n    return [\n        \"top\",\n        \"bottom\"\n    ].includes(getSide(placement)) ? \"y\" : \"x\";\n}\nfunction getAlignmentAxis(placement) {\n    return getOppositeAxis(getSideAxis(placement));\n}\nfunction getAlignmentSides(placement, rects, rtl) {\n    if (rtl === void 0) {\n        rtl = false;\n    }\n    const alignment = getAlignment(placement);\n    const alignmentAxis = getAlignmentAxis(placement);\n    const length = getAxisLength(alignmentAxis);\n    let mainAlignmentSide = alignmentAxis === \"x\" ? alignment === (rtl ? \"end\" : \"start\") ? \"right\" : \"left\" : alignment === \"start\" ? \"bottom\" : \"top\";\n    if (rects.reference[length] > rects.floating[length]) {\n        mainAlignmentSide = getOppositePlacement(mainAlignmentSide);\n    }\n    return [\n        mainAlignmentSide,\n        getOppositePlacement(mainAlignmentSide)\n    ];\n}\nfunction getExpandedPlacements(placement) {\n    const oppositePlacement = getOppositePlacement(placement);\n    return [\n        getOppositeAlignmentPlacement(placement),\n        oppositePlacement,\n        getOppositeAlignmentPlacement(oppositePlacement)\n    ];\n}\nfunction getOppositeAlignmentPlacement(placement) {\n    return placement.replace(/start|end/g, (alignment)=>oppositeAlignmentMap[alignment]);\n}\nfunction getSideList(side, isStart, rtl) {\n    const lr = [\n        \"left\",\n        \"right\"\n    ];\n    const rl = [\n        \"right\",\n        \"left\"\n    ];\n    const tb = [\n        \"top\",\n        \"bottom\"\n    ];\n    const bt = [\n        \"bottom\",\n        \"top\"\n    ];\n    switch(side){\n        case \"top\":\n        case \"bottom\":\n            if (rtl) return isStart ? rl : lr;\n            return isStart ? lr : rl;\n        case \"left\":\n        case \"right\":\n            return isStart ? tb : bt;\n        default:\n            return [];\n    }\n}\nfunction getOppositeAxisPlacements(placement, flipAlignment, direction, rtl) {\n    const alignment = getAlignment(placement);\n    let list = getSideList(getSide(placement), direction === \"start\", rtl);\n    if (alignment) {\n        list = list.map((side)=>side + \"-\" + alignment);\n        if (flipAlignment) {\n            list = list.concat(list.map(getOppositeAlignmentPlacement));\n        }\n    }\n    return list;\n}\nfunction getOppositePlacement(placement) {\n    return placement.replace(/left|right|bottom|top/g, (side)=>oppositeSideMap[side]);\n}\nfunction expandPaddingObject(padding) {\n    return {\n        top: 0,\n        right: 0,\n        bottom: 0,\n        left: 0,\n        ...padding\n    };\n}\nfunction getPaddingObject(padding) {\n    return typeof padding !== \"number\" ? expandPaddingObject(padding) : {\n        top: padding,\n        right: padding,\n        bottom: padding,\n        left: padding\n    };\n}\nfunction rectToClientRect(rect) {\n    return {\n        ...rect,\n        top: rect.y,\n        left: rect.x,\n        right: rect.x + rect.width,\n        bottom: rect.y + rect.height\n    };\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGZsb2F0aW5nLXVpL3V0aWxzL2Rpc3QvZmxvYXRpbmctdWkudXRpbHMubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBOzs7Q0FHQyxHQUVELE1BQU1BLFFBQVE7SUFBQztJQUFPO0lBQVM7SUFBVTtDQUFPO0FBQ2hELE1BQU1DLGFBQWE7SUFBQztJQUFTO0NBQU07QUFDbkMsTUFBTUMsYUFBYSxXQUFXLEdBQUVGLE1BQU1HLE1BQU0sQ0FBQyxDQUFDQyxLQUFLQyxPQUFTRCxJQUFJRSxNQUFNLENBQUNELE1BQU1BLE9BQU8sTUFBTUosVUFBVSxDQUFDLEVBQUUsRUFBRUksT0FBTyxNQUFNSixVQUFVLENBQUMsRUFBRSxHQUFHLEVBQUU7QUFDeEksTUFBTU0sTUFBTUMsS0FBS0QsR0FBRztBQUNwQixNQUFNRSxNQUFNRCxLQUFLQyxHQUFHO0FBQ3BCLE1BQU1DLFFBQVFGLEtBQUtFLEtBQUs7QUFDeEIsTUFBTUMsUUFBUUgsS0FBS0csS0FBSztBQUN4QixNQUFNQyxlQUFlQyxDQUFBQSxJQUFNO1FBQ3pCQyxHQUFHRDtRQUNIRSxHQUFHRjtJQUNMO0FBQ0EsTUFBTUcsa0JBQWtCO0lBQ3RCQyxNQUFNO0lBQ05DLE9BQU87SUFDUEMsUUFBUTtJQUNSQyxLQUFLO0FBQ1A7QUFDQSxNQUFNQyx1QkFBdUI7SUFDM0JDLE9BQU87SUFDUEMsS0FBSztBQUNQO0FBQ0EsU0FBU0MsTUFBTUYsS0FBSyxFQUFFRyxLQUFLLEVBQUVGLEdBQUc7SUFDOUIsT0FBT2QsSUFBSWEsT0FBT2YsSUFBSWtCLE9BQU9GO0FBQy9CO0FBQ0EsU0FBU0csU0FBU0QsS0FBSyxFQUFFRSxLQUFLO0lBQzVCLE9BQU8sT0FBT0YsVUFBVSxhQUFhQSxNQUFNRSxTQUFTRjtBQUN0RDtBQUNBLFNBQVNHLFFBQVFDLFNBQVM7SUFDeEIsT0FBT0EsVUFBVUMsS0FBSyxDQUFDLElBQUksQ0FBQyxFQUFFO0FBQ2hDO0FBQ0EsU0FB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Qy9CLE9BQU8sT0FBT0EsWUFBWSxXQUFXRCxvQkFBb0JDLFdBQVc7UUFDbEU1QyxLQUFLNEM7UUFDTDlDLE9BQU84QztRQUNQN0MsUUFBUTZDO1FBQ1IvQyxNQUFNK0M7SUFDUjtBQUNGO0FBQ0EsU0FBU0UsaUJBQWlCQyxJQUFJO0lBQzVCLE9BQU87UUFDTCxHQUFHQSxJQUFJO1FBQ1AvQyxLQUFLK0MsS0FBS3BELENBQUM7UUFDWEUsTUFBTWtELEtBQUtyRCxDQUFDO1FBQ1pJLE9BQU9pRCxLQUFLckQsQ0FBQyxHQUFHcUQsS0FBS0MsS0FBSztRQUMxQmpELFFBQVFnRCxLQUFLcEQsQ0FBQyxHQUFHb0QsS0FBS0UsTUFBTTtJQUM5QjtBQUNGO0FBRXlXIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vb3Blbi1wcm8tbmV4dC8uL25vZGVfbW9kdWxlcy9AZmxvYXRpbmctdWkvdXRpbHMvZGlzdC9mbG9hdGluZy11aS51dGlscy5tanM/NWFlYSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEN1c3RvbSBwb3NpdGlvbmluZyByZWZlcmVuY2UgZWxlbWVudC5cbiAqIEBzZWUgaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy92aXJ0dWFsLWVsZW1lbnRzXG4gKi9cblxuY29uc3Qgc2lkZXMgPSBbJ3RvcCcsICdyaWdodCcsICdib3R0b20nLCAnbGVmdCddO1xuY29uc3QgYWxpZ25tZW50cyA9IFsnc3RhcnQnLCAnZW5kJ107XG5jb25zdCBwbGFjZW1lbnRzID0gLyojX19QVVJFX18qL3NpZGVzLnJlZHVjZSgoYWNjLCBzaWRlKSA9PiBhY2MuY29uY2F0KHNpZGUsIHNpZGUgKyBcIi1cIiArIGFsaWdubWVudHNbMF0sIHNpZGUgKyBcIi1cIiArIGFsaWdubWVudHNbMV0pLCBbXSk7XG5jb25zdCBtaW4gPSBNYXRoLm1pbjtcbmNvbnN0IG1heCA9IE1hdGgubWF4O1xuY29uc3Qgcm91bmQgPSBNYXRoLnJvdW5kO1xuY29uc3QgZmxvb3IgPSBNYXRoLmZsb29yO1xuY29uc3QgY3JlYXRlQ29vcmRzID0gdiA9PiAoe1xuICB4OiB2LFxuICB5OiB2XG59KTtcbmNvbnN0IG9wcG9zaXRlU2lkZU1hcCA9IHtcbiAgbGVmdDogJ3JpZ2h0JyxcbiAgcmlnaHQ6ICdsZWZ0JyxcbiAgYm90dG9tOiAndG9wJyxcbiAgdG9wOiAnYm90dG9tJ1xufTtcbmNvbnN0IG9wcG9zaXRlQWxpZ25tZW50TWFwID0ge1xuICBzdGFydDogJ2VuZCcsXG4gIGVuZDogJ3N0YXJ0J1xufTtcbmZ1bmN0aW9uIGNsYW1wKHN0YXJ0LCB2YWx1ZSwgZW5kKSB7XG4gIHJldHVybiBtYXgoc3RhcnQsIG1pbih2YWx1ZSwgZW5kKSk7XG59XG5mdW5jdGlvbiBldmFsdWF0ZSh2YWx1ZSwgcGFyYW0pIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJyA/IHZhbHVlKHBhcmFtKSA6IHZhbHVlO1xufVxuZnVuY3Rpb24gZ2V0U2lkZShwbGFjZW1lbnQpIHtcbiAgcmV0dXJuIHBsYWNlbWVudC5zcGxpdCgnLScpWzBdO1xufVxuZnVuY3Rpb24gZ2V0QWxpZ25tZW50KHBsYWNlbWVudCkge1xuICByZXR1cm4gcGxhY2VtZW50LnNwbGl0KCctJylbMV07XG59XG5mdW5jdGlvbiBnZXRPcHBvc2l0ZUF4aXMoYXhpcykge1xuICByZXR1cm4gYXhpcyA9PT0gJ3gnID8gJ3knIDogJ3gnO1xufVxuZnVuY3Rpb24gZ2V0QXhpc0xlbmd0aChheGlzKSB7XG4gIHJldHVybiBheGlzID09PSAneScgPyAnaGVpZ2h0JyA6ICd3aWR0aCc7XG59XG5mdW5jdGlvbiBnZXRTaWRlQXhpcyhwbGFjZW1lbnQpIHtcbiAgcmV0dXJuIFsndG9wJywgJ2JvdHRvbSddLmluY2x1ZGVzKGdldFNpZGUocGxhY2VtZW50KSkgPyAneScgOiAneCc7XG59XG5mdW5jdGlvbiBnZXRBbGlnbm1lbnRBeGlzKHBsYWNlbWVudCkge1xuICByZXR1cm4gZ2V0T3Bwb3NpdGVBeGlzKGdldFNpZGVBeGlzKHBsYWNlbWVudCkpO1xufVxuZnVuY3Rpb24gZ2V0QWxpZ25tZW50U2lkZXMocGxhY2VtZW50LCByZWN0cywgcnRsKSB7XG4gIGlmIChydGwgPT09IHZvaWQgMCkge1xuICAgIHJ0bCA9IGZhbHNlO1xuICB9XG4gIGNvbnN0IGFsaWdubWVudCA9IGdldEFsaWdubWVudChwbGFjZW1lbnQpO1xuICBjb25zdCBhbGlnbm1lbnRBeGlzID0gZ2V0QWxpZ25tZW50QXhpcyhwbGFjZW1lbnQpO1xuICBjb25zdCBsZW5ndGggPSBnZXRBeGlzTGVuZ3RoKGFsaWdubWVudEF4aXMpO1xuICBsZXQgbWFpbkFsaWdubWVudFNpZGUgPSBhbGlnbm1lbnRBeGlzID09PSAneCcgPyBhbGlnbm1lbnQgPT09IChydGwgPyAnZW5kJyA6ICdzdGFydCcpID8gJ3JpZ2h0JyA6ICdsZWZ0JyA6IGFsaWdubWVudCA9PT0gJ3N0YXJ0JyA/ICdib3R0b20nIDogJ3RvcCc7XG4gIGlmIChyZWN0cy5yZWZlcmVuY2VbbGVuZ3RoXSA+IHJlY3RzLmZsb2F0aW5nW2xlbmd0aF0pIHtcbiAgICBtYWluQWxpZ25tZW50U2lkZSA9IGdldE9wcG9zaXRlUGxhY2VtZW50KG1haW5BbGlnbm1lbnRTaWRlKTtcbiAgfVxuICByZXR1cm4gW21haW5BbGlnbm1lbnRTaWRlLCBnZXRPcHBvc2l0ZVBsYWNlbWVudChtYWluQWxpZ25tZW50U2lkZSldO1xufVxuZnVuY3Rpb24gZ2V0RXhwYW5kZWRQbGFjZW1lbnRzKHBsYWNlbWVudCkge1xuICBjb25zdCBvcHBvc2l0ZVBsYWNlbWVudCA9IGdldE9wcG9zaXRlUGxhY2VtZW50KHBsYWNlbWVudCk7XG4gIHJldHVybiBbZ2V0T3Bwb3NpdGVBbGlnbm1lbnRQbGFjZW1lbnQocGxhY2VtZW50KSwgb3Bwb3NpdGVQbGFjZW1lbnQsIGdldE9wcG9zaXRlQWxpZ25tZW50UGxhY2VtZW50KG9wcG9zaXRlUGxhY2VtZW50KV07XG59XG5mdW5jdGlvbiBnZXRPcHBvc2l0ZUFsaWdubWVudFBsYWNlbWVudChwbGFjZW1lbnQpIHtcbiAgcmV0dXJuIHBsYWNlbWVudC5yZXBsYWNlKC9zdGFydHxlbmQvZywgYWxpZ25tZW50ID0+IG9wcG9zaXRlQWxpZ25tZW50TWFwW2FsaWdubWVudF0pO1xufVxuZnVuY3Rpb24gZ2V0U2lkZUxpc3Qoc2lkZSwgaXNTdGFydCwgcnRsKSB7XG4gIGNvbnN0IGxyID0gWydsZWZ0JywgJ3JpZ2h0J107XG4gIGNvbnN0IHJsID0gWydyaWdodCcsICdsZWZ0J107XG4gIGNvbnN0IHRiID0gWyd0b3AnLCAnYm90dG9tJ107XG4gIGNvbnN0IGJ0ID0gWydib3R0b20nLCAndG9wJ107XG4gIHN3aXRjaCAoc2lkZSkge1xuICAgIGNhc2UgJ3RvcCc6XG4gICAgY2FzZSAnYm90dG9tJzpcbiAgICAgIGlmIChydGwpIHJldHVybiBpc1N0YXJ0ID8gcmwgOiBscjtcbiAgICAgIHJldHVybiBpc1N0YXJ0ID8gbHIgOiBybDtcbiAgICBjYXNlICdsZWZ0JzpcbiAgICBjYXNlICdyaWdodCc6XG4gICAgICByZXR1cm4gaXNTdGFydCA/IHRiIDogYnQ7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBbXTtcbiAgfVxufVxuZnVuY3Rpb24gZ2V0T3Bwb3NpdGVBeGlzUGxhY2VtZW50cyhwbGFjZW1lbnQsIGZsaXBBbGlnbm1lbnQsIGRpcmVjdGlvbiwgcnRsKSB7XG4gIGNvbnN0IGFsaWdubWVudCA9IGdldEFsaWdubWVudChwbGFjZW1lbnQpO1xuICBsZXQgbGlzdCA9IGdldFNpZGVMaXN0KGdldFNpZGUocGxhY2VtZW50KSwgZGlyZWN0aW9uID09PSAnc3RhcnQnLCBydGwpO1xuICBpZiAoYWxpZ25tZW50KSB7XG4gICAgbGlzdCA9IGxpc3QubWFwKHNpZGUgPT4gc2lkZSArIFwiLVwiICsgYWxpZ25tZW50KTtcbiAgICBpZiAoZmxpcEFsaWdubWVudCkge1xuICAgICAgbGlzdCA9IGxpc3QuY29uY2F0KGxpc3QubWFwKGdldE9wcG9zaXRlQWxpZ25tZW50UGxhY2VtZW50KSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBsaXN0O1xufVxuZnVuY3Rpb24gZ2V0T3Bwb3NpdGVQbGFjZW1lbnQocGxhY2VtZW50KSB7XG4gIHJldHVybiBwbGFjZW1lbnQucmVwbGFjZSgvbGVmdHxyaWdodHxib3R0b218dG9wL2csIHNpZGUgPT4gb3Bwb3NpdGVTaWRlTWFwW3NpZGVdKTtcbn1cbmZ1bmN0aW9uIGV4cGFuZFBhZGRpbmdPYmplY3QocGFkZGluZykge1xuICByZXR1cm4ge1xuICAgIHRvcDogMCxcbiAgICByaWdodDogMCxcbiAgICBib3R0b206IDAsXG4gICAgbGVmdDogMCxcbiAgICAuLi5wYWRkaW5nXG4gIH07XG59XG5mdW5jdGlvbiBnZXRQYWRkaW5nT2JqZWN0KHBhZGRpbmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBwYWRkaW5nICE9PSAnbnVtYmVyJyA/IGV4cGFuZFBhZGRpbmdPYmplY3QocGFkZGluZykgOiB7XG4gICAgdG9wOiBwYWRkaW5nLFxuICAgIHJpZ2h0OiBwYWRkaW5nLFxuICAgIGJvdHRvbTogcGFkZGluZyxcbiAgICBsZWZ0OiBwYWRkaW5nXG4gIH07XG59XG5mdW5jdGlvbiByZWN0VG9DbGllbnRSZWN0KHJlY3QpIHtcbiAgcmV0dXJuIHtcbiAgICAuLi5yZWN0LFxuICAgIHRvcDogcmVjdC55LFxuICAgIGxlZnQ6IHJlY3QueCxcbiAgICByaWdodDogcmVjdC54ICsgcmVjdC53aWR0aCxcbiAgICBib3R0b206IHJlY3QueSArIHJlY3QuaGVpZ2h0XG4gIH07XG59XG5cbmV4cG9ydCB7IGFsaWdubWVudHMsIGNsYW1wLCBjcmVhdGVDb29yZHMsIGV2YWx1YXRlLCBleHBhbmRQYWRkaW5nT2JqZWN0LCBmbG9vciwgZ2V0QWxpZ25tZW50LCBnZXRBbGlnbm1lbnRBeGlzLCBnZXRBbGlnbm1lbnRTaWRlcywgZ2V0QXhpc0xlbmd0aCwgZ2V0RXhwYW5kZWRQbGFjZW1lbnRzLCBnZXRPcHBvc2l0ZUFsaWdubWVudFBsYWNlbWVudCwgZ2V0T3Bwb3NpdGVBeGlzLCBnZXRPcHBvc2l0ZUF4aXNQbGFjZW1lbnRzLCBnZXRPcHBvc2l0ZVBsYWNlbWVudCwgZ2V0UGFkZGluZ09iamVjdCwgZ2V0U2lkZSwgZ2V0U2lkZUF4aXMsIG1heCwgbWluLCBwbGFjZW1lbnRzLCByZWN0VG9DbGllbnRSZWN0LCByb3VuZCwgc2lkZXMgfTtcbiJdLCJuYW1lcyI6WyJzaWRlcyIsImFsaWdubWVudHMiLCJwbGFjZW1lbnRzIiwicmVkdWNlIiwiYWNjIiwic2lkZSIsImNvbmNhdCIsIm1pbiIsIk1hdGgiLCJtYXgiLCJyb3VuZCIsImZsb29yIiwiY3JlYXRlQ29vcmRzIiwidiIsIngiLCJ5Iiwib3Bwb3NpdGVTaWRlTWFwIiwibGVmdCIsInJpZ2h0IiwiYm90dG9tIiwidG9wIiwib3Bwb3NpdGVBbGlnbm1lbnRNYXAiLCJzdGFydCIsImVuZCIsImNsYW1wIiwidmFsdWUiLCJldmFsdWF0ZSIsInBhcmFtIiwiZ2V0U2lkZSIsInBsYWNlbWVudCIsInNwbGl0IiwiZ2V0QWxpZ25tZW50IiwiZ2V0T3Bwb3NpdGVBeGlzIiwiYXhpcyIsImdldEF4aXNMZW5ndGgiLCJnZXRTaWRlQXhpcyIsImluY2x1ZGVzIiwiZ2V0QWxpZ25tZW50QXhpcyIsImdldEFsaWdubWVudFNpZGVzIiwicmVjdHMiLCJydGwiLCJhbGlnbm1lbnQiLCJhbGlnbm1lbnRBeGlzIiwibGVuZ3RoIiwibWFpbkFsaWdubWVudFNpZGUiLCJyZWZlcmVuY2UiLCJmbG9hdGluZyIsImdldE9wcG9zaXRlUGxhY2VtZW50IiwiZ2V0RXhwYW5kZWRQbGFjZW1lbnRzIiwib3Bwb3NpdGVQbGFjZW1lbnQiLCJnZXRPcHBvc2l0ZUFsaWdubWVudFBsYWNlbWVudCIsInJlcGxhY2UiLCJnZXRTaWRlTGlzdCIsImlzU3RhcnQiLCJsciIsInJsIiwidGIiLCJidCIsImdldE9wcG9zaXRlQXhpc1BsYWNlbWVudHMiLCJmbGlwQWxpZ25tZW50IiwiZGlyZWN0aW9uIiwibGlzdCIsIm1hcCIsImV4cGFuZFBhZGRpbmdPYmplY3QiLCJwYWRkaW5nIiwiZ2V0UGFkZGluZ09iamVjdCIsInJlY3RUb0NsaWVudFJlY3QiLCJyZWN0Iiwid2lkdGgiLCJoZWlnaHQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@floating-ui/utils/dist/floating-ui.utils.mjs\n");

/***/ })

};
;